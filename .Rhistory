}
smt[,t] <- mt; sCt[,,t] <- Ct #saving
}
par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", ylim = c(-20, 20), xlab = "time interval", ylab = "online state mean", main = "Dynamic Params")
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.8, y=30.5, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
x <- matrix(c(xm*(2*rbeta(n=nshots, 6,8) - 1),
ym*rbeta(n=nshots, 2, 12)),
ncol = 2)
x
head(x)
coef(priormod)
{
cond <- allgameshots$globalplayerid %in% playerids & allgameshots$season %in% seasons
allgameshots_sub <- allgameshots %>% filter(cond)
Z <- allgameshots_sub %>% mutate(logr = log(r) - mean(log(r))) %>% select(logr, theta) %>% cbind(1,.)
X <- allgameshots_sub %>% select(x=xt, y=yt)
y <- allgameshots_sub %>% select(result) %>% '[['(1)
ym <- 94; xm <- 50
shots <- rep(TRUE,nrow(Z)) #no missing shots in this case
tshot <- which(shots)
nshots <- length(tshot)
iy <- which(y[!is.nan(y)] == 1)
T <- length(shots)
#initial parameters
theta <- coef(priormod)
p <- length(theta)
#Forward Filtering
#set up DGLM and initial prior
#first, set up covariates per time interval
F <- t(Z)
p <- dim(F)[1]
#theta = state vector (GLM parameters) (px1)
#F = the data...regression vectors for all t...aka the design matrix (pxT)
#G = known evolution matrix ???????
#omega = evolution errors with 0 mean and known variance matrix W
#g(.) = function to map eta to real line (logit)
mt <- theta
Ct <- diag(p)
#mt = prior mean vector
#Ct = prior covariance matrix
#(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1])
delta <- 0.99 #discount factor; "streaky parameter"
#forward filtering (FF)
smt <- matrix(rep(0,p*T), nrow=p)           #save post means
sCt <- array(rep(0,p*p*T), dim = c(p,p,T))  #save post covars
spt <- rep(NaN, T)                          #save post prob success
lmlik <- rep(0,T)                           #marg lik per time int
ishot <- 0
rtst <- array(NA, c(T,2))
#rt gets out of control when qt is very small or ft is very big
#ft is very big when:
#qt is very small when At is very small
#At is very small when Ct is very small
#Ct is very small when
}
nmc <- 1000
for(t in 1:T){
if(t %in% tshot){
#current shot attempt index, and time
ishot <- ishot + 1
ti <- tshot[ishot]
ft <- (F[,ishot]) %*% mt
At <- Ct %*% F[,ishot]/delta
qt <- (F[,ishot]) %*% At
At <- At/as.numeric(qt)
#at = Gt*mt in txtbk, but = mt here.
#Rt = Gt*Ct[t-1]*Gt' + Wt in txtbk, but = Ct/delta here
#f = F'at = F'mt
#q = F'RF = F'Ct F (1/delta)
#((lambda,theta)' | Dt-1) ~ N( (f, a), ((q, F'C/delta),(CF/delta, C)) )
#what is mu tho?
#???????????????????????
#"the samp dist of Yt depends on thetat only via the single quantity mut
#prior: (mu|Dt) ~ N(f, q)
#Vt > 0 is scale parameter aka precision of distribution...
#but precision of what??? what is b(Yt, Vt?)
#Q = q + Vt
#post:  (mu|Dt) ~ N(f*, q*)
#f* =
#what is mu???
#f = F'a which is
#prior mean and var of linear predictor, and adaptive vector
#compute approx prior Beta(r,s) params; update w/ numerical iterations for exact   values
eft <- exp(ft)   #crude initial values
rt <- (1+eft)/qt
st <- rt/eft
rt <- max(0.5, rt)
st <- max(0.5, st)
#fts = ft* = posterior mean of ????
#qts = qt* = posterior variance of something ???
#iterative numerical solution (optional)
if(iterate){
ep <- 0.5; drt <- 1; dst <- 1; xt <- matrix(c(rt, st))
while(max(drt, dst) < ep){
r0t <- psigamma(rt,0); s0t <- psigamma(st,0)
r1t <- psigamma(rt,1); s1t <- psigamma(st,1)
fxt <- c(r0t-s0t-ft, r1t+s1t-qt)
Axt <- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE)
xt <- xt - solve(Axt, fxt)
drt <- xt[1] - rt; dst <- xt[2] - st
rt <- xt[1]; st <- xt[2]
}
}
rtst[t,] <- c(rt, st)
cat(paste0("t=",t,"\t",
"rt=",rtst[t,1],"\t",
"At=",paste(collapse=" ",round(At,3)), "\n"))
# if(rt > 10000){
#   break
# }
lmlik[t] <- lgamma(rt+st) - lgamma(rt) - lgamma(st) +
lgamma(rt+y[t]) + lgamma(st+1-y[t]) - lgamma(rt+st+1) +
lgamma(2) - lgamma(1+y[t]) - lgamma(2-y[t])
rts <- rt + y[t]; sts <- st + 1-y[t] #posterior beta params
#convert to mean and variance for linear predictor
fts <- psigamma(rts,0)-psigamma(sts,0); qts <- psigamma(rts,1)+psigamma(sts,1)
spt[t] <- rts/(sts+rts)
#update state parameters
mt <- mt + (At%*%(fts-ft))
Ct <- Ct/delta - (At%*%t(At))*as.numeric(qt-qts)
Ct <- (Ct + t(Ct))/2
#c(t, rt, st, mt)
if(any(is.nan(mt))){
print("stop")
break
}
}
smt[,t] <- mt; sCt[,,t] <- Ct #saving
}
par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", ylim = c(-20, 20), xlab = "time interval", ylab = "online state mean", main = "Dynamic Params")
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.8, y=30.5, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
smt
rtst
plot_dynamics(smt)
plot_dynamics <- function(smt){
T <- dim(smt)[2]
par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters")
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.75, y=4, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
par(xpd=FALSE)
}
plot_dynamics(smt)
plot_dynamics <- function(smt){
T <- dim(smt)[2]
par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters", ylim=c(-20,20))
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.75, y=4, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
par(xpd=FALSE)
}
plot_dynamics <- function(smt){
T <- dim(smt)[2]
par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters", ylim=c(-20,20))
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.75, y=4, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
par(xpd=FALSE)
}
plot_dynamics(smt)
plot_dynamics <- function(smt){
T <- dim(smt)[2]
par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters", ylim=c(-20,20))
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.75, y=30.5, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
par(xpd=FALSE)
}
fit_dglm <- function(playerids, seasons, iterate=TRUE){
{
cond <- allgameshots$globalplayerid %in% playerids & allgameshots$season %in% seasons
allgameshots_sub <- allgameshots %>% filter(cond)
Z <- allgameshots_sub %>% mutate(logr = log(r) - mean(log(r))) %>% select(logr, theta) %>% cbind(1,.)
X <- allgameshots_sub %>% select(x=xt, y=yt)
y <- allgameshots_sub %>% select(result) %>% '[['(1)
ym <- 94; xm <- 50
shots <- rep(TRUE,nrow(Z)) #no missing shots in this case
tshot <- which(shots)
nshots <- length(tshot)
iy <- which(y[!is.nan(y)] == 1)
T <- length(shots)
#initial parameters
theta <- coef(priormod)
p <- length(theta)
#Forward Filtering
#set up DGLM and initial prior
#first, set up covariates per time interval
F <- t(Z)
p <- dim(F)[1]
#theta = state vector (GLM parameters) (px1)
#F = the data...regression vectors for all t...aka the design matrix (pxT)
#G = known evolution matrix ???????
#omega = evolution errors with 0 mean and known variance matrix W
#g(.) = function to map eta to real line (logit)
mt <- theta
Ct <- diag(p)
#mt = prior mean vector
#Ct = prior covariance matrix
#(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1])
delta <- 0.99 #discount factor; "streaky parameter"
#forward filtering (FF)
smt <- matrix(rep(0,p*T), nrow=p)           #save post means
sCt <- array(rep(0,p*p*T), dim = c(p,p,T))  #save post covars
spt <- rep(NaN, T)                          #save post prob success
lmlik <- rep(0,T)                           #marg lik per time int
ishot <- 0
rtst <- array(NA, c(T,2))
#rt gets out of control when qt is very small or ft is very big
#ft is very big when:
#qt is very small when At is very small
#At is very small when Ct is very small
#Ct is very small when
}
for(t in 1:T){
if(t %in% tshot){
#current shot attempt index, and time
ishot <- ishot + 1
ti <- tshot[ishot]
ft <- (F[,ishot]) %*% mt
At <- Ct %*% F[,ishot]/delta
qt <- (F[,ishot]) %*% At
At <- At/as.numeric(qt)
#at = Gt*mt in txtbk, but = mt here.
#Rt = Gt*Ct[t-1]*Gt' + Wt in txtbk, but = Ct/delta here
#f = F'at = F'mt
#q = F'RF = F'Ct F (1/delta)
#((lambda,theta)' | Dt-1) ~ N( (f, a), ((q, F'C/delta),(CF/delta, C)) )
#what is mu tho?
#???????????????????????
#"the samp dist of Yt depends on thetat only via the single quantity mut
#prior: (mu|Dt) ~ N(f, q)
#Vt > 0 is scale parameter aka precision of distribution...
#but precision of what??? what is b(Yt, Vt?)
#Q = q + Vt
#post:  (mu|Dt) ~ N(f*, q*)
#f* =
#what is mu???
#f = F'a which is
#prior mean and var of linear predictor, and adaptive vector
#compute approx prior Beta(r,s) params; update w/ numerical iterations for exact   values
eft <- exp(ft)   #crude initial values
rt <- (1+eft)/qt
st <- rt/eft
rt <- max(0.5, rt)
st <- max(0.5, st)
#fts = ft* = posterior mean of ????
#qts = qt* = posterior variance of something ???
#iterative numerical solution (optional)
if(iterate){
ep <- 0.5; drt <- 1; dst <- 1; xt <- matrix(c(rt, st))
while(max(drt, dst) < ep){
r0t <- psigamma(rt,0); s0t <- psigamma(st,0)
r1t <- psigamma(rt,1); s1t <- psigamma(st,1)
fxt <- c(r0t-s0t-ft, r1t+s1t-qt)
Axt <- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE)
xt <- xt - solve(Axt, fxt)
drt <- xt[1] - rt; dst <- xt[2] - st
rt <- xt[1]; st <- xt[2]
}
}
rtst[t,] <- c(rt, st)
cat(paste0("t=",t,"\t",
"rt=",rtst[t,1],"\t",
"At=",paste(collapse=" ",round(At,3)), "\n"))
# if(rt > 10000){
#   break
# }
lmlik[t] <- lgamma(rt+st) - lgamma(rt) - lgamma(st) +
lgamma(rt+y[t]) + lgamma(st+1-y[t]) - lgamma(rt+st+1) +
lgamma(2) - lgamma(1+y[t]) - lgamma(2-y[t])
rts <- rt + y[t]; sts <- st + 1-y[t] #posterior beta params
#convert to mean and variance for linear predictor
fts <- psigamma(rts,0)-psigamma(sts,0); qts <- psigamma(rts,1)+psigamma(sts,1)
spt[t] <- rts/(sts+rts)
#update state parameters
mt <- mt + (At%*%(fts-ft))
Ct <- Ct/delta - (At%*%t(At))*as.numeric(qt-qts)
Ct <- (Ct + t(Ct))/2
#c(t, rt, st, mt)
if(any(is.nan(mt))){
print("stop")
break
}
}
smt[,t] <- mt; sCt[,,t] <- Ct #saving
}
# par(xpd=TRUE)
# plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters")
# lines(smt[2,],type="l", col = "orange")
# lines(smt[3,],type="l", col = "yellow")
# legend(x=T*.75, y=4, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
# plot(0,0,type="n",xlim = c(0,T),ylim=c(0,1), ylab = "probability", xlab = "time index", main = "DGLM Predictions")
# points(tshot, spt[tshot], pch=4, col = "blue")
# points(tshot, y[tshot], pch=1, col = "red")
# legend(x=T*.8, y=1.21, legend=c("probability", "outcome"), pch = c(4,1), col=c("blue", "red"))
#Backward sampling
nmc <- 1000
#save posterior means and posterior success probs
MCtheta <- array(0, c(p, T, nmc))
MCq <- array(0, c(T, nmc))
#begin BS at timeunit T
thetat <- rmvnorm(n=nmc, smt[,T], sCt[,,T])
MCtheta[,T,] <- t(thetat)
MCq[T,] <- 1/(1+exp(-thetat %*% F[,nshots]))
#then recurse backwards
ishot <- nshots + 1
for(t in (T-1):1){
if(t %in% tshot){
ht = (1-delta)*t(array(smt[,t], c(dim(smt)[1], nmc))) + delta*thetat
#run a simulation for each row of ht and each 3rd dim of sCt
thetat <- t(apply(ht, 1, rmvnorm, n=1, sigma = sCt[,,t]*(1-delta)))
MCtheta[,t,] <- t(thetat)
ishot <- ishot - 1; ti <- tshot[ishot]
MCq[t,] <- 1/(1+exp(-thetat %*% F[,ishot]))
}
}
return(list(smt=smt,sCt=sCt,spt=spt,MCtheta=MCtheta,MCq=MCq,rtst=rtst))
}
dglm1 <- fit_dglm(playerseasons[1,1], playerseasons[1,2])
dglm2 <- fit_dglm(playerseasons[2,1], playerseasons[2,2])
dglm3 <- fit_dglm(playerseasons[3,1], playerseasons[3,2])
dglm4 <- fit_dglm(playerseasons[4,1], playerseasons[4,2])
fit_dglm <- function(playerids, seasons, iterate=TRUE){
{
cond <- allgameshots$globalplayerid %in% playerids & allgameshots$season %in% seasons
allgameshots_sub <- allgameshots %>% filter(cond)
Z <- allgameshots_sub %>% mutate(logr = log(r) - mean(log(r))) %>% select(logr, theta) %>% cbind(1,.)
X <- allgameshots_sub %>% select(x=xt, y=yt)
y <- allgameshots_sub %>% select(result) %>% '[['(1)
ym <- 94; xm <- 50
shots <- rep(TRUE,nrow(Z)) #no missing shots in this case
tshot <- which(shots)
nshots <- length(tshot)
iy <- which(y[!is.nan(y)] == 1)
T <- length(shots)
#initial parameters
theta <- coef(priormod)
p <- length(theta)
#Forward Filtering
#set up DGLM and initial prior
#first, set up covariates per time interval
F <- t(Z)
p <- dim(F)[1]
#theta = state vector (GLM parameters) (px1)
#F = the data...regression vectors for all t...aka the design matrix (pxT)
#G = known evolution matrix ???????
#omega = evolution errors with 0 mean and known variance matrix W
#g(.) = function to map eta to real line (logit)
mt <- theta
Ct <- diag(p)
#mt = prior mean vector
#Ct = prior covariance matrix
#(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1])
delta <- 0.99 #discount factor; "streaky parameter"
#forward filtering (FF)
smt <- matrix(rep(0,p*T), nrow=p)           #save post means
sCt <- array(rep(0,p*p*T), dim = c(p,p,T))  #save post covars
spt <- rep(NaN, T)                          #save post prob success
lmlik <- rep(0,T)                           #marg lik per time int
ishot <- 0
rtst <- array(NA, c(T,2))
#rt gets out of control when qt is very small or ft is very big
#ft is very big when:
#qt is very small when At is very small
#At is very small when Ct is very small
#Ct is very small when
}
for(t in 1:T){
if(t %in% tshot){
#current shot attempt index, and time
ishot <- ishot + 1
ti <- tshot[ishot]
ft <- (F[,ishot]) %*% mt
At <- Ct %*% F[,ishot]/delta
qt <- (F[,ishot]) %*% At
At <- At/as.numeric(qt)
#at = Gt*mt in txtbk, but = mt here.
#Rt = Gt*Ct[t-1]*Gt' + Wt in txtbk, but = Ct/delta here
#f = F'at = F'mt
#q = F'RF = F'Ct F (1/delta)
#((lambda,theta)' | Dt-1) ~ N( (f, a), ((q, F'C/delta),(CF/delta, C)) )
#what is mu tho?
#???????????????????????
#"the samp dist of Yt depends on thetat only via the single quantity mut
#prior: (mu|Dt) ~ N(f, q)
#Vt > 0 is scale parameter aka precision of distribution...
#but precision of what??? what is b(Yt, Vt?)
#Q = q + Vt
#post:  (mu|Dt) ~ N(f*, q*)
#f* =
#what is mu???
#f = F'a which is
#prior mean and var of linear predictor, and adaptive vector
#compute approx prior Beta(r,s) params; update w/ numerical iterations for exact   values
eft <- exp(ft)   #crude initial values
rt <- (1+eft)/qt
st <- rt/eft
rt <- max(0.5, rt)
st <- max(0.5, st)
#fts = ft* = posterior mean of ????
#qts = qt* = posterior variance of something ???
#iterative numerical solution (optional)
if(iterate){
ep <- 0.5; drt <- 1; dst <- 1; xt <- matrix(c(rt, st))
while(max(drt, dst) < ep){
r0t <- psigamma(rt,0); s0t <- psigamma(st,0)
r1t <- psigamma(rt,1); s1t <- psigamma(st,1)
fxt <- c(r0t-s0t-ft, r1t+s1t-qt)
Axt <- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE)
xt <- xt - solve(Axt, fxt)
drt <- xt[1] - rt; dst <- xt[2] - st
rt <- xt[1]; st <- xt[2]
}
}
rtst[t,] <- c(rt, st)
# cat(paste0("t=",t,"\t",
#            "rt=",rtst[t,1],"\t",
#            "At=",paste(collapse=" ",round(At,3)), "\n"))
#
# if(rt > 10000){
#   break
# }
lmlik[t] <- lgamma(rt+st) - lgamma(rt) - lgamma(st) +
lgamma(rt+y[t]) + lgamma(st+1-y[t]) - lgamma(rt+st+1) +
lgamma(2) - lgamma(1+y[t]) - lgamma(2-y[t])
rts <- rt + y[t]; sts <- st + 1-y[t] #posterior beta params
#convert to mean and variance for linear predictor
fts <- psigamma(rts,0)-psigamma(sts,0); qts <- psigamma(rts,1)+psigamma(sts,1)
spt[t] <- rts/(sts+rts)
#update state parameters
mt <- mt + (At%*%(fts-ft))
Ct <- Ct/delta - (At%*%t(At))*as.numeric(qt-qts)
Ct <- (Ct + t(Ct))/2
#c(t, rt, st, mt)
if(any(is.nan(mt))){
print("stop")
break
}
}
smt[,t] <- mt; sCt[,,t] <- Ct #saving
}
# par(xpd=TRUE)
# plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters")
# lines(smt[2,],type="l", col = "orange")
# lines(smt[3,],type="l", col = "yellow")
# legend(x=T*.75, y=4, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))
# plot(0,0,type="n",xlim = c(0,T),ylim=c(0,1), ylab = "probability", xlab = "time index", main = "DGLM Predictions")
# points(tshot, spt[tshot], pch=4, col = "blue")
# points(tshot, y[tshot], pch=1, col = "red")
# legend(x=T*.8, y=1.21, legend=c("probability", "outcome"), pch = c(4,1), col=c("blue", "red"))
#Backward sampling
nmc <- 1000
#save posterior means and posterior success probs
MCtheta <- array(0, c(p, T, nmc))
MCq <- array(0, c(T, nmc))
#begin BS at timeunit T
thetat <- rmvnorm(n=nmc, smt[,T], sCt[,,T])
MCtheta[,T,] <- t(thetat)
MCq[T,] <- 1/(1+exp(-thetat %*% F[,nshots]))
#then recurse backwards
ishot <- nshots + 1
for(t in (T-1):1){
if(t %in% tshot){
ht = (1-delta)*t(array(smt[,t], c(dim(smt)[1], nmc))) + delta*thetat
#run a simulation for each row of ht and each 3rd dim of sCt
thetat <- t(apply(ht, 1, rmvnorm, n=1, sigma = sCt[,,t]*(1-delta)))
MCtheta[,t,] <- t(thetat)
ishot <- ishot - 1; ti <- tshot[ishot]
MCq[t,] <- 1/(1+exp(-thetat %*% F[,ishot]))
}
}
return(list(smt=smt,sCt=sCt,spt=spt,MCtheta=MCtheta,MCq=MCq,rtst=rtst))
}
plot_dynamics(dglm1[[1]])
plot_dynamics(dglm2[[1]])
plot_dynamics(dglm3[[1]])
plot_dynamics(dglm4[[1]])
plot_dynamics(dglm2[[1]])
plot_dynamics(dglm3[[1]])
plot_posteriors(dglm3[[4]])
plot_posteriors <- function(MCtheta){
#dimensions are [p,nshots,nmc]
p <- dim(MCtheta)[1]
T <- dim(MCtheta)[2]
nmc <- dim(MCtheta)[3]
posterior_labels <- c("Posterior Intercept", "Posterior Angle", "Posterior Log Distance")
tshot <- which(!(is.na(MCtheta[1,,1]) | is.null(MCtheta[1,,1])))
for(j in 1:p){
pr <- t(apply(MCtheta[j,tshot,], 1, quantile, c(.025, .25, .5, .75, .975)))
plot(0,0, type="n", xlim = c(0,T), ylim = range(pr), main = posterior_labels[j], xlab = "time interval", ylab = "state vector element")
lines(x=tshot, y=pr[,1], col = "gray")
lines(x=tshot, y=pr[,5], col = "gray")
polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])),
col = "gray", border = NA)
lines(x=tshot, y=pr[,2], col = "black")
lines(x=tshot, y=pr[,4], col = "black")
polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])),
col = "black", border = NA)
points(x=tshot, y=pr[,3], col = "red", pch = 4)
}
}
plot_posteriors(dglm3[[4]])
