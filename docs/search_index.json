[
["7-model.html", "Chapter 7 Models", " Chapter 7 Models library(mvtnorm); library(dplyr); library(ggplot2); library(R2jags); library(pROC); library(knitr) Warning: package &#39;dplyr&#39; was built under R version 3.3.3 Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union Warning: package &#39;ggplot2&#39; was built under R version 3.3.3 Warning: package &#39;R2jags&#39; was built under R version 3.3.3 Loading required package: rjags Warning: package &#39;rjags&#39; was built under R version 3.3.2 Loading required package: coda Linked to JAGS 4.2.0 Loaded modules: basemod,bugs Attaching package: &#39;R2jags&#39; The following object is masked from &#39;package:coda&#39;: traceplot Warning: package &#39;pROC&#39; was built under R version 3.3.3 Type &#39;citation(&quot;pROC&quot;)&#39; for a citation. Attaching package: &#39;pROC&#39; The following objects are masked from &#39;package:stats&#39;: cov, smooth, var Warning: package &#39;knitr&#39; was built under R version 3.3.3 #generating shot success probabilities #theta &lt;- matrix(c(-0.5, 1.5, -5.5)) #GLM parameters (intercept, angle, log distance) datafolder &lt;- &quot;C:/Users/Nathaniel Brown/Documents/important things/DMBBall Data&quot; githubfolder &lt;- &quot;C:/Users/Nathaniel Brown/Documents/GitHub/thesis-sp18-brown-hothand/&quot; setwd(githubfolder) source(&quot;sportvu_fxns.R&quot;) Warning: package &#39;xml2&#39; was built under R version 3.3.3 id1 &lt;- 887661 id2 &lt;- 842296 For our models, we consider the shot location and the shooter identity as factors that can affect a shot outcome. For each of the following models, location is parametrized in polar coordinates, as described in the table below. theta &lt;- &quot;\\u03b8&quot; root &lt;- &quot;\\u221a&quot; pi &lt;- &quot;\\u03c0&quot; paramstr &lt;- c(&quot;distance&quot;,&quot;angle&quot;, paste0(&quot;r = &quot;,root,&quot;(x^2^ + y^2^)&quot;), paste0(theta,&quot; = arctan(x/y)&quot;), &quot;r &gt; 0&quot;, paste0(&quot;-&quot;,pi,&quot; &lt; \\u03b8 &lt; &quot;,pi)) paramtab &lt;- matrix(paramstr,ncol=3) colnames(paramtab) &lt;- c(&quot;Parameter&quot;,&quot;Formula&quot;,&quot;Range&quot;) kable(paramtab) Parameter Formula Range distance r = v(x2 + y2) r &gt; 0 angle = arctan(x/y) -p &lt; &lt; p 7.0.0.1 Generalized Linear Model The results of the credible intervals are reported for the same four players, in the same order. playerid &lt;- id2 seasons &lt;- c(2014,2015,2016,2017) priormod &lt;- glm(result ~ r + theta, data=allgameshots %&gt;% filter(as.integer(as.factor(gameid)) &lt; 5), family=&quot;binomial&quot;) build_glm &lt;- function(playerids, seasons = 2014:2017){ model.glm &lt;- function(){ # N observations for(i in 1:N){ result[i] ~ dbern(prob[i]) logit(prob[i]) &lt;- beta_int*int[i] + beta_r*logr[i] + beta_theta*theta[i] } # Priors beta_int ~ dnorm(0, 0.1) beta_r ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases. beta_theta ~ dnorm(mu0theta, 0.1) } allgameshots_sub &lt;- allgameshots %&gt;% filter(globalplayerid %in% playerids &amp; season %in% seasons) mu0r &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Estimate&quot;] mu0theta &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;] tau0r &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;]^2 tau0theta &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;]^2 datlist.glm &lt;- list( logr = log(allgameshots_sub$r), theta = allgameshots_sub$theta, result = allgameshots_sub$result, N = nrow(allgameshots_sub), int = rep(1, nrow(allgameshots_sub)), mu0r = summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Estimate&quot;], mu0theta = summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;] ) params.glm &lt;- c(&quot;beta_int&quot;,&quot;beta_r&quot;, &quot;beta_theta&quot;) sim &lt;- jags(data = datlist.glm, n.iter = 10000, n.chains = 1, n.burnin = 500, #inits=list(list(p = rep(0.5, nrow(P0)))), parameters.to.save = params.glm, model.file=model.glm ) sim.mcmc &lt;- as.data.frame(as.mcmc(sim)[[1]]) return(sim.mcmc) } plot_params &lt;- function(sim.mcmc = NA){ coefs &lt;- sim.mcmc[,c(&quot;beta_int&quot;,&quot;beta_r&quot;,&quot;beta_theta&quot;)] %&gt;% apply(2, quantile, c(0.025,0.5,0.975)) %&gt;% t() %&gt;% as.data.frame() colnames(coefs) &lt;- c(&quot;lo&quot;, &quot;mid&quot;, &quot;hi&quot;) ggplot(data = coefs, aes(x=c(&quot;intercept&quot;,&quot;distance&quot;,&quot;angle&quot;),y=mid)) + geom_point() + geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + geom_abline(intercept=0, slope=0, linetype=2) + labs(title=&quot;GLM Posterior Parameters (95% error)&quot;,x=&quot;predictor&quot;, y=&quot;estimate&quot;) + theme_bw() } for(i in c(id1, id2)){ for(j in 2014:2017){ print(plot_params(i,j)) } } 7.0.0.2 Dynamic Generalized Linear Model #TO DO: #send prof west the ft array (location and angle data, and intercept) and the binary y vector data. (check) #make a mixed effects GLM with random player effect (check?) #use JAGS or rstan for logistic regression random effects MCMC (check?) playerid &lt;- id1 Z &lt;- allgameshots %&gt;% filter(globalplayerid == playerid) %&gt;% mutate(logr = log(r) - mean(log(r))) %&gt;% select(theta, logr) %&gt;% cbind(1,.) X &lt;- allgameshots %&gt;% filter(globalplayerid == playerid) %&gt;% select(x=xt, y=yt) y &lt;- allgameshots %&gt;% filter(globalplayerid == playerid) %&gt;% mutate(logr = log(r) - mean(log(r))) %&gt;% select(result) %&gt;% &#39;[[&#39;(1) ym &lt;- 94; xm &lt;- 50 shots &lt;- rep(TRUE,nrow(Z)) #no missing shots in this case tshot &lt;- which(shots) nshots &lt;- length(tshot) T &lt;- length(shots) #generating shot outcomes iy &lt;- which(y[!is.nan(y)] == 1) #initial parameters mod &lt;- (glm(y ~ theta + logr, data=Z, family=&quot;binomial&quot;)) #high p-values everywhere theta &lt;- coef(mod) p &lt;- length(theta) pscore &lt;- fitted(mod, type=&quot;response&quot;) q &lt;- rep(NaN, T) q[shots] &lt;- pscore par(xpd=TRUE) plot(0,0,type=&quot;n&quot;,xlim = c(0,T),ylim=c(0,1), ylab = &quot;probability&quot;, xlab = &quot;time index&quot;, main = &quot;GLM Predictions&quot;) points(tshot, q[tshot], pch=4, col = &quot;blue&quot;) points(tshot, y[tshot], pch=1, col = &quot;red&quot;) legend(x=T*.8, y=1.21, legend=c(&quot;probability&quot;, &quot;outcome&quot;), pch = c(4,1), col=c(&quot;blue&quot;, &quot;red&quot;)) par(xpd=FALSE) plot(X[iy,c(&quot;x&quot;,&quot;y&quot;)], ylim=c(0,ym), xlim=c(-xm/2,xm/2), col = &quot;red&quot;, pch = 3, xlab=&quot;x&quot;, ylab=&quot;y&quot;, main = &quot;Makes and Misses&quot;) points(X[-iy,c(&quot;x&quot;,&quot;y&quot;)], col =&quot;blue&quot;, pch = 1) abline(h=ym/2) points(0,0,col=&quot;red&quot;, cex=2) #Forward Filtering #set up DGLM and initial prior #first, set up covariates per time interval F &lt;- t(Z) p &lt;- dim(F)[1] #theta = state vector (GLM parameters) (px1) #F = the data...regression vectors for all t...aka the design matrix (pxT) #G = known evolution matrix ??????? #omega = evolution errors with 0 mean and known variance matrix W #g(.) = function to map eta to real line (logit) mt &lt;- theta Ct &lt;- diag(p) #mt = prior mean vector #Ct = prior covariance matrix #(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1]) delta &lt;- 1 #0.99 #discount factor; &quot;streaky parameter&quot; #forward filtering (FF) smt &lt;- matrix(rep(0,p*T), nrow=p) #save post means sCt &lt;- array(rep(0,p*p*T), dim = c(p,p,T)) #save post covars spt &lt;- rep(NaN, T) #save post prob success lmlik &lt;- rep(0,T) #marg lik per time int ishot &lt;- 0 rtst &lt;- array(NA, c(T,2)) for(t in 1:T){ if(t %in% tshot){ #current shot attempt index, and time ishot &lt;- ishot + 1 ti &lt;- tshot[ishot] ft &lt;- (F[,ishot]) %*% mt At &lt;- Ct %*% F[,ishot]/delta qt &lt;- (F[,ishot]) %*% At At &lt;- At/as.numeric(qt) #at = Gt*mt in txtbk, but = mt here. #Rt = Gt*Ct[t-1]*Gt&#39; + Wt in txtbk, but = Ct/delta here #f = F&#39;at = F&#39;mt #q = F&#39;RF = F&#39;Ct F (1/delta) #((lambda,theta)&#39; | Dt-1) ~ N( (f, a), ((q, F&#39;C/delta),(CF/delta, C)) ) #what is mu tho? #??????????????????????? #&quot;the samp dist of Yt depends on thetat only via the single quantity mut #prior: (mu|Dt) ~ N(f, q) #Vt &gt; 0 is scale parameter aka precision of distribution... #but precision of what??? what is b(Yt, Vt?) #Q = q + Vt #post: (mu|Dt) ~ N(f*, q*) #f* = #what is mu??? #f = F&#39;a which is #prior mean and var of linear predictor, and adaptive vector #compute approx prior Beta(r,s) params; update w/ numerical iterations for exact values eft &lt;- exp(ft) #crude initial values rt &lt;- (1+eft)/qt st &lt;- rt/eft rt &lt;- max(0.5, rt) st &lt;- max(0.5, st) #fts = ft* = posterior mean of ???? #qts = qt* = posterior variance of something ??? #iterative numerical solution (maybe comment out) ep &lt;- 0.5; drt &lt;- 1; dst &lt;- 1; xt &lt;- matrix(c(rt, st)) while(max(drt, dst) &lt; ep){ r0t &lt;- psigamma(rt,0); s0t &lt;- psigamma(st,0) r1t &lt;- psigamma(rt,1); s1t &lt;- psigamma(st,1) fxt &lt;- c(r0t-s0t-ft, r1t+s1t-qt) Axt &lt;- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE) xt &lt;- xt - solve(Axt, fxt) drt &lt;- xt[1] - rt; dst &lt;- xt[2] - st rt &lt;- xt[1]; st &lt;- xt[2] } rtst[t,] &lt;- c(rt, st) # if(rt &gt; 1000){ # break # } lmlik[t] &lt;- lgamma(rt+st) - lgamma(rt) - lgamma(st) + lgamma(rt+y[t]) + lgamma(st+1-y[t]) - lgamma(rt+st+1) + lgamma(2) - lgamma(1+y[t]) - lgamma(2-y[t]) rts &lt;- rt + y[t]; sts &lt;- st + 1-y[t] #posterior beta params #convert to mean and variance for linear predictor fts &lt;- psigamma(rts,0)-psigamma(sts,0); qts &lt;- psigamma(rts,1)+psigamma(sts,1) spt[t] &lt;- rts/(sts+rts) #update state parameters mt &lt;- mt+At%*%(fts-ft) Ct &lt;- Ct/delta - (At%*%t(At))*as.numeric(qt-qts) Ct &lt;- (Ct + t(Ct))/2 c(t, rt, st, mt) if(any(is.nan(mt))){ print(&quot;stop&quot;) break } } smt[,t] &lt;- mt; sCt[,,t] &lt;- Ct #saving } par(xpd=TRUE) plot(smt[1,],type=&quot;l&quot;, col = &quot;blue&quot;, xlab = &quot;shot index&quot;, ylab = &quot;online state mean&quot;, main = &quot;Dynamic Parameters&quot;) lines(smt[2,],type=&quot;l&quot;, col = &quot;orange&quot;) lines(smt[3,],type=&quot;l&quot;, col = &quot;yellow&quot;) legend(x=T*.75, y=4, legend = c(&quot;intercept&quot;, &quot;angle&quot;, &quot;log(distance)&quot;), pch = c(16), col = c(&quot;blue&quot;, &quot;orange&quot;, &quot;yellow&quot;)) plot(0,0,type=&quot;n&quot;,xlim = c(0,T),ylim=c(0,1), ylab = &quot;probability&quot;, xlab = &quot;time index&quot;, main = &quot;DGLM Predictions&quot;) points(tshot, spt[tshot], pch=4, col = &quot;blue&quot;) points(tshot, y[tshot], pch=1, col = &quot;red&quot;) legend(x=T*.8, y=1.21, legend=c(&quot;probability&quot;, &quot;outcome&quot;), pch = c(4,1), col=c(&quot;blue&quot;, &quot;red&quot;)) #arm::binnedplot(x=spt[tshot], y=y[tshot]-spt[tshot]) #Backward sampling nmc &lt;- 1000 #save posterior means and posterior success probs MCtheta &lt;- array(0, c(p, T, nmc)) MCq &lt;- array(0, c(T, nmc)) #begin BS at timeunit T thetat &lt;- rmvnorm(n=nmc, smt[,T], sCt[,,T]) #SOMETIMES sCT[,,T] IS NOT POSITIVE DEFINITE. DEPENDS ON RANDOM SEED. MCtheta[,T,] &lt;- t(thetat) MCq[T,] &lt;- 1/(1+exp(-thetat %*% F[,nshots])) #then recurse backwards ishot &lt;- nshots + 1 for(t in (T-1):1){ if(t %in% tshot){ ht = (1-delta)*t(array(smt[,t], c(dim(smt)[1], nmc))) + delta*thetat #run a simulation for each row of ht and each 3rd dim of sCt thetat &lt;- t(apply(ht, 1, rmvnorm, n=1, sigma = sCt[,,t]*(1-delta))) MCtheta[,t,] &lt;- t(thetat) ishot &lt;- ishot - 1; ti &lt;- tshot[ishot] MCq[t,] &lt;- 1/(1+exp(-thetat %*% F[,ishot])) } } #retrospective posterior summaries #posterior of shot probabilities? pr &lt;- t(apply(MCq[tshot,], 1, quantile, c(.025, .25, .5, .75, .975))) #get quantiles of each row plot(0,0, type=&quot;n&quot;, xlim = c(0,T), ylim=c(0,1), main = &quot;Posterior Probability&quot;, ylab=&quot;hit rate&quot;, xlab=&quot;time interval&quot;) lines(x=tshot, y=pr[,1], col = &quot;gray&quot;) lines(x=tshot, y=pr[,5], col = &quot;gray&quot;) polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])), col = &quot;gray&quot;, border = NA) lines(x=tshot, y=pr[,2], col = &quot;black&quot;) lines(x=tshot, y=pr[,4], col = &quot;black&quot;) polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])), col = &quot;black&quot;, border = NA) lines(x=tshot, y=pr[,3], col = &quot;red&quot;) points(x=1:T, y=y, pch=1) #posteriors of parameters from DGLM posterior_labels &lt;- c(&quot;Posterior Intercept&quot;, &quot;Posterior Angle&quot;, &quot;Posterior Log Distance&quot;) for(j in 1:p){ pr = t(apply(MCtheta[j,tshot,], 1, quantile, c(.025, .25, .5, .75, .975))) plot(0,0, type=&quot;n&quot;, xlim = c(0,T), ylim = range(pr), main = posterior_labels[j], xlab = &quot;time interval&quot;, ylab = &quot;state vector element&quot;) lines(x=tshot, y=pr[,1], col = &quot;gray&quot;) lines(x=tshot, y=pr[,5], col = &quot;gray&quot;) polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])), col = &quot;gray&quot;, border = NA) lines(x=tshot, y=pr[,2], col = &quot;black&quot;) lines(x=tshot, y=pr[,4], col = &quot;black&quot;) polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])), col = &quot;black&quot;, border = NA) points(x=tshot, y=pr[,3], col = &quot;red&quot;, pch = 4) } proc(y,q, main=&quot;ROC Curve for GLM&quot;) proc(y,spt, main=&quot;ROC Curve for DGLM&quot;) 7.0.0.3 Hierarchichal Model # TODO: # for beta priors, build a glm on a few games without player-specific measurements. # use means and precisions of these team glm betas as priors for gibbs betas # these will give you prior means. and use generally wide prior variances. # investigate positive beta_r # model2 &lt;- function(){ # # N observations # for(i in 1:N){ # result[i] ~ dbern(prob[i]) # logit(prob[i]) &lt;- beta_int*int[i] + e_int[player[i]] + beta_r*logr[i] + e_r[player[i]] + beta_theta*theta[i] + e_theta[player[i]] # a random &#39;e&#39; here or is that implied? # } # # priors on random player effects # for(j in 1:M){ # e_int[j] ~ dnorm(beta_int,tau) # e_r[j] ~ dnorm(beta_r,tau) # e_theta[j] ~ dnorm(beta_theta,tau) # } # # Priors # beta_int ~ dnorm(0.0,0.1) # beta_r ~ dnorm(mu0r,0.1) # beta_theta ~ dnorm(mu0theta,0.1) # # # Hyperpriors # tau ~ dgamma(0.1,0.1) # } model.hier &lt;- function(){ # N observations for(i in 1:N){ result[i] ~ dbern(prob[i]) logit(prob[i]) &lt;- beta_int[player[i]]*int[i] + beta_r[player[i]]*logr[i] + beta_theta[player[i]]*theta[i] } # priors on random player effects for(j in 1:M){ beta_int[j] ~ dnorm(beta_int0,tau_int) beta_r[j] ~ dnorm(beta_r0,tau_r) beta_theta[j] ~ dnorm(beta_theta0,tau_theta) } # Priors beta_int0 ~ dnorm(0, 0.1) beta_r0 ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases. beta_theta0 ~ dnorm(mu0theta, 0.1) # Hyperpriors tau_int ~ dgamma(10, 100) tau_r ~ dgamma(10, 0.2) tau_theta ~ dgamma(10, 10) } datlist &lt;- list( logr = log(allgameshots$r), theta = allgameshots$theta, result = allgameshots$result, player = as.integer(as.factor(allgameshots$globalplayerid)), N = nrow(allgameshots), int = rep(1, nrow(allgameshots)), M = n_distinct(allgameshots$globalplayerid), mu0r = summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Estimate&quot;], mu0theta = summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;], tau0r = summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;]^2, tau0theta = summary(priormod)[[&quot;coefficients&quot;]][&quot;r&quot;,&quot;Std. Error&quot;]^2 ) params &lt;- c(&quot;beta_int&quot;,&quot;beta_r&quot;, &quot;beta_theta&quot;,&quot;beta_int0&quot;,&quot;beta_r0&quot;, &quot;beta_theta0&quot;, &quot;tau_int&quot;, &quot;tau_r&quot;, &quot;tau_theta&quot;) sim &lt;- jags(data = datlist, n.iter = 1000, n.chains = 1, n.burnin = 100, #inits=list(list(p = rep(0.5, nrow(P0)))), parameters.to.save = params, model.file=model.hier ) sim.mcmc &lt;- as.data.frame(as.mcmc(sim)[[1]]) sim.mcmc.means &lt;- colMeans(sim.mcmc) sim.mcmc.means[!grepl(&quot;\\\\[&quot;, names(sim.mcmc.means))][1:3] -&gt; theta factorid &lt;- data.frame( factorid = as.integer(as.factor(allgameshots$globalplayerid)), globalplayerid = allgameshots$globalplayerid ) %&gt;% unique() playermapshots &lt;- merge(factorid, playermap, by=&quot;globalplayerid&quot;, all=TRUE) playermapparams &lt;- playermapshots %&gt;% mutate(int = NA, r = NA, theta = NA) for(i in 1:nrow(playermapshots)){ fid &lt;- playermapparams$factorid[i] if(!is.na(fid)){ theta_i &lt;- sim.mcmc.means[grep(paste0(&quot;\\\\[&quot;,fid,&quot;\\\\]&quot;), names(sim.mcmc.means))] }else{ theta_i &lt;- theta } playermapparams[i,c(&quot;int&quot;, &quot;r&quot;, &quot;theta&quot;)] &lt;- theta_i } post_prob &lt;- function(newdata=NA){ Z &lt;- merge(newdata, factorid) %&gt;% arrange(time) levels &lt;- Z$factorid B &lt;- t(apply(as.matrix(levels), 1, function(l){ matrix(c(sim.mcmc.means[[paste0(&quot;beta_int[&quot;,l,&quot;]&quot;)]], sim.mcmc.means[[paste0(&quot;beta_r[&quot;,l,&quot;]&quot;)]], sim.mcmc.means[[paste0(&quot;beta_theta[&quot;,l,&quot;]&quot;)]]),ncol=3,byrow=TRUE )} )) X &lt;- Z %&gt;% mutate(logr = log(r) - mean(log(r)), int=1) %&gt;% select(int, logr, theta) %&gt;% as.matrix() probs &lt;- B %&gt;% &#39;%*%&#39;(t(X)) %&gt;% diag() %&gt;% arm::invlogit() # sim.results &lt;- arm::invlogit(sim.mcmc.means[[&quot;beta_int&quot;]] + sim.mcmc.means[[&quot;beta_r&quot;]] %*% t(Z[[&quot;logr&quot;]]) + sim.mcmc.means[[&quot;beta_theta&quot;]] %*% t(Z[[&quot;theta&quot;]]) + indiv_effect) return(probs) } roc(allgameshots$result, post_prob(allgameshots)) "]
]
