[
["index.html", "My Final College Paper Introduction", " My Final College Paper Nathaniel Brown May 20xx Introduction Welcome to the R Markdown thesis template. This template is based on (and in many places copied directly from) the Reed College LaTeX template, but hopefully it will provide a nicer interface for those that have never used TeX or LaTeX before. Using R Markdown will also allow you to easily keep track of your analyses in R chunks of code, with the resulting plots and output included as well. The hope is this R Markdown template gets you in the habit of doing reproducible research, which benefits you long-term as a researcher, but also will greatly help anyone that is trying to reproduce or build onto your results down the road. Hopefully, you won’t have much of a learning period to go through and you will reap the benefits of a nicely formatted thesis. The use of LaTeX in combination with Markdown is more consistent than the output of a word processor, much less prone to corruption or crashing, and the resulting file is smaller than a Word file. While you may have never had problems using Word in the past, your thesis is likely going to be about twice as large and complex as anything you’ve written before, taxing Word’s capabilities. After working with Markdown and R together for a few weeks, we are confident this will be your reporting style of choice going forward. Why use it? R Markdown creates a simple and straightforward way to interface with the beauty of LaTeX. Packages have been written in R to work directly with LaTeX to produce nicely formatting tables and paragraphs. In addition to creating a user friendly interface to LaTeX, R Markdown also allows you to read in your data, to analyze it and to visualize it using R functions, and also to provide the documentation and commentary on the results of your project. Further, it allows for R results to be passed inline to the commentary of your results. You’ll see more on this later. Having your code and commentary all together in one place has a plethora of benefits! Who should use it? Anyone who needs to use data analysis, math, tables, a lot of figures, complex cross-references, or who just cares about the final appearance of their document should use R Markdown. Of particular use should be anyone in the sciences, but the user-friendly nature of Markdown and its ability to keep track of and easily include figures, automatically generate a table of contents, index, references, table of figures, etc. should make it of great benefit to nearly anyone writing a thesis project. "],
["1-abstract.html", "Chapter 1 Abstract", " Chapter 1 Abstract The proposed study is an investigation of Bayesian statistical models and analyses for problems arising in shooting a basketball. The data comes from the Duke Men’s Basketball team’s player-tracking data from the SportVU cameras of STATS, LLC. Goals will be to explore, develop and apply Bayesian models to existing and new data on shooting outcomes, to understand and evaluate questions of inherent random variation, changes over time in shooting performance, and issues related to the “Hot Hand” concept in sports. The models we use to investigate this data are a Generalized Linear Model, a Dynamic Generalized Linear Model, and a Bayesian Hierarchichal Model. Our results so far show that the best-fitting model is a Dynamic Generalized Linear Model; this suggests that the predictive features of a shooting model may be time-dependent. "],
["2-litreview.html", "Chapter 2 Literature Review", " Chapter 2 Literature Review 2.0.1 how do I get the full citations to show up and not just last name and year? Gilovich, Vallone, &amp; Tversky (1985) In this research paper from Cognitive Psychology, Thomas Gilovich, Robert Vallone, and Amos Tversky investigate peoples’ belief in the Hot Hand in Basketball. The Hot Hand is the concept that the probability of a success increases for trials that follow a success in a binary sequence; in basketball, these binary events are shot attempts. The methods in this paper include an analysis of shot attempts from the Philadelphia 76ers of the National Basketball Association (NBA) in the 1981 season, analysis of free-throw attempts from the Boston Celtics in the 1981 and 1982 seasons, and a controlled shooting drill using male and female varsity basketball players at Cornell University. Statistical techniques they used to attempt to detect streakiness in the data included Walf-Wolfowitz run tests, autocorrelation tests on consecutive shot attempts, goodness-of-fit tests for the distribution of succesess, and paired t-tests comparing the mean of makes following a make to that of makes following a miss. In addition to this analysis of shooting, this research also contained a survey of basketball fans, that gauged how much people believed success probabilities changed given a success or a failure. The statistical tests did not detect significant evidence supporting the Hot Hand in basketball. The lack of statistical power in Gilovich, Vallone, and Tversky’s frequentist tests motivates the use of Bayesian models in this thesis. Strengths of this paper include the fact that it was one of the first research papers to analyze streakiness in basketball data, and many future papers build off of it. Some weaknesses in this paper are the assumptions it makes in its analysis, such as all shots being independent of each other, and not accounting for shot location. Albert &amp; Williamson (1999) In this paper, Jim Albert attempts to improve upon the low-powered tests of Gilovich, Vallone, and Tverky’s 1985 paper on the Hot Hand. Albert formally defines “streakiness” as the presence of nonstationarity (nonconstant probability between trials) or autocorrelation (sequential dependency). Albert uses Gibbs sampling to approximate posterior densities and to simulate data, then fits two types of models on binary data from baseball and basketball to try to characterize streakiness. He fits an overdispersion model to detect nonstationarity, and a markov switching model to detect sequential dependencies. While he did not uncover strong evidence for the hot hand, one of his takeaways was that overdispersion decreases as time goes on in basketball free throw shooting data. A weakness of this paper is that Albert does not show the results of both the Markov model and the overdispersion model on the same data. We use Albert’s formal definitions of streakiness as well as his motivation for Bayesian models over frequentist tests. Bar-Eli, Avugos, &amp; Raab (2006) This paper is a review of previous hot hand research. It reviews several papers investigating the concept of the “hot hand” in several sports such as basketball, baseball, volleyball, and horeshoe, and other fields such as cognitive science and economics. Bar-Eli, Avugos, and Raab evaluate the datasets, the tests and statistics used, and the conclusions of each study. Overall, the authors summarize 13 papers that oppose the hot hand phenomenon, and 11 that support it; they also acknowledge that the scientific evidence for the hot hand is weaker than the evidence against it, and it is typically more controversial. Instead of just looking to answer whether the hot hand exists, Bar-Eli, Avugos, and Raab also examine how people define a “hot hand”, and the psychological factors behind the belief in it, such as the gambling and game strategy. The strengths of this paper are that it evaluates the strengths and weaknesses of many competing claims, and concisely summarizes the information into a table. A weakness is that they do not make any claim of their own. This paper is useful in this thesis because it describes several data analysis techniques to detect streaks in a binary sequence. Ryan Wetzels (2016) In this research paper, Wetzels conducts a simulation study to investigate the Hot Hand Phenomenon. His analysis consists of calculating Bayes Factors to compare evidence between a Hidden Markov Model with two states and a binomial model with one state. He applies this method to data from basketball foul shots and from visual discernment tests. In the basketball data, he found that Shaquille O’Neal’s free-throws show evidence for a two-state Markov model, while Kobe Bryant’s show more evidence for a one-state binomial model. In the data from the visual discernment tests, he found no strong evidence supporting one model over the other. A strength of this paper is Wetzel’s formal comparison of a Bayesian Markov model to a binomial model. A weakness is that the Bayes Factors only compare evidence between the two models; it does not mean that either model is “good”. We use this paper for the specification of the Hidden Markov Model. Albert (1993) In this paper, Albert uses a Markov switching model to analyze streakiness in baseball pitching data. He concludes that a few players exhibit streakiness, but not enough to reject the null hypothesis. An exploratory technique that we take from this paper is to examine the peaks and valleys in a moving average plot to observe streakiness. A strength of this paper is that Albert controls for situational variables such as home field advantage, the handedness of the pitcher, and the runners on the bases. Albert (2013) In this paper, Albert analyzes streakiness in baseball hitting data. His analysis techniques include using Bayes Factors to compare models of the form \\(f(y_j|p_j) = p_j(1-p_j)^{y_j}, y_j = 0,1,2,...\\); a consistent model with a constant \\(p_j\\), and a streaky model with a varying \\(p_j\\) from a beta distribution. A useful insight that we apply to this paper is the concept that the existence of streakiness depends on the definition of “success” in binary outcome data. He found substantially more evidence for streakiness for when a success was coded as “not a strikeout” instead of a “hit”. Likewise, in this paper we blank. West, Harrison, &amp; Migon (1985) This textbook provides theory, applications, and examples of time series models such Dynamic Generalized Linear Models (DGLMs). More specifically, section 14.4 provides an example of a DGLM for a binomial response variable, which we apply in chapter blank of this research paper. "],
["3-data.html", "Chapter 3 Data", " Chapter 3 Data The data for this analysis comes from SportVU, a player-tracking system from STATS, LLC. that provides precise coordinates for all ten players and the ball at a rate of 25 times per second. The Duke University Men’s Basketball team permitted the use of their SportVU data from the 2014 to 2017 basketball seasons for this project. However, since the ability to record this data depends on specialized tracking cameras, Duke does not have this data for every game they play—only home games, and a few road games in arenas that had the techology installed. Therefore, there is a substantial amount of missing data between games. For our analysis, we use the following files for each game: Final Sequence Play-by-Play Optical: This dataset comes in an a semi-structured Extensible Markup Language (XML) file, where there is a unique element for each “event” (an event is a basketball action such as a dribble, pass, shot, foul, etc.). Each event element has attributes describing the type of event, the time of the event, and the player who completed the action. We use these files to uncover when a shot is attempted in a game, who attempted the shot, and the result of the shot attempt. Box Score Optical: We use this dataset to match the names and ids of players who were in the game. This is also an XML file, with elements corresponding to individual players. These elements contain attributes describing information about the player (e.g. team name, jersey number) and various statistics for the game (e.g. points, assists, distance run). Final Sequence Optical: These XML files contain the locations of all ten players and the ball during precise time intervals within the game. Each timeunit has a unique element, and these elements have attributes describing the locations. We merge this with the Final Sequence Play-by-Play Optical data on the time attribute to obtain the shooter’s location at the moment of a shot attempt. &lt;!– Final Box Optical: These file contain semi-structured data –&gt; "],
["4-proc.html", "Chapter 4 Procedure", " Chapter 4 Procedure Using the time-stamped sequence of shot locations and binary outcomes, we fit generalized linear models, dynamic generalized linear models, or DGLMs (West, Migon, and Harrison, 1985) (West and Harrison, 1997), and hierarchichal models. DGLMs allow for time-varying effects on shot attempt frequency and shot success rate within a game and between games. The formal Bayesian analysis allows us to produce full quantified inferences on these patterns over time, with probabilistic summaries of the within-game and between-game outcomes. For each provided game, we will analyze player shooting tendencies and outcomes, which provides understanding of inherent variability (or “randomness”) for the players, and formal assessments of differences in patterns game-to-game. We are also considering a two-state Hidden Markov Switching Model that parallels and extends these models; the two potential states for each shot attempt are a “high” probability or a “low” probability of making the next shot, given the features of the current and previous possessions. "],
["5-EDA.html", "Chapter 5 Exploratory Data Analysis", " Chapter 5 Exploratory Data Analysis 5.0.0.1 Exploratory Data Analysis The following exploratory plots examine how consistent the probability of a made shot is, using a loess smooth curve on the binary outcomes. We present these smoothed plots for four high-usage basketball players at Duke University, and we leave the others in the Appendix. Each plot represents a single player’s ordered shooting outcomes for a single season. These plots do not account for the amount of time in between shots, but simply shot order and outcome. datafolder &lt;- &quot;C:/Users/Nathaniel Brown/Documents/important things/DMBBall Data/&quot; githubfolder &lt;- &quot;C:/Users/Nathaniel Brown/Documents/GitHub/thesis-sp18-brown-hothand/&quot; source(paste0(githubfolder,&quot;sportvu_fxns.R&quot;)) Warning: package &#39;xml2&#39; was built under R version 3.3.3 plotshottime &lt;- function(playerid, season){ allgameshots_sub &lt;- allgameshots[allgameshots$globalplayerid==playerid &amp; allgameshots$season==season,] if(nrow(allgameshots_sub) &lt; 10){ plot(0,0,type=&quot;n&quot;, yaxt=&quot;n&quot;,xaxt=&quot;n&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) text(0,0,label=&quot;Not Enough Data&quot;, cex=2) }else{ Y &lt;- allgameshots_sub$result #zoo::rollmean((allgameshots_sub$result), 4) X &lt;- 1:length(Y) scatter.smooth(X,Y,span=20/length(Y), main = paste0(&quot;Smoothed Shooting Outcomes&quot;), yaxt=&quot;n&quot;,ylab=&quot;Result&quot;,xlab=&quot;Order&quot;) axis(side=2,at=c(0,1),labels=c(&quot;Miss&quot;,&quot;Make&quot;)) } } maxseason &lt;- allgameshots %&gt;% group_by(globalplayerid, season) %&gt;% summarize(num=n()) %&gt;% group_by(globalplayerid) %&gt;% mutate(m=max(num)) %&gt;% filter(num==m) %&gt;% as.data.frame() Warning: package &#39;bindrcpp&#39; was built under R version 3.3.3 for(i in 1:nrow(playerseasons)){ r &lt;- playerseasons[i,] plotshottime(r[[1]],r[[2]]) } We can see that the plots vary in the consistency of their made shots, since they all contain spikes and trends. For example, the third plot initially has a very high success rate, which quickly falls to the middle after about thirty shot attempts, and the second plot has a noticeable upward trend in shot success beginning around shot number one hundred fifty. We investigate the shooting outcome using Bayesian models, and show the results in the next section. "],
["6-model.html", "Chapter 6 Models", " Chapter 6 Models For our models, we consider the shot location and the shooter identity as factors that can affect a shot outcome. For each of the following models, shot location is parametrized in polar coordinates, or \\(r\\) and \\(\\theta\\). 6.0.0.1 Generalized Linear Model The results of the credible intervals are reported for the same four players, in the same order. # playerid &lt;- id2 # seasons &lt;- c(2014,2015,2016,2017) priormod &lt;- glm(result ~ log(r) + theta, data=allgameshots %&gt;% filter(as.integer(as.factor(gameid)) &lt; 5), family=&quot;binomial&quot;) mu0r &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;log(r)&quot;,&quot;Estimate&quot;] mu0theta &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;log(r)&quot;,&quot;Std. Error&quot;] tau0r &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;theta&quot;,&quot;Std. Error&quot;]^2 tau0theta &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;theta&quot;,&quot;Std. Error&quot;]^2 fit_glm &lt;- function(playerids, seasons = 2014:2017){ model.glm &lt;- function(){ # N observations for(i in 1:N){ result[i] ~ dbern(prob[i]) logit(prob[i]) &lt;- beta_int*int[i] + beta_r*logr[i] + beta_theta*theta[i] } # Priors beta_int ~ dnorm(0, 0.1) beta_r ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases. beta_theta ~ dnorm(mu0theta, 0.1) } allgameshots_sub &lt;- allgameshots %&gt;% filter(globalplayerid %in% playerids &amp; season %in% seasons) datlist.glm &lt;- list( logr = log(allgameshots_sub$r), theta = allgameshots_sub$theta, result = allgameshots_sub$result, N = nrow(allgameshots_sub), int = rep(1, nrow(allgameshots_sub)), mu0r = mu0r, mu0theta = mu0theta ) params.glm &lt;- c(&quot;beta_int&quot;,&quot;beta_r&quot;, &quot;beta_theta&quot;) sim &lt;- jags(data = datlist.glm, n.iter = 10000, n.chains = 1, n.burnin = 500, #inits=list(list(p = rep(0.5, nrow(P0)))), parameters.to.save = params.glm, model.file=model.glm ) sim.mcmc &lt;- as.data.frame(as.mcmc(sim)[[1]]) return(sim.mcmc) } plot_params &lt;- function(sim.mcmc = NA){ coefs &lt;- sim.mcmc[,c(&quot;beta_int&quot;,&quot;beta_r&quot;,&quot;beta_theta&quot;)] %&gt;% apply(2, quantile, c(0.025,0.5,0.975)) %&gt;% t() %&gt;% as.data.frame() colnames(coefs) &lt;- c(&quot;lo&quot;, &quot;mid&quot;, &quot;hi&quot;) ggplot(data = coefs, aes(x=c(&quot;intercept&quot;,&quot;distance&quot;,&quot;angle&quot;),y=mid)) + geom_point() + geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + geom_abline(intercept=0, slope=0, linetype=2) + labs(title=&quot;GLM Posterior Parameters (95% error)&quot;,x=&quot;predictor&quot;, y=&quot;estimate&quot;) + theme_bw() } playerseasons glm1 &lt;- fit_glm(playerseasons[1,1], playerseasons[1,2]) glm2 &lt;- fit_glm(playerseasons[2,1], playerseasons[2,2]) glm3 &lt;- fit_glm(playerseasons[3,1], playerseasons[3,2]) glm4 &lt;- fit_glm(playerseasons[4,1], playerseasons[4,2]) plot_params(glm1) plot_params(glm2) plot_params(glm3) plot_params(glm4) The four plots show the GLM parameters for the four players and seasons that we investigated in the Exploratory Data Analysis section. From these plots we see that the effect of the angle contains zero, and it is probably not predictive of a made shot. We also see that the 95% credible interval on the effect of distance is completely negative, which follows the intuitive idea that the probability of a made shot decreases as distance from the basket increases. 6.0.0.2 Hierarchichal Model priormod &lt;- glm(result ~ log(r) + theta, data=allgameshots %&gt;% filter(as.integer(as.factor(gameid)) &lt; 5), family=&quot;binomial&quot;) mu0r &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;log(r)&quot;,&quot;Estimate&quot;] mu0theta &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;log(r)&quot;,&quot;Std. Error&quot;] tau0r &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;theta&quot;,&quot;Std. Error&quot;]^2 tau0theta &lt;- summary(priormod)[[&quot;coefficients&quot;]][&quot;theta&quot;,&quot;Std. Error&quot;]^2 # model2 &lt;- function(){ # # N observations # for(i in 1:N){ # result[i] ~ dbern(prob[i]) # logit(prob[i]) &lt;- beta_int*int[i] + e_int[player[i]] + beta_r*logr[i] + e_r[player[i]] + beta_theta*theta[i] + e_theta[player[i]] # a random &#39;e&#39; here or is that implied? # } # # priors on random player effects # for(j in 1:M){ # e_int[j] ~ dnorm(beta_int,tau) # e_r[j] ~ dnorm(beta_r,tau) # e_theta[j] ~ dnorm(beta_theta,tau) # } # # Priors # beta_int ~ dnorm(0.0,0.1) # beta_r ~ dnorm(mu0r,0.1) # beta_theta ~ dnorm(mu0theta,0.1) # # # Hyperpriors # tau ~ dgamma(0.1,0.1) # } fit_hier &lt;- function(){ # cond &lt;- allgameshots$globalplayerid %in% playerids &amp; allgameshots$season %in% seasons # allgameshots_sub &lt;- allgameshots %&gt;% filter(cond) model.hier &lt;- function(){ # N observations for(i in 1:N){ result[i] ~ dbern(prob[i]) logit(prob[i]) &lt;- beta_int[player[i]]*int[i] + beta_r[player[i]]*logr[i] + beta_theta[player[i]]*theta[i] } # priors on random player effects for(j in 1:M){ beta_int[j] ~ dnorm(beta_int0,tau_int) beta_r[j] ~ dnorm(beta_r0,tau_r) beta_theta[j] ~ dnorm(beta_theta0,tau_theta) } # Priors beta_int0 ~ dnorm(0, 0.1) beta_r0 ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases. beta_theta0 ~ dnorm(mu0theta, 0.1) # Hyperpriors tau_int ~ dgamma(10, 100) tau_r ~ dgamma(10, 0.2) tau_theta ~ dgamma(10, 10) } datlist.hier &lt;- list( logr = log(allgameshots$r), theta = allgameshots$theta, result = allgameshots$result, player = as.integer(as.factor(allgameshots$globalplayerid)), N = nrow(allgameshots), int = rep(1, nrow(allgameshots)), M = n_distinct(allgameshots$globalplayerid), mu0r = mu0r, mu0theta = mu0theta, tau0r =tau0r, tau0theta = tau0theta ) params &lt;- c(&quot;beta_int&quot;,&quot;beta_r&quot;, &quot;beta_theta&quot;,&quot;beta_int0&quot;,&quot;beta_r0&quot;, &quot;beta_theta0&quot;, &quot;tau_int&quot;, &quot;tau_r&quot;, &quot;tau_theta&quot;) sim &lt;- jags(data = datlist.hier, n.iter = 10000, n.chains = 1, n.burnin = 500, #inits=list(list(p = rep(0.5, nrow(P0)))), parameters.to.save = params, model.file=model.hier ) sim.mcmc.hier &lt;- as.data.frame(as.mcmc(sim)[[1]]) return(sim.mcmc.hier) } get_player_params &lt;- function(sim.mcmc.hier){ factorid &lt;- data.frame( factorid = as.integer(as.factor(allgameshots$globalplayerid)), globalplayerid = allgameshots$globalplayerid ) %&gt;% unique() sim.mcmc.means &lt;- colMeans(sim.mcmc.hier) playermapshots &lt;- merge(factorid, playermap, by=&quot;globalplayerid&quot;, all=TRUE) playermapparams &lt;- playermapshots %&gt;% mutate(int = NA, r = NA, theta = NA) for(i in 1:nrow(playermapshots)){ fid &lt;- playermapparams$factorid[i] if(!is.na(fid)){ theta_i &lt;- sim.mcmc.means[grep(paste0(&quot;\\\\[&quot;,fid,&quot;\\\\]&quot;), names(sim.mcmc.means))] }else{ theta_i &lt;- theta } playermapparams[i,c(&quot;int&quot;, &quot;r&quot;, &quot;theta&quot;)] &lt;- theta_i } return(playermapparams) } post_prob &lt;- function(newdata=NA){ Z &lt;- merge(newdata, factorid) %&gt;% arrange(time) levels &lt;- Z$factorid B &lt;- t(apply(as.matrix(levels), 1, function(l){ matrix(c(sim.mcmc.means[[paste0(&quot;beta_int[&quot;,l,&quot;]&quot;)]], sim.mcmc.means[[paste0(&quot;beta_r[&quot;,l,&quot;]&quot;)]], sim.mcmc.means[[paste0(&quot;beta_theta[&quot;,l,&quot;]&quot;)]]),ncol=3,byrow=TRUE )} )) X &lt;- Z %&gt;% mutate(logr = log(r) - mean(log(r)), int=1) %&gt;% select(int, logr, theta) %&gt;% as.matrix() probs &lt;- B %&gt;% &#39;%*%&#39;(t(X)) %&gt;% diag() %&gt;% arm::invlogit() # sim.results &lt;- arm::invlogit(sim.mcmc.means[[&quot;beta_int&quot;]] + sim.mcmc.means[[&quot;beta_r&quot;]] %*% t(Z[[&quot;logr&quot;]]) + sim.mcmc.means[[&quot;beta_theta&quot;]] %*% t(Z[[&quot;theta&quot;]]) + indiv_effect) return(probs) } hier &lt;- fit_hier() module glm loaded Warning in jags.model(model.file, data = data, inits = init.values, n.chains = n.chains, : Unused variable &quot;tau0r&quot; in data Warning in jags.model(model.file, data = data, inits = init.values, n.chains = n.chains, : Unused variable &quot;tau0theta&quot; in data Compiling model graph Resolving undeclared variables Allocating nodes Graph information: Observed stochastic nodes: 5467 Unobserved stochastic nodes: 99 Total graph size: 49347 Initializing model colnames(playerseasons) &lt;- c(&quot;globalplayerid&quot; ,&quot;season&quot;) fourparams &lt;- merge((playerseasons), get_player_params(hier),all=FALSE) %&gt;% select(int, r, theta) mainlab &lt;- &quot;Posterior Density plus Four Players&quot; plot(density(hier[[&quot;beta_int0&quot;]]), mainlab,xlab=&quot;intercept&quot;) abline(v=fourparams[,1], col=&quot;red&quot;) plot(density(hier[[&quot;beta_r0&quot;]]), mainlab, xlab=&quot;r&quot;) abline(v=fourparams[,2], col=&quot;red&quot;) plot(density(hier[[&quot;beta_theta0&quot;]]),mainlab, xlab=&quot;theta&quot;) abline(v=fourparams[,3], col=&quot;red&quot;) The hierarchical model shows us that our four high-usage players of interest do not appear to be randomly spread across the population of players. The intercept plot shows that all four are in or close to the top half of values, and the radius plot shows the opposite with the four players trending towards lower parameter values. The high intercepts make intuitive sense, because the players who take a lot of shots are most more capable of making them under baseline conditions than their teammates are. However, the observation that these players would have a more drastic drop in field goal percentage than an average Duke player as they move farther from the basket is surprising. 6.0.0.3 Dynamic Generalized Linear Model priormod &lt;- glm(result ~ log(r) + theta, data=allgameshots %&gt;% filter(as.integer(as.factor(gameid)) &lt; 5), family=&quot;binomial&quot;) fit_dglm &lt;- function(playerids, seasons, iterate=TRUE){ cond &lt;- allgameshots$globalplayerid %in% playerids &amp; allgameshots$season %in% seasons allgameshots_sub &lt;- allgameshots %&gt;% filter(cond) Z &lt;- allgameshots_sub %&gt;% mutate(logr = log(r) - mean(log(r))) %&gt;% select(logr, theta) %&gt;% cbind(1,.) X &lt;- allgameshots_sub %&gt;% select(x=xt, y=yt) y &lt;- allgameshots_sub %&gt;% select(result) %&gt;% &#39;[[&#39;(1) ym &lt;- 94; xm &lt;- 50 shots &lt;- rep(TRUE,nrow(Z)) #no missing shots in this case tshot &lt;- which(shots) nshots &lt;- length(tshot) iy &lt;- which(y[!is.nan(y)] == 1) T &lt;- length(shots) #initial parameters theta &lt;- coef(priormod) p &lt;- length(theta) # pscore &lt;- fitted(mod, type=&quot;response&quot;) #GLM predictions # q &lt;- rep(NaN, T) # q[shots] &lt;- pscore #q is just the GLM prediction # par(xpd=TRUE) # plot(0,0,type=&quot;n&quot;,xlim = c(0,T),ylim=c(0,1), ylab = &quot;probability&quot;, xlab = &quot;time index&quot;, main = &quot;GLM Predictions&quot;) # points(tshot, q[tshot], pch=4, col = &quot;blue&quot;) # points(tshot, y[tshot], pch=1, col = &quot;red&quot;) # legend(x=T*.8, y=1.21, legend=c(&quot;probability&quot;, &quot;outcome&quot;), pch = c(4,1), col=c(&quot;blue&quot;, &quot;red&quot;)) # par(xpd=FALSE) # plot(X[iy,c(&quot;x&quot;,&quot;y&quot;)], ylim=c(0,ym), xlim=c(-xm/2,xm/2), col = &quot;red&quot;, pch = 3, xlab=&quot;x&quot;, ylab=&quot;y&quot;, main = &quot;Makes and Misses&quot;) # points(X[-iy,c(&quot;x&quot;,&quot;y&quot;)], col =&quot;blue&quot;, pch = 1) # abline(h=ym/2) # points(0,0,col=&quot;red&quot;, cex=2) #Forward Filtering #set up DGLM and initial prior #first, set up covariates per time interval F &lt;- t(Z) p &lt;- dim(F)[1] #theta = state vector (GLM parameters) (px1) #F = the data...regression vectors for all t...aka the design matrix (pxT) #G = known evolution matrix ??????? #omega = evolution errors with 0 mean and known variance matrix W #g(.) = function to map eta to real line (logit) mt &lt;- theta Ct &lt;- diag(p) #mt = prior mean vector #Ct = prior covariance matrix #(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1]) delta &lt;- 0.99 #discount factor; &quot;streaky parameter&quot; #forward filtering (FF) smt &lt;- matrix(rep(0,p*T), nrow=p) #save post means sCt &lt;- array(rep(0,p*p*T), dim = c(p,p,T)) #save post covars spt &lt;- rep(NaN, T) #save post prob success lmlik &lt;- rep(0,T) #marg lik per time int ishot &lt;- 0 rtst &lt;- array(NA, c(T,2)) #rt gets out of control when qt is very small or ft is very big #ft is very big when: #qt is very small when At is very small #At is very small when Ct is very small #Ct is very small when for(t in 1:T){ if(t %in% tshot){ #current shot attempt index, and time ishot &lt;- ishot + 1 ti &lt;- tshot[ishot] ft &lt;- (F[,ishot]) %*% mt At &lt;- Ct %*% F[,ishot]/delta qt &lt;- (F[,ishot]) %*% At At &lt;- At/as.numeric(qt) #at = Gt*mt in txtbk, but = mt here. #Rt = Gt*Ct[t-1]*Gt&#39; + Wt in txtbk, but = Ct/delta here #f = F&#39;at = F&#39;mt #q = F&#39;RF = F&#39;Ct F (1/delta) #((lambda,theta)&#39; | Dt-1) ~ N( (f, a), ((q, F&#39;C/delta),(CF/delta, C)) ) #what is mu tho? #??????????????????????? #&quot;the samp dist of Yt depends on thetat only via the single quantity mut #prior: (mu|Dt) ~ N(f, q) #Vt &gt; 0 is scale parameter aka precision of distribution... #but precision of what??? what is b(Yt, Vt?) #Q = q + Vt #post: (mu|Dt) ~ N(f*, q*) #f* = #what is mu??? #f = F&#39;a which is #prior mean and var of linear predictor, and adaptive vector #compute approx prior Beta(r,s) params; update w/ numerical iterations for exact values eft &lt;- exp(ft) #crude initial values rt &lt;- (1+eft)/qt st &lt;- rt/eft rt &lt;- max(0.5, rt) st &lt;- max(0.5, st) #fts = ft* = posterior mean of ???? #qts = qt* = posterior variance of something ??? #iterative numerical solution (optional) if(iterate){ ep &lt;- 0.5; drt &lt;- 1; dst &lt;- 1; xt &lt;- matrix(c(rt, st)) while(max(drt, dst) &lt; ep){ r0t &lt;- psigamma(rt,0); s0t &lt;- psigamma(st,0) r1t &lt;- psigamma(rt,1); s1t &lt;- psigamma(st,1) fxt &lt;- c(r0t-s0t-ft, r1t+s1t-qt) Axt &lt;- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE) xt &lt;- xt - solve(Axt, fxt) drt &lt;- xt[1] - rt; dst &lt;- xt[2] - st rt &lt;- xt[1]; st &lt;- xt[2] } } rtst[t,] &lt;- c(rt, st) # cat(paste0(&quot;t=&quot;,t,&quot;\\t&quot;, # &quot;rt=&quot;,rtst[t,1],&quot;\\t&quot;, # &quot;Z[i,]=&quot;,F[,ishot],&quot;\\t&quot;, # &quot;mt=&quot;,mt,&quot;\\n&quot;)) # # if(rt &gt; 1000){ # break # } lmlik[t] &lt;- lgamma(rt+st) - lgamma(rt) - lgamma(st) + lgamma(rt+y[t]) + lgamma(st+1-y[t]) - lgamma(rt+st+1) + lgamma(2) - lgamma(1+y[t]) - lgamma(2-y[t]) rts &lt;- rt + y[t]; sts &lt;- st + 1-y[t] #posterior beta params #convert to mean and variance for linear predictor fts &lt;- psigamma(rts,0)-psigamma(sts,0); qts &lt;- psigamma(rts,1)+psigamma(sts,1) spt[t] &lt;- rts/(sts+rts) #update state parameters mt &lt;- mt+At%*%(fts-ft) Ct &lt;- Ct/delta - (At%*%t(At))*as.numeric(qt-qts) Ct &lt;- (Ct + t(Ct))/2 #c(t, rt, st, mt) if(any(is.nan(mt))){ print(&quot;stop&quot;) break } } smt[,t] &lt;- mt; sCt[,,t] &lt;- Ct #saving } # par(xpd=TRUE) # plot(smt[1,],type=&quot;l&quot;, col = &quot;blue&quot;, xlab = &quot;shot index&quot;, ylab = &quot;online state mean&quot;, main = &quot;Dynamic Parameters&quot;) # lines(smt[2,],type=&quot;l&quot;, col = &quot;orange&quot;) # lines(smt[3,],type=&quot;l&quot;, col = &quot;yellow&quot;) # legend(x=T*.75, y=4, legend = c(&quot;intercept&quot;, &quot;angle&quot;, &quot;log(distance)&quot;), pch = c(16), col = c(&quot;blue&quot;, &quot;orange&quot;, &quot;yellow&quot;)) # plot(0,0,type=&quot;n&quot;,xlim = c(0,T),ylim=c(0,1), ylab = &quot;probability&quot;, xlab = &quot;time index&quot;, main = &quot;DGLM Predictions&quot;) # points(tshot, spt[tshot], pch=4, col = &quot;blue&quot;) # points(tshot, y[tshot], pch=1, col = &quot;red&quot;) # legend(x=T*.8, y=1.21, legend=c(&quot;probability&quot;, &quot;outcome&quot;), pch = c(4,1), col=c(&quot;blue&quot;, &quot;red&quot;)) #Backward sampling nmc &lt;- 1000 #save posterior means and posterior success probs MCtheta &lt;- array(0, c(p, T, nmc)) MCq &lt;- array(0, c(T, nmc)) #begin BS at timeunit T thetat &lt;- rmvnorm(n=nmc, smt[,T], sCt[,,T]) MCtheta[,T,] &lt;- t(thetat) MCq[T,] &lt;- 1/(1+exp(-thetat %*% F[,nshots])) #then recurse backwards ishot &lt;- nshots + 1 for(t in (T-1):1){ if(t %in% tshot){ ht = (1-delta)*t(array(smt[,t], c(dim(smt)[1], nmc))) + delta*thetat #run a simulation for each row of ht and each 3rd dim of sCt thetat &lt;- t(apply(ht, 1, rmvnorm, n=1, sigma = sCt[,,t]*(1-delta))) MCtheta[,t,] &lt;- t(thetat) ishot &lt;- ishot - 1; ti &lt;- tshot[ishot] MCq[t,] &lt;- 1/(1+exp(-thetat %*% F[,ishot])) } } return(list(smt=smt,sCt=sCt,spt=spt,MCtheta=MCtheta,MCq=MCq,rtst=rtst)) } # pr &lt;- t(apply(MCq[tshot,], 1, quantile, c(.025, .25, .5, .75, .975))) #get quantiles of each row # plot(0,0, type=&quot;n&quot;, xlim = c(0,T), ylim=c(0,1), main = &quot;Posterior Probability&quot;, ylab=&quot;hit rate&quot;, xlab=&quot;time interval&quot;) # lines(x=tshot, y=pr[,1], col = &quot;gray&quot;) # lines(x=tshot, y=pr[,5], col = &quot;gray&quot;) # polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])), # col = &quot;gray&quot;, border = NA) # lines(x=tshot, y=pr[,2], col = &quot;black&quot;) # lines(x=tshot, y=pr[,4], col = &quot;black&quot;) # polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])), # col = &quot;black&quot;, border = NA) # lines(x=tshot, y=pr[,3], col = &quot;red&quot;) # points(x=1:T, y=y, pch=1) # par(xpd=TRUE) # plot(smt[1,],type=&quot;l&quot;, col = &quot;blue&quot;, xlab = &quot;shot index&quot;, ylab = &quot;online state mean&quot;, main = &quot;Dynamic Parameters&quot;) # lines(smt[2,],type=&quot;l&quot;, col = &quot;orange&quot;) # lines(smt[3,],type=&quot;l&quot;, col = &quot;yellow&quot;) # legend(x=T*.75, y=4, legend = c(&quot;intercept&quot;, &quot;angle&quot;, &quot;log(distance)&quot;), pch = c(16), col = c(&quot;blue&quot;, &quot;orange&quot;, &quot;yellow&quot;)) plot_dynamics &lt;- function(smt){ T &lt;- dim(smt)[2] par(xpd=TRUE) plot(smt[1,],type=&quot;l&quot;, col = &quot;blue&quot;, xlab = &quot;shot index&quot;, ylab = &quot;online state mean&quot;, main = &quot;Dynamic Parameters&quot;) lines(smt[2,],type=&quot;l&quot;, col = &quot;orange&quot;) lines(smt[3,],type=&quot;l&quot;, col = &quot;yellow&quot;) legend(x=T*.75, y=4, legend = c(&quot;intercept&quot;, &quot;angle&quot;, &quot;log(distance)&quot;), pch = c(16), col = c(&quot;blue&quot;, &quot;orange&quot;, &quot;yellow&quot;)) par(xpd=FALSE) } #posteriors of parameters from DGLM plot_posteriors &lt;- function(MCtheta){ #dimensions are [p,nshots,nmc] p &lt;- dim(MCtheta)[1] T &lt;- dim(MCtheta)[2] nmc &lt;- dim(MCtheta)[3] posterior_labels &lt;- c(&quot;Posterior Intercept&quot;, &quot;Posterior Angle&quot;, &quot;Posterior Log Distance&quot;) tshot &lt;- which(!(is.na(MCtheta[1,,1]) | is.null(MCtheta[1,,1]))) for(j in 1:p){ pr &lt;- t(apply(MCtheta[j,tshot,], 1, quantile, c(.025, .25, .5, .75, .975))) plot(0,0, type=&quot;n&quot;, xlim = c(0,T), ylim = range(pr), main = posterior_labels[j], xlab = &quot;time interval&quot;, ylab = &quot;state vector element&quot;) lines(x=tshot, y=pr[,1], col = &quot;gray&quot;) lines(x=tshot, y=pr[,5], col = &quot;gray&quot;) polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])), col = &quot;gray&quot;, border = NA) lines(x=tshot, y=pr[,2], col = &quot;black&quot;) lines(x=tshot, y=pr[,4], col = &quot;black&quot;) polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])), col = &quot;black&quot;, border = NA) points(x=tshot, y=pr[,3], col = &quot;red&quot;, pch = 4) } } dglm1 &lt;- fit_dglm(playerseasons[1,1], playerseasons[1,2]) dglm2 &lt;- fit_dglm(playerseasons[2,1], playerseasons[2,2]) dglm3 &lt;- fit_dglm(playerseasons[3,1], playerseasons[3,2]) dglm4 &lt;- fit_dglm(playerseasons[4,1], playerseasons[4,2]) plot_dynamics(dglm1[[1]]) plot_posteriors(dglm1[[4]]) plot_dynamics(dglm2[[1]]) plot_posteriors(dglm2[[4]]) plot_dynamics(dglm3[[1]]) plot_posteriors(dglm3[[4]]) plot_dynamics(dglm4[[1]]) plot_posteriors(dglm4[[4]]) The amount of volatility that we see in the posterior distribution of the parameters with a discount factor of \\(\\delta\\) = 0.99 suggests that there is time dependency in the data. However, the state means of the dynamic parameters appear to be unstable. Therefore, we must apply a better-fitting time series model before concluding that the parameters have time dependencies. "],
["7-disc.html", "Chapter 7 Discussion", " Chapter 7 Discussion Our results so far suggest that some insights can be taken by predicting basketball shooting outcomes, but none of our results so far are more insightful than what one could find by watching a game (i.e. the most frequent shooters are usually above average shooters, or the probability of making a shot decreases as distance from the basket increases). The three models we have fit so far (GLM, DGLM, and Hierarchical) either not realistic enough, or do not fit well enough. We could refine our models by including more predictors such as a proxy for fatigue (using information about total minutes played, or consecutive minutes played without a timeout), or shot difficulty (using information about the nearest defender). Future goals for this research are to build a better-fitting model to predict basketball shots, and to thoroughly investigate the time-dependency of the predictive features. If you feel it necessary to include an appendix, it goes here. --> "],
["A-the-first-appendix.html", "A The First Appendix", " A The First Appendix This first appendix includes all of the R chunks of code that were hidden throughout the document (using the include = FALSE chunk tag) to help with readibility and/or setup. In the main Rmd file # This chunk ensures that the thesisdowndss package is # installed and loaded. This thesisdowndss package includes # the template files for the thesis. if(!require(devtools)) install.packages(&quot;devtools&quot;, repos = &quot;http://cran.rstudio.com&quot;) if(!require(thesisdowndss)) devtools::install_github(&quot;mine-cetinkaya-rundel/thesisdowndss&quot;) library(thesisdowndss) In Chapter ??: "],
["B-the-second-appendix-for-fun.html", "B The Second Appendix, for Fun", " B The Second Appendix, for Fun "],
["references.html", "References", " References "]
]
