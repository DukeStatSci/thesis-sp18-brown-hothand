<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>My Final College Paper</title>
  <meta name="description" content="My Final College Paper">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="My Final College Paper" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="My Final College Paper" />
  
  
  

<meta name="author" content="Nathaniel Brown">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="3-proc.html">
<link rel="next" href="5-results.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./"></a></li>
<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a></li>
<li class="chapter" data-level="1" data-path="1-abstract.html"><a href="1-abstract.html"><i class="fa fa-check"></i><b>1</b> Abstract</a><ul>
<li class="chapter" data-level="1.0.1" data-path="1-abstract.html"><a href="1-abstract.html#how-do-i-get-the-full-citations-to-show-up-and-not-just-last-name-and-year"><i class="fa fa-check"></i><b>1.0.1</b> how do I get the full citations to show up and not just last name and year?</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="2-data.html"><a href="2-data.html"><i class="fa fa-check"></i><b>2</b> Data</a></li>
<li class="chapter" data-level="3" data-path="3-proc.html"><a href="3-proc.html"><i class="fa fa-check"></i><b>3</b> Procedure</a></li>
<li class="chapter" data-level="4" data-path="4-model.html"><a href="4-model.html"><i class="fa fa-check"></i><b>4</b> Models</a></li>
<li class="chapter" data-level="5" data-path="5-results.html"><a href="5-results.html"><i class="fa fa-check"></i><b>5</b> Results</a></li>
<li class="chapter" data-level="6" data-path="6-disc.html"><a href="6-disc.html"><i class="fa fa-check"></i><b>6</b> Discussion</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">My Final College Paper</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="model" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> Models</h1>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mvtnorm); <span class="kw">library</span>(dplyr); <span class="kw">library</span>(ggplot2); <span class="kw">library</span>(R2jags)</code></pre></div>
<pre><code>Warning: package &#39;R2jags&#39; was built under R version 3.3.3</code></pre>
<pre><code>Loading required package: rjags</code></pre>
<pre><code>Warning: package &#39;rjags&#39; was built under R version 3.3.2</code></pre>
<pre><code>Loading required package: coda</code></pre>
<pre><code>Linked to JAGS 4.2.0</code></pre>
<pre><code>Loaded modules: basemod,bugs</code></pre>
<pre><code>
Attaching package: &#39;R2jags&#39;</code></pre>
<pre><code>The following object is masked from &#39;package:coda&#39;:

    traceplot</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#generating shot success probabilities</span>
<span class="co">#theta &lt;- matrix(c(-0.5, 1.5, -5.5)) #GLM parameters (intercept, angle, log distance)</span>
datafolder &lt;-<span class="st"> &quot;C:/Users/Nathaniel Brown/Documents/important things/DMBBall Data&quot;</span>
<span class="kw">source</span>(<span class="st">&quot;C:/Users/Nathaniel Brown/Documents/GitHub/thesis-sp18-brown-hothand/sportvu_fxns.R&quot;</span>)</code></pre></div>
<pre><code>Warning: package &#39;xml2&#39; was built under R version 3.3.3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">id1 &lt;-<span class="st"> </span><span class="dv">887661</span>
id2 &lt;-<span class="st"> </span><span class="dv">842296</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plotshotloc &lt;-<span class="st"> </span>function(playerid, season){
<span class="kw">plot</span>(<span class="dt">x=</span>allgameshots$x2[allgameshots$result ==<span class="st"> </span><span class="dv">1</span> &amp;<span class="st"> </span>allgameshots$globalplayerid==playerid &amp;<span class="st"> </span>allgameshots$season==season],
       <span class="dt">y=</span>allgameshots$y2[allgameshots$result ==<span class="st"> </span><span class="dv">1</span> &amp;<span class="st"> </span>allgameshots$globalplayerid==playerid &amp;<span class="st"> </span>allgameshots$season==season], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;y&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;x&quot;</span>, <span class="dt">main =</span> <span class="kw">paste</span>(playerid, season))

<span class="kw">points</span>(<span class="dt">x=</span>allgameshots$x2[allgameshots$result ==<span class="st"> </span><span class="dv">0</span> &amp;<span class="st"> </span>allgameshots$globalplayerid==playerid &amp;<span class="st"> </span>allgameshots$season==season],
       <span class="dt">y=</span>allgameshots$y2[allgameshots$result ==<span class="st"> </span><span class="dv">0</span> &amp;<span class="st"> </span>allgameshots$globalplayerid==playerid &amp;<span class="st"> </span>allgameshots$season==season], <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
}

plotshottime &lt;-<span class="st"> </span>function(playerid, season){
  allgameshots_sub &lt;-<span class="st"> </span>allgameshots[allgameshots$globalplayerid==playerid &amp;<span class="st"> </span>allgameshots$season==season,]
  Y &lt;-<span class="st"> </span>allgameshots_sub$result <span class="co">#zoo::rollmean((allgameshots_sub$result), 4)</span>
  X &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="kw">length</span>(Y)
  <span class="kw">scatter.smooth</span>(X,Y,<span class="dt">span=</span><span class="fl">0.05</span>,<span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">main =</span> <span class="kw">paste</span>(playerid, season))
}</code></pre></div>
<div id="glm" class="section level4">
<h4><span class="header-section-number">4.0.0.1</span> GLM</h4>
</div>
<div id="shot-by-shot-dglm-only-considering-location-order-and-result-of-each-shot.-not-amount-of-time-between-shots." class="section level4">
<h4><span class="header-section-number">4.0.0.2</span> Shot-by-Shot DGLM (only considering location, order, and result of each shot. not amount of time between shots).</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#TO DO:</span>
<span class="co">#send prof west the ft array (location and angle data, and intercept) and the binary y vector data. (check)</span>
<span class="co">#make a mixed effects GLM with random player effect (check?)</span>
<span class="co">#use JAGS or rstan for logistic regression random effects MCMC (check?)</span>

playerid &lt;-<span class="st"> </span>id1
Z &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">logr =</span> <span class="kw">log</span>(r) -<span class="st"> </span><span class="kw">mean</span>(<span class="kw">log</span>(r))) %&gt;%<span class="st"> </span><span class="kw">select</span>(theta, logr) %&gt;%<span class="st"> </span><span class="kw">cbind</span>(<span class="dv">1</span>,.)
X &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid) %&gt;%<span class="st"> </span><span class="kw">select</span>(<span class="dt">x=</span>x2, <span class="dt">y=</span>y2)
y &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">logr =</span> <span class="kw">log</span>(r) -<span class="st"> </span><span class="kw">mean</span>(<span class="kw">log</span>(r))) %&gt;%<span class="st"> </span><span class="kw">select</span>(result) %&gt;%<span class="st"> &#39;[[&#39;</span>(<span class="dv">1</span>)

ym &lt;-<span class="st"> </span><span class="dv">94</span>; xm &lt;-<span class="st"> </span><span class="dv">50</span>
shots &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">TRUE</span>,<span class="kw">nrow</span>(Z)) <span class="co">#no missing shots in this case</span>
tshot &lt;-<span class="st"> </span><span class="kw">which</span>(shots)
nshots &lt;-<span class="st"> </span><span class="kw">length</span>(tshot)
T &lt;-<span class="st"> </span><span class="kw">length</span>(shots)

<span class="co">#generating shot outcomes</span>

iy &lt;-<span class="st"> </span><span class="kw">which</span>(y[!<span class="kw">is.nan</span>(y)] ==<span class="st"> </span><span class="dv">1</span>)

<span class="co">#initial parameters</span>
mod &lt;-<span class="st"> </span>(<span class="kw">glm</span>(y ~<span class="st"> </span>theta +<span class="st"> </span>logr, <span class="dt">data=</span>Z, <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)) <span class="co">#high p-values everywhere</span>
theta &lt;-<span class="st"> </span><span class="kw">coef</span>(mod)

p &lt;-<span class="st"> </span><span class="kw">length</span>(theta)
pscore &lt;-<span class="st"> </span><span class="kw">fitted</span>(mod, <span class="dt">type=</span><span class="st">&quot;response&quot;</span>)
q &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NaN</span>, T)
q[shots] &lt;-<span class="st"> </span>pscore

<span class="kw">par</span>(<span class="dt">xpd=</span><span class="ot">TRUE</span>)
<span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dt">type=</span><span class="st">&quot;n&quot;</span>,<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">ylab =</span> <span class="st">&quot;probability&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;time index&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;GLM&quot;</span>)
<span class="kw">points</span>(tshot, q[tshot], <span class="dt">pch=</span><span class="dv">4</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(tshot, y[tshot], <span class="dt">pch=</span><span class="dv">1</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">legend</span>(<span class="dt">x=</span>T*.<span class="dv">8</span>, <span class="dt">y=</span><span class="fl">1.21</span>, <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;probability&quot;</span>, <span class="st">&quot;outcome&quot;</span>), <span class="dt">pch =</span> <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">1</span>), <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>))

<span class="kw">par</span>(<span class="dt">xpd=</span><span class="ot">FALSE</span>)
<span class="kw">plot</span>(X[iy,<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)], <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,ym), <span class="dt">xlim=</span><span class="kw">c</span>(-xm,xm), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">pch =</span> <span class="dv">3</span>, <span class="dt">xlab=</span><span class="st">&quot;x&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;y&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Makes and Misses&quot;</span>)
<span class="kw">points</span>(X[-iy,<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)], <span class="dt">col =</span><span class="st">&quot;blue&quot;</span>, <span class="dt">pch =</span> <span class="dv">1</span>)
<span class="kw">abline</span>(<span class="dt">h=</span>ym/<span class="dv">2</span>)
<span class="kw">points</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>, <span class="dt">cex=</span><span class="dv">2</span>)



<span class="co">#Forward Filtering</span>

<span class="co">#set up DGLM and initial prior</span>
<span class="co">#first, set up covariates per time interval</span>
F &lt;-<span class="st"> </span><span class="kw">t</span>(Z)
p &lt;-<span class="st"> </span><span class="kw">dim</span>(F)[<span class="dv">1</span>]
<span class="co">#theta = state vector (GLM parameters) (px1)</span>
<span class="co">#F = the data...regression vectors for all t...aka the design matrix (pxT)</span>
<span class="co">#G = known evolution matrix ???????</span>
<span class="co">#omega = evolution errors with 0 mean and known variance matrix W</span>
<span class="co">#g(.) = function to map eta to real line (logit)</span>

mt &lt;-<span class="st"> </span>theta
Ct &lt;-<span class="st"> </span><span class="kw">diag</span>(p)
<span class="co">#mt = prior mean vector</span>
<span class="co">#Ct = prior covariance matrix</span>
<span class="co">#(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1])</span>


delta &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co">#0.99 #discount factor; &quot;streaky parameter&quot;</span>
<span class="co">#forward filtering (FF)</span>
smt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">0</span>,p*T), <span class="dt">nrow=</span>p)           <span class="co">#save post means</span>
sCt &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">rep</span>(<span class="dv">0</span>,p*p*T), <span class="dt">dim =</span> <span class="kw">c</span>(p,p,T))  <span class="co">#save post covars</span>
spt &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NaN</span>, T)                          <span class="co">#save post prob success</span>
lmlik &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,T)                           <span class="co">#marg lik per time int</span>
ishot &lt;-<span class="st"> </span><span class="dv">0</span>

rtst &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(T,<span class="dv">2</span>))
for(t in <span class="dv">1</span>:T){
  if(t %in%<span class="st"> </span>tshot){
    <span class="co">#current shot attempt index, and time</span>
    ishot &lt;-<span class="st"> </span>ishot +<span class="st"> </span><span class="dv">1</span>
    ti &lt;-<span class="st"> </span>tshot[ishot]
    
    ft &lt;-<span class="st"> </span>(F[,ishot]) %*%<span class="st"> </span>mt
    At &lt;-<span class="st"> </span>Ct %*%<span class="st"> </span>F[,ishot]/delta
    qt &lt;-<span class="st"> </span>(F[,ishot]) %*%<span class="st"> </span>At
    At &lt;-<span class="st"> </span>At/<span class="kw">as.numeric</span>(qt)
    
    <span class="co">#at = Gt*mt in txtbk, but = mt here.</span>
    <span class="co">#Rt = Gt*Ct[t-1]*Gt&#39; + Wt in txtbk, but = Ct/delta here</span>
    <span class="co">#f = F&#39;at = F&#39;mt</span>
    <span class="co">#q = F&#39;RF = F&#39;Ct F (1/delta)</span>
    <span class="co">#((lambda,theta)&#39; | Dt-1) ~ N( (f, a), ((q, F&#39;C/delta),(CF/delta, C)) )</span>

    <span class="co">#what is mu tho?</span>
    <span class="co">#???????????????????????</span>
    <span class="co">#&quot;the samp dist of Yt depends on thetat only via the single quantity mut</span>
    <span class="co">#prior: (mu|Dt) ~ N(f, q)</span>
    <span class="co">#Vt &gt; 0 is scale parameter aka precision of distribution...</span>
    <span class="co">#but precision of what??? what is b(Yt, Vt?)</span>
    <span class="co">#Q = q + Vt</span>
    <span class="co">#post:  (mu|Dt) ~ N(f*, q*)</span>
    
    <span class="co">#f* = </span>
    <span class="co">#what is mu???</span>
    <span class="co">#f = F&#39;a which is</span>
    
    <span class="co">#prior mean and var of linear predictor, and adaptive vector</span>
    <span class="co">#compute approx prior Beta(r,s) params; update w/ numerical iterations for exact values</span>
    eft &lt;-<span class="st"> </span><span class="kw">exp</span>(ft)   <span class="co">#crude initial values</span>
    rt &lt;-<span class="st"> </span>(<span class="dv">1</span>+eft)/qt
    st &lt;-<span class="st"> </span>rt/eft
    rt &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="fl">0.5</span>, rt)
    st &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="fl">0.5</span>, st)
    
    
    

    <span class="co">#fts = ft* = posterior mean of ????</span>
    <span class="co">#qts = qt* = posterior variance of something ???</span>
    <span class="co">#iterative numerical solution</span>
    <span class="co"># ep &lt;- 0.5; drt &lt;- 1; dst &lt;- 1; xt &lt;- matrix(c(rt, st))</span>
    <span class="co"># while(max(drt, dst) &lt; ep){</span>
    <span class="co">#   r0t &lt;- psigamma(rt,0); s0t &lt;- psigamma(st,0)</span>
    <span class="co">#   r1t &lt;- psigamma(rt,1); s1t &lt;- psigamma(st,1)</span>
    <span class="co">#   fxt &lt;- c(r0t-s0t-ft, r1t+s1t-qt)</span>
    <span class="co">#   Axt &lt;- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE)</span>
    <span class="co">#   xt &lt;- xt - solve(Axt, fxt)</span>
    <span class="co">#   drt &lt;- xt[1] - rt; dst &lt;- xt[2] - st</span>
    <span class="co">#   rt &lt;- xt[1]; st &lt;- xt[2]</span>
    <span class="co"># }</span>
    
    rtst[t,] &lt;-<span class="st"> </span><span class="kw">c</span>(rt, st)
    
    if(rt &gt;<span class="st"> </span><span class="dv">1000</span>){
      break
    }
    
    lmlik[t] &lt;-<span class="st"> </span><span class="kw">lgamma</span>(rt+st) -<span class="st"> </span><span class="kw">lgamma</span>(rt) -<span class="st"> </span><span class="kw">lgamma</span>(st) +<span class="st"> </span>
<span class="st">                </span><span class="kw">lgamma</span>(rt+y[t]) +<span class="st"> </span><span class="kw">lgamma</span>(st<span class="dv">+1</span>-y[t]) -<span class="st"> </span><span class="kw">lgamma</span>(rt+st<span class="dv">+1</span>) +<span class="st"> </span>
<span class="st">                </span><span class="kw">lgamma</span>(<span class="dv">2</span>) -<span class="st"> </span><span class="kw">lgamma</span>(<span class="dv">1</span>+y[t]) -<span class="st"> </span><span class="kw">lgamma</span>(<span class="dv">2</span>-y[t])
    rts &lt;-<span class="st"> </span>rt +<span class="st"> </span>y[t]; sts &lt;-<span class="st"> </span>st +<span class="st"> </span><span class="dv">1</span>-y[t] <span class="co">#posterior beta params</span>
    <span class="co">#convert to mean and variance for linear predictor</span>
    fts &lt;-<span class="st"> </span><span class="kw">psigamma</span>(rts,<span class="dv">0</span>)-<span class="kw">psigamma</span>(sts,<span class="dv">0</span>); qts &lt;-<span class="st"> </span><span class="kw">psigamma</span>(rts,<span class="dv">1</span>)+<span class="kw">psigamma</span>(sts,<span class="dv">1</span>)
    spt[t] &lt;-<span class="st"> </span>rts/(sts+rts)
    
    <span class="co">#update state parameters</span>
    mt &lt;-<span class="st"> </span>mt+At%*%(fts-ft)
    Ct &lt;-<span class="st"> </span>Ct/delta -<span class="st"> </span>(At%*%<span class="kw">t</span>(At))*<span class="kw">as.numeric</span>(qt-qts)
    Ct &lt;-<span class="st"> </span>(Ct +<span class="st"> </span><span class="kw">t</span>(Ct))/<span class="dv">2</span>
    <span class="kw">c</span>(t, rt, st, mt)
    
    if(<span class="kw">any</span>(<span class="kw">is.nan</span>(mt))){
      <span class="kw">print</span>(<span class="st">&quot;stop&quot;</span>)
      break
    }
    
  }
  smt[,t] &lt;-<span class="st"> </span>mt; sCt[,,t] &lt;-<span class="st"> </span>Ct <span class="co">#saving</span>
}

<span class="kw">par</span>(<span class="dt">xpd=</span><span class="ot">TRUE</span>)
<span class="kw">plot</span>(smt[<span class="dv">1</span>,],<span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;shot index&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;online state mean&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Dynamic Parameters&quot;</span>)
<span class="kw">lines</span>(smt[<span class="dv">2</span>,],<span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;orange&quot;</span>)
<span class="kw">lines</span>(smt[<span class="dv">3</span>,],<span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;yellow&quot;</span>)
<span class="kw">legend</span>(<span class="dt">x=</span>T*.<span class="dv">75</span>, <span class="dt">y=</span><span class="dv">4</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;intercept&quot;</span>, <span class="st">&quot;angle&quot;</span>, <span class="st">&quot;log(distance)&quot;</span>), <span class="dt">pch =</span> <span class="kw">c</span>(<span class="dv">16</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;yellow&quot;</span>))

<span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dt">type=</span><span class="st">&quot;n&quot;</span>,<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">ylab =</span> <span class="st">&quot;probability&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;time index&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;DGLM&quot;</span>)
<span class="kw">points</span>(tshot, spt[tshot], <span class="dt">pch=</span><span class="dv">4</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(tshot, y[tshot], <span class="dt">pch=</span><span class="dv">1</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">legend</span>(<span class="dt">x=</span>T*.<span class="dv">8</span>, <span class="dt">y=</span><span class="fl">1.21</span>, <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;probability&quot;</span>, <span class="st">&quot;outcome&quot;</span>), <span class="dt">pch =</span> <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">1</span>), <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>))

<span class="co">#arm::binnedplot(x=spt[tshot], y=y[tshot]-spt[tshot])</span>




<span class="co">#Backward sampling</span>
nmc &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="co">#save posterior means and posterior success probs</span>
MCtheta &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="kw">c</span>(p, T, nmc)) 
MCq &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="kw">c</span>(T, nmc))

<span class="co">#begin BS at timeunit T</span>
thetat &lt;-<span class="st"> </span><span class="kw">rmvnorm</span>(<span class="dt">n=</span>nmc, smt[,T], sCt[,,T]) <span class="co">#SOMETIMES sCT[,,T] IS NOT POSITIVE DEFINITE. DEPENDS ON RANDOM SEED.</span>
MCtheta[,T,] &lt;-<span class="st"> </span><span class="kw">t</span>(thetat)
MCq[T,] &lt;-<span class="st"> </span><span class="dv">1</span>/(<span class="dv">1</span>+<span class="kw">exp</span>(-thetat %*%<span class="st"> </span>F[,nshots]))

<span class="co">#then recurse backwards</span>
ishot &lt;-<span class="st"> </span>nshots +<span class="st"> </span><span class="dv">1</span>
for(t in (T<span class="dv">-1</span>):<span class="dv">1</span>){
  if(t %in%<span class="st"> </span>tshot){
    ht =<span class="st"> </span>(<span class="dv">1</span>-delta)*<span class="kw">t</span>(<span class="kw">array</span>(smt[,t], <span class="kw">c</span>(<span class="kw">dim</span>(smt)[<span class="dv">1</span>], nmc))) +<span class="st"> </span>delta*thetat
    <span class="co">#run a simulation for each row of ht and each 3rd dim of sCt</span>
    thetat &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(ht, <span class="dv">1</span>, rmvnorm, <span class="dt">n=</span><span class="dv">1</span>, <span class="dt">sigma =</span> sCt[,,t]*(<span class="dv">1</span>-delta)))
    MCtheta[,t,] &lt;-<span class="st"> </span><span class="kw">t</span>(thetat)
    ishot &lt;-<span class="st"> </span>ishot -<span class="st"> </span><span class="dv">1</span>; ti &lt;-<span class="st"> </span>tshot[ishot]
    MCq[t,] &lt;-<span class="st"> </span><span class="dv">1</span>/(<span class="dv">1</span>+<span class="kw">exp</span>(-thetat %*%<span class="st"> </span>F[,ishot]))
  }
}

<span class="co">#retrospective posterior summaries</span>
<span class="co">#posterior of shot probabilities?</span>
pr &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(MCq[tshot,], <span class="dv">1</span>, quantile, <span class="kw">c</span>(.<span class="dv">025</span>, .<span class="dv">25</span>, .<span class="dv">5</span>, .<span class="dv">75</span>, .<span class="dv">975</span>))) <span class="co">#get quantiles of each row</span>
<span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">main =</span> <span class="st">&quot;Posterior Probability&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;hit rate&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;time interval&quot;</span>) 
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">1</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">5</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
<span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">1</span>], <span class="kw">rev</span>(pr[,<span class="dv">5</span>])),
        <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">2</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">4</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
<span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">2</span>], <span class="kw">rev</span>(pr[,<span class="dv">4</span>])),
        <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">3</span>], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">points</span>(<span class="dt">x=</span><span class="dv">1</span>:T, <span class="dt">y=</span>y, <span class="dt">pch=</span><span class="dv">1</span>)

<span class="co">#posteriors of parameters from DGLM</span>
posterior_labels &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Posterior Intercept&quot;</span>, <span class="st">&quot;Posterior Angle&quot;</span>, <span class="st">&quot;Posterior Log Distance&quot;</span>)
for(j in <span class="dv">1</span>:p){
  
  pr =<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(MCtheta[j,tshot,], <span class="dv">1</span>, quantile, <span class="kw">c</span>(.<span class="dv">025</span>, .<span class="dv">25</span>, .<span class="dv">5</span>, .<span class="dv">75</span>, .<span class="dv">975</span>)))
  <span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T), <span class="dt">ylim =</span> <span class="kw">range</span>(pr), <span class="dt">main =</span> posterior_labels[j], <span class="dt">xlab =</span> <span class="st">&quot;time interval&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;state vector element&quot;</span>) 
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">1</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">5</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
  <span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">1</span>], <span class="kw">rev</span>(pr[,<span class="dv">5</span>])),
          <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">2</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">4</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
  <span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">2</span>], <span class="kw">rev</span>(pr[,<span class="dv">4</span>])),
          <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
  <span class="kw">points</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">3</span>], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">pch =</span> <span class="dv">4</span>)
  
}</code></pre></div>
</div>
<div id="game-by-game-gibbs" class="section level4">
<h4><span class="header-section-number">4.0.0.3</span> Game-By-Game gibbs</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model2 &lt;-<span class="st"> </span>function(){
    <span class="co"># N observations</span>
    for(i in <span class="dv">1</span>:N){
      result[i] ~<span class="st"> </span><span class="kw">dbern</span>(prob[i])
      <span class="kw">logit</span>(prob[i]) &lt;-<span class="st"> </span>beta_int*int[i] +<span class="st"> </span>e_int[player[i]] +<span class="st"> </span>beta_r*logr[i] +<span class="st"> </span>e_r[player[i]] +<span class="st"> </span>beta_theta*theta[i] +<span class="st"> </span>e_theta[player[i]] <span class="co"># a random &#39;e&#39; here or is that implied?</span>
    }
    <span class="co"># priors on random player effects</span>
    for(j in <span class="dv">1</span>:M){
        e_int[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_int,tau)
        e_r[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_r,tau)
        e_theta[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_theta,tau)
    }
    <span class="co"># Priors</span>
    beta_int   ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="fl">0.0</span>,<span class="fl">1.0E-6</span>)
    beta_r     ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="fl">0.0</span>,<span class="fl">1.0E-6</span>)
    beta_theta ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="fl">0.0</span>,<span class="fl">1.0E-6</span>)

    <span class="co"># Hyperpriors</span>
    tau ~<span class="st"> </span><span class="kw">dgamma</span>(<span class="fl">0.1</span>,<span class="fl">0.1</span>)
}

model &lt;-<span class="st"> </span>function(){
    <span class="co"># N observations</span>
    for(i in <span class="dv">1</span>:N){
      result[i] ~<span class="st"> </span><span class="kw">dbern</span>(prob[i])
      <span class="kw">logit</span>(prob[i]) &lt;-<span class="st"> </span>beta_int[player[i]]*int[i] +<span class="st"> </span>beta_r[player[i]]*logr[i] +<span class="st"> </span>beta_theta[player[i]]*theta[i]
    }
    <span class="co"># priors on random player effects</span>
    for(j in <span class="dv">1</span>:M){
        beta_int[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_int0,tau)
        beta_r[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_r0,tau)
        beta_theta[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_theta0,tau)
    }
    <span class="co"># Priors</span>
    beta_int0   ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="fl">1.0E-6</span>)
    beta_r0     ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="fl">1.0E-6</span>)
    beta_theta0 ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="fl">1.0E-6</span>)

    <span class="co"># Hyperpriors</span>
    tau ~<span class="st"> </span><span class="kw">dgamma</span>(<span class="fl">1E-4</span>,<span class="fl">1E-4</span>)
}

datlist &lt;-<span class="st"> </span><span class="kw">list</span>(
                <span class="dt">logr =</span> <span class="kw">log</span>(allgameshots$r), 
                <span class="dt">theta =</span> allgameshots$theta, 
                <span class="dt">result =</span> allgameshots$result, 
                <span class="dt">player =</span> <span class="kw">as.integer</span>(<span class="kw">as.factor</span>(allgameshots$globalplayerid)),
                <span class="dt">N =</span> <span class="kw">nrow</span>(allgameshots), 
                <span class="dt">int =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(allgameshots)), 
                <span class="dt">M =</span> <span class="kw">n_distinct</span>(allgameshots$globalplayerid)
                )
params &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;beta_int&quot;</span>,<span class="st">&quot;beta_r&quot;</span>, <span class="st">&quot;beta_theta&quot;</span>,<span class="st">&quot;beta_int0&quot;</span>,<span class="st">&quot;beta_r0&quot;</span>, <span class="st">&quot;beta_theta0&quot;</span>)


sim &lt;-<span class="st"> </span><span class="kw">jags</span>(<span class="dt">data =</span> datlist, 
            <span class="dt">n.iter =</span> <span class="dv">1000</span>, <span class="dt">n.chains =</span> <span class="dv">1</span>, <span class="dt">n.burnin =</span> <span class="dv">100</span>,
            <span class="co">#inits=list(list(p = rep(0.5, nrow(P0)))),</span>
            <span class="dt">parameters.to.save =</span> params,
            <span class="dt">model.file=</span>model
)
sim.mcmc &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">as.mcmc</span>(sim)[[<span class="dv">1</span>]])
sim.mcmc.means &lt;-<span class="st"> </span><span class="kw">colMeans</span>(sim.mcmc)
sim.mcmc.means[!<span class="kw">grepl</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">[&quot;</span>, <span class="kw">names</span>(sim.mcmc.means))][<span class="dv">1</span>:<span class="dv">3</span>] -&gt;<span class="st"> </span>theta

factorid &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">factorid =</span> <span class="kw">as.integer</span>(<span class="kw">as.factor</span>(allgameshots$globalplayerid)),
  <span class="dt">globalplayerid =</span> allgameshots$globalplayerid
) %&gt;%<span class="st"> </span><span class="kw">unique</span>()

playermapshots &lt;-<span class="st"> </span><span class="kw">merge</span>(factorid, playermap, <span class="dt">by=</span><span class="st">&quot;globalplayerid&quot;</span>, <span class="dt">all=</span><span class="ot">TRUE</span>)
playermapparams &lt;-<span class="st"> </span>playermapshots %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">int =</span> <span class="ot">NA</span>, <span class="dt">r =</span> <span class="ot">NA</span>, <span class="dt">theta =</span> <span class="ot">NA</span>)
for(i in <span class="dv">1</span>:<span class="kw">nrow</span>(playermapshots)){
  fid &lt;-<span class="st"> </span>playermapparams$factorid[i]
  if(!<span class="kw">is.na</span>(fid)){
    theta_i &lt;-<span class="st"> </span>sim.mcmc.means[<span class="kw">grep</span>(<span class="kw">paste0</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">[&quot;</span>,fid,<span class="st">&quot;</span><span class="ch">\\</span><span class="st">]&quot;</span>), <span class="kw">names</span>(sim.mcmc.means))]
  }else{
    theta_i &lt;-<span class="st"> </span>theta
  }
  playermapparams[i,<span class="kw">c</span>(<span class="st">&quot;int&quot;</span>, <span class="st">&quot;r&quot;</span>, <span class="st">&quot;theta&quot;</span>)] &lt;-<span class="st"> </span>theta_i

}

post_prob &lt;-<span class="st"> </span>function(<span class="dt">playerid =</span> <span class="ot">NA</span>, <span class="dt">playerseason =</span> <span class="ot">NA</span>){

      Z &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid &amp;<span class="st"> </span>season ==<span class="st"> </span>playerseason) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">logr =</span> <span class="kw">log</span>(r) -<span class="st"> </span><span class="kw">mean</span>(<span class="kw">log</span>(r))) %&gt;%<span class="st"> </span><span class="kw">select</span>(result, theta, logr)

  level &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">sort</span>(<span class="kw">unique</span>(allgameshots$globalplayerid)) ==<span class="st"> </span>playerid)
  indiv_effect &lt;-<span class="st"> </span>sim.mcmc.means[[<span class="kw">paste0</span>(<span class="st">&quot;beta_int[&quot;</span>,level,<span class="st">&quot;]&quot;</span>)]] +<span class="st"> </span>
<span class="st">                  </span>sim.mcmc.means[[<span class="kw">paste0</span>(<span class="st">&quot;beta_r[&quot;</span>,level,<span class="st">&quot;]&quot;</span>)]] +<span class="st"> </span>
<span class="st">                  </span>sim.mcmc.means[[<span class="kw">paste0</span>(<span class="st">&quot;beta_theta[&quot;</span>,level,<span class="st">&quot;]&quot;</span>)]] 
  
  if(<span class="kw">is.na</span>(playerid)){
    indiv_effect &lt;-<span class="st"> </span><span class="dv">0</span>
  }
  

  sim.results &lt;-<span class="st"> </span>arm::<span class="kw">invlogit</span>(sim.mcmc[[<span class="st">&quot;beta_int&quot;</span>]] +<span class="st"> </span>sim.mcmc[[<span class="st">&quot;beta_r&quot;</span>]] %*%<span class="st"> </span><span class="kw">t</span>(Z[[<span class="st">&quot;logr&quot;</span>]]) +<span class="st"> </span>sim.mcmc[[<span class="st">&quot;beta_theta&quot;</span>]] %*%<span class="st"> </span><span class="kw">t</span>(Z[[<span class="st">&quot;theta&quot;</span>]]) +<span class="st"> </span>indiv_effect)
  
}</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="3-proc.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="5-results.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": [["thesis.pdf", "PDF"], ["thesis.epub", "EPUB"], ["thesis.docx", "Word"]],
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
