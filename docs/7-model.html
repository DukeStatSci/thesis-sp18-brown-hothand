<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>My Final College Paper</title>
  <meta name="description" content="My Final College Paper">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="My Final College Paper" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="My Final College Paper" />
  
  
  

<meta name="author" content="Nathaniel Brown">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="6-EDA.html">
<link rel="next" href="8-disc.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./"></a></li>
<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Delete line 7 if you only have one advisor</a></li>
<li class="chapter" data-level="2" data-path="2-placeholder.html"><a href="2-placeholder.html"><i class="fa fa-check"></i><b>2</b> Placeholder</a></li>
<li class="chapter" data-level="3" data-path="3-placeholder-1.html"><a href="3-placeholder-1.html"><i class="fa fa-check"></i><b>3</b> Placeholder</a><ul>
<li class="chapter" data-level="3.0.1" data-path="3-placeholder-1.html"><a href="3-placeholder-1.html#how-do-i-get-the-full-citations-to-show-up-and-not-just-last-name-and-year"><i class="fa fa-check"></i><b>3.0.1</b> how do I get the full citations to show up and not just last name and year?</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="4-data.html"><a href="4-data.html"><i class="fa fa-check"></i><b>4</b> Data</a></li>
<li class="chapter" data-level="5" data-path="5-proc.html"><a href="5-proc.html"><i class="fa fa-check"></i><b>5</b> Procedure</a></li>
<li class="chapter" data-level="6" data-path="6-EDA.html"><a href="6-EDA.html"><i class="fa fa-check"></i><b>6</b> Exploratory Data Analysis</a></li>
<li class="chapter" data-level="7" data-path="7-model.html"><a href="7-model.html"><i class="fa fa-check"></i><b>7</b> Models</a></li>
<li class="chapter" data-level="8" data-path="8-disc.html"><a href="8-disc.html"><i class="fa fa-check"></i><b>8</b> Discussion</a></li>
<li class="chapter" data-level="9" data-path="9-the-first-appendix.html"><a href="9-the-first-appendix.html"><i class="fa fa-check"></i><b>9</b> The First Appendix</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">My Final College Paper</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="model" class="section level1">
<h1><span class="header-section-number">Chapter 7</span> Models</h1>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mvtnorm); <span class="kw">library</span>(dplyr); <span class="kw">library</span>(ggplot2); <span class="kw">library</span>(R2jags); <span class="kw">library</span>(pROC); <span class="kw">library</span>(knitr)</code></pre></div>
<pre><code>Warning: package &#39;dplyr&#39; was built under R version 3.3.3</code></pre>
<pre><code>
Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>The following objects are masked from &#39;package:stats&#39;:

    filter, lag</code></pre>
<pre><code>The following objects are masked from &#39;package:base&#39;:

    intersect, setdiff, setequal, union</code></pre>
<pre><code>Warning: package &#39;ggplot2&#39; was built under R version 3.3.3</code></pre>
<pre><code>Warning: package &#39;R2jags&#39; was built under R version 3.3.3</code></pre>
<pre><code>Loading required package: rjags</code></pre>
<pre><code>Warning: package &#39;rjags&#39; was built under R version 3.3.2</code></pre>
<pre><code>Loading required package: coda</code></pre>
<pre><code>Linked to JAGS 4.2.0</code></pre>
<pre><code>Loaded modules: basemod,bugs</code></pre>
<pre><code>
Attaching package: &#39;R2jags&#39;</code></pre>
<pre><code>The following object is masked from &#39;package:coda&#39;:

    traceplot</code></pre>
<pre><code>Warning: package &#39;pROC&#39; was built under R version 3.3.3</code></pre>
<pre><code>Type &#39;citation(&quot;pROC&quot;)&#39; for a citation.</code></pre>
<pre><code>
Attaching package: &#39;pROC&#39;</code></pre>
<pre><code>The following objects are masked from &#39;package:stats&#39;:

    cov, smooth, var</code></pre>
<pre><code>Warning: package &#39;knitr&#39; was built under R version 3.3.3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#generating shot success probabilities</span>
<span class="co">#theta &lt;- matrix(c(-0.5, 1.5, -5.5)) #GLM parameters (intercept, angle, log distance)</span>
datafolder &lt;-<span class="st"> &quot;C:/Users/Nathaniel Brown/Documents/important things/DMBBall Data&quot;</span>
githubfolder &lt;-<span class="st"> &quot;C:/Users/Nathaniel Brown/Documents/GitHub/thesis-sp18-brown-hothand/&quot;</span>
<span class="kw">setwd</span>(githubfolder)
<span class="kw">source</span>(<span class="st">&quot;sportvu_fxns.R&quot;</span>)</code></pre></div>
<pre><code>Warning: package &#39;xml2&#39; was built under R version 3.3.3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">id1 &lt;-<span class="st"> </span><span class="dv">887661</span>
id2 &lt;-<span class="st"> </span><span class="dv">842296</span></code></pre></div>
<p>For our models, we consider the shot location and the shooter identity as factors that can affect a shot outcome. For each of the following models, location is parametrized in polar coordinates, as described in the table below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta &lt;-<span class="st"> &quot;\u03b8&quot;</span>
root &lt;-<span class="st"> &quot;\u221a&quot;</span>
pi &lt;-<span class="st"> &quot;\u03c0&quot;</span>
paramstr &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;distance&quot;</span>,<span class="st">&quot;angle&quot;</span>,
              <span class="kw">paste0</span>(<span class="st">&quot;r = &quot;</span>,root,<span class="st">&quot;(x^2^ + y^2^)&quot;</span>), <span class="kw">paste0</span>(theta,<span class="st">&quot; = arctan(x/y)&quot;</span>),
              <span class="st">&quot;r &gt; 0&quot;</span>, <span class="kw">paste0</span>(<span class="st">&quot;-&quot;</span>,pi,<span class="st">&quot; &lt; \u03b8 &lt; &quot;</span>,pi))

paramtab &lt;-<span class="st"> </span><span class="kw">matrix</span>(paramstr,<span class="dt">ncol=</span><span class="dv">3</span>)
<span class="kw">colnames</span>(paramtab) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Parameter&quot;</span>,<span class="st">&quot;Formula&quot;</span>,<span class="st">&quot;Range&quot;</span>)
<span class="kw">kable</span>(paramtab)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="left">Formula</th>
<th align="left">Range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">distance</td>
<td align="left">r = v(x<sup>2</sup> + y<sup>2</sup>)</td>
<td align="left">r &gt; 0</td>
</tr>
<tr class="even">
<td align="left">angle</td>
<td align="left"><U+03B8> = arctan(x/y)</td>
<td align="left">-p &lt; <U+03B8> &lt; p</td>
</tr>
</tbody>
</table>
<div id="generalized-linear-model" class="section level4">
<h4><span class="header-section-number">7.0.0.1</span> Generalized Linear Model</h4>
<p>The results of the credible intervals are reported for the same four players, in the same order.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">playerid &lt;-<span class="st"> </span>id2
seasons &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2014</span>,<span class="dv">2015</span>,<span class="dv">2016</span>,<span class="dv">2017</span>)

priormod &lt;-<span class="st"> </span><span class="kw">glm</span>(result ~<span class="st"> </span>r +<span class="st"> </span>theta, <span class="dt">data=</span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(<span class="kw">as.integer</span>(<span class="kw">as.factor</span>(gameid)) &lt;<span class="st"> </span><span class="dv">5</span>), <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)

build_glm &lt;-<span class="st"> </span>function(playerids, <span class="dt">seasons =</span> <span class="dv">2014</span>:<span class="dv">2017</span>){
  
  model.glm &lt;-<span class="st"> </span>function(){
  
    <span class="co"># N observations</span>
    for(i in <span class="dv">1</span>:N){
      result[i] ~<span class="st"> </span><span class="kw">dbern</span>(prob[i])
      <span class="kw">logit</span>(prob[i]) &lt;-<span class="st"> </span>beta_int*int[i] +<span class="st"> </span>beta_r*logr[i] +<span class="st"> </span>beta_theta*theta[i]
    }

    <span class="co"># Priors</span>
    beta_int   ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="fl">0.1</span>)
    beta_r     ~<span class="st"> </span><span class="kw">dnorm</span>(mu0r, <span class="fl">0.01</span>) <span class="co">#would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.</span>
    beta_theta ~<span class="st"> </span><span class="kw">dnorm</span>(mu0theta, <span class="fl">0.1</span>)

  }

  allgameshots_sub &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid %in%<span class="st"> </span>playerids &amp;
<span class="st">                                            </span>season %in%<span class="st"> </span>seasons)

  mu0r &lt;-<span class="st"> </span><span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Estimate&quot;</span>]
  mu0theta &lt;-<span class="st"> </span><span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>]
  tau0r &lt;-<span class="st"> </span><span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>]^<span class="dv">2</span>
  tau0theta &lt;-<span class="st"> </span><span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>]^<span class="dv">2</span>

  datlist.glm &lt;-<span class="st">  </span><span class="kw">list</span>(
                    <span class="dt">logr =</span> <span class="kw">log</span>(allgameshots_sub$r), 
                    <span class="dt">theta =</span> allgameshots_sub$theta, 
                    <span class="dt">result =</span> allgameshots_sub$result, 
                    <span class="dt">N =</span> <span class="kw">nrow</span>(allgameshots_sub), 
                    <span class="dt">int =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(allgameshots_sub)), 
                    <span class="dt">mu0r =</span> <span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Estimate&quot;</span>],
                    <span class="dt">mu0theta =</span> <span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>]
                )
  params.glm &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;beta_int&quot;</span>,<span class="st">&quot;beta_r&quot;</span>, <span class="st">&quot;beta_theta&quot;</span>)


  sim &lt;-<span class="st"> </span><span class="kw">jags</span>(<span class="dt">data =</span> datlist.glm, 
              <span class="dt">n.iter =</span> <span class="dv">10000</span>, <span class="dt">n.chains =</span> <span class="dv">1</span>, <span class="dt">n.burnin =</span> <span class="dv">500</span>,
              <span class="co">#inits=list(list(p = rep(0.5, nrow(P0)))),</span>
              <span class="dt">parameters.to.save =</span> params.glm,
              <span class="dt">model.file=</span>model.glm
  )
  sim.mcmc &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">as.mcmc</span>(sim)[[<span class="dv">1</span>]])
  <span class="kw">return</span>(sim.mcmc)
}



plot_params &lt;-<span class="st"> </span>function(<span class="dt">sim.mcmc =</span> <span class="ot">NA</span>){
  
    coefs &lt;-<span class="st"> </span>sim.mcmc[,<span class="kw">c</span>(<span class="st">&quot;beta_int&quot;</span>,<span class="st">&quot;beta_r&quot;</span>,<span class="st">&quot;beta_theta&quot;</span>)] %&gt;%<span class="st"> </span><span class="kw">apply</span>(<span class="dv">2</span>, quantile, <span class="kw">c</span>(<span class="fl">0.025</span>,<span class="fl">0.5</span>,<span class="fl">0.975</span>)) %&gt;%<span class="st"> </span><span class="kw">t</span>() %&gt;%<span class="st"> </span><span class="kw">as.data.frame</span>()
    
    <span class="kw">colnames</span>(coefs) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;lo&quot;</span>, <span class="st">&quot;mid&quot;</span>, <span class="st">&quot;hi&quot;</span>)
  
    <span class="kw">ggplot</span>(<span class="dt">data =</span> coefs, <span class="kw">aes</span>(<span class="dt">x=</span><span class="kw">c</span>(<span class="st">&quot;intercept&quot;</span>,<span class="st">&quot;distance&quot;</span>,<span class="st">&quot;angle&quot;</span>),<span class="dt">y=</span>mid)) +<span class="st"> </span>
<span class="st">      </span><span class="kw">geom_point</span>() +<span class="st"> </span>
<span class="st">      </span><span class="kw">geom_errorbar</span>(<span class="kw">aes</span>(<span class="dt">ymin=</span>lo, <span class="dt">ymax=</span>hi), <span class="dt">width=</span><span class="fl">0.5</span>) +<span class="st"> </span>
<span class="st">      </span><span class="kw">geom_abline</span>(<span class="dt">intercept=</span><span class="dv">0</span>, <span class="dt">slope=</span><span class="dv">0</span>, <span class="dt">linetype=</span><span class="dv">2</span>) +<span class="st"> </span>
<span class="st">      </span><span class="kw">labs</span>(<span class="dt">title=</span><span class="st">&quot;GLM Posterior Parameters (95% error)&quot;</span>,<span class="dt">x=</span><span class="st">&quot;predictor&quot;</span>, <span class="dt">y=</span><span class="st">&quot;estimate&quot;</span>) +<span class="st"> </span>
<span class="st">      </span><span class="kw">theme_bw</span>()
}

for(i in <span class="kw">c</span>(id1, id2)){
  for(j in <span class="dv">2014</span>:<span class="dv">2017</span>){
    <span class="kw">print</span>(<span class="kw">plot_params</span>(i,j))
  }
}</code></pre></div>
</div>
<div id="dynamic-generalized-linear-model" class="section level4">
<h4><span class="header-section-number">7.0.0.2</span> Dynamic Generalized Linear Model</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#TO DO:</span>
<span class="co">#send prof west the ft array (location and angle data, and intercept) and the binary y vector data. (check)</span>
<span class="co">#make a mixed effects GLM with random player effect (check?)</span>
<span class="co">#use JAGS or rstan for logistic regression random effects MCMC (check?)</span>

playerid &lt;-<span class="st"> </span>id1
Z &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">logr =</span> <span class="kw">log</span>(r) -<span class="st"> </span><span class="kw">mean</span>(<span class="kw">log</span>(r))) %&gt;%<span class="st"> </span><span class="kw">select</span>(theta, logr) %&gt;%<span class="st"> </span><span class="kw">cbind</span>(<span class="dv">1</span>,.)
X &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid) %&gt;%<span class="st"> </span><span class="kw">select</span>(<span class="dt">x=</span>xt, <span class="dt">y=</span>yt)
y &lt;-<span class="st"> </span>allgameshots %&gt;%<span class="st"> </span><span class="kw">filter</span>(globalplayerid ==<span class="st"> </span>playerid) %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">logr =</span> <span class="kw">log</span>(r) -<span class="st"> </span><span class="kw">mean</span>(<span class="kw">log</span>(r))) %&gt;%<span class="st"> </span><span class="kw">select</span>(result) %&gt;%<span class="st"> &#39;[[&#39;</span>(<span class="dv">1</span>)

ym &lt;-<span class="st"> </span><span class="dv">94</span>; xm &lt;-<span class="st"> </span><span class="dv">50</span>
shots &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">TRUE</span>,<span class="kw">nrow</span>(Z)) <span class="co">#no missing shots in this case</span>
tshot &lt;-<span class="st"> </span><span class="kw">which</span>(shots)
nshots &lt;-<span class="st"> </span><span class="kw">length</span>(tshot)
T &lt;-<span class="st"> </span><span class="kw">length</span>(shots)

<span class="co">#generating shot outcomes</span>

iy &lt;-<span class="st"> </span><span class="kw">which</span>(y[!<span class="kw">is.nan</span>(y)] ==<span class="st"> </span><span class="dv">1</span>)

<span class="co">#initial parameters</span>
mod &lt;-<span class="st"> </span>(<span class="kw">glm</span>(y ~<span class="st"> </span>theta +<span class="st"> </span>logr, <span class="dt">data=</span>Z, <span class="dt">family=</span><span class="st">&quot;binomial&quot;</span>)) <span class="co">#high p-values everywhere</span>
theta &lt;-<span class="st"> </span><span class="kw">coef</span>(mod)

p &lt;-<span class="st"> </span><span class="kw">length</span>(theta)
pscore &lt;-<span class="st"> </span><span class="kw">fitted</span>(mod, <span class="dt">type=</span><span class="st">&quot;response&quot;</span>)
q &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NaN</span>, T)
q[shots] &lt;-<span class="st"> </span>pscore

<span class="kw">par</span>(<span class="dt">xpd=</span><span class="ot">TRUE</span>)
<span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dt">type=</span><span class="st">&quot;n&quot;</span>,<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">ylab =</span> <span class="st">&quot;probability&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;time index&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;GLM Predictions&quot;</span>)
<span class="kw">points</span>(tshot, q[tshot], <span class="dt">pch=</span><span class="dv">4</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(tshot, y[tshot], <span class="dt">pch=</span><span class="dv">1</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">legend</span>(<span class="dt">x=</span>T*.<span class="dv">8</span>, <span class="dt">y=</span><span class="fl">1.21</span>, <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;probability&quot;</span>, <span class="st">&quot;outcome&quot;</span>), <span class="dt">pch =</span> <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">1</span>), <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>))

<span class="kw">par</span>(<span class="dt">xpd=</span><span class="ot">FALSE</span>)
<span class="kw">plot</span>(X[iy,<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)], <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,ym), <span class="dt">xlim=</span><span class="kw">c</span>(-xm/<span class="dv">2</span>,xm/<span class="dv">2</span>), <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">pch =</span> <span class="dv">3</span>, <span class="dt">xlab=</span><span class="st">&quot;x&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;y&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Makes and Misses&quot;</span>)
<span class="kw">points</span>(X[-iy,<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>)], <span class="dt">col =</span><span class="st">&quot;blue&quot;</span>, <span class="dt">pch =</span> <span class="dv">1</span>)
<span class="kw">abline</span>(<span class="dt">h=</span>ym/<span class="dv">2</span>)
<span class="kw">points</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>, <span class="dt">cex=</span><span class="dv">2</span>)



<span class="co">#Forward Filtering</span>

<span class="co">#set up DGLM and initial prior</span>
<span class="co">#first, set up covariates per time interval</span>
F &lt;-<span class="st"> </span><span class="kw">t</span>(Z)
p &lt;-<span class="st"> </span><span class="kw">dim</span>(F)[<span class="dv">1</span>]
<span class="co">#theta = state vector (GLM parameters) (px1)</span>
<span class="co">#F = the data...regression vectors for all t...aka the design matrix (pxT)</span>
<span class="co">#G = known evolution matrix ???????</span>
<span class="co">#omega = evolution errors with 0 mean and known variance matrix W</span>
<span class="co">#g(.) = function to map eta to real line (logit)</span>

mt &lt;-<span class="st"> </span>theta
Ct &lt;-<span class="st"> </span><span class="kw">diag</span>(p)
<span class="co">#mt = prior mean vector</span>
<span class="co">#Ct = prior covariance matrix</span>
<span class="co">#(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1])</span>


delta &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co">#0.99 #discount factor; &quot;streaky parameter&quot;</span>
<span class="co">#forward filtering (FF)</span>
smt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">0</span>,p*T), <span class="dt">nrow=</span>p)           <span class="co">#save post means</span>
sCt &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">rep</span>(<span class="dv">0</span>,p*p*T), <span class="dt">dim =</span> <span class="kw">c</span>(p,p,T))  <span class="co">#save post covars</span>
spt &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NaN</span>, T)                          <span class="co">#save post prob success</span>
lmlik &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>,T)                           <span class="co">#marg lik per time int</span>
ishot &lt;-<span class="st"> </span><span class="dv">0</span>

rtst &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="kw">c</span>(T,<span class="dv">2</span>))
for(t in <span class="dv">1</span>:T){
  if(t %in%<span class="st"> </span>tshot){
    <span class="co">#current shot attempt index, and time</span>
    ishot &lt;-<span class="st"> </span>ishot +<span class="st"> </span><span class="dv">1</span>
    ti &lt;-<span class="st"> </span>tshot[ishot]
    
    ft &lt;-<span class="st"> </span>(F[,ishot]) %*%<span class="st"> </span>mt
    At &lt;-<span class="st"> </span>Ct %*%<span class="st"> </span>F[,ishot]/delta
    qt &lt;-<span class="st"> </span>(F[,ishot]) %*%<span class="st"> </span>At
    At &lt;-<span class="st"> </span>At/<span class="kw">as.numeric</span>(qt)
    
    <span class="co">#at = Gt*mt in txtbk, but = mt here.</span>
    <span class="co">#Rt = Gt*Ct[t-1]*Gt&#39; + Wt in txtbk, but = Ct/delta here</span>
    <span class="co">#f = F&#39;at = F&#39;mt</span>
    <span class="co">#q = F&#39;RF = F&#39;Ct F (1/delta)</span>
    <span class="co">#((lambda,theta)&#39; | Dt-1) ~ N( (f, a), ((q, F&#39;C/delta),(CF/delta, C)) )</span>

    <span class="co">#what is mu tho?</span>
    <span class="co">#???????????????????????</span>
    <span class="co">#&quot;the samp dist of Yt depends on thetat only via the single quantity mut</span>
    <span class="co">#prior: (mu|Dt) ~ N(f, q)</span>
    <span class="co">#Vt &gt; 0 is scale parameter aka precision of distribution...</span>
    <span class="co">#but precision of what??? what is b(Yt, Vt?)</span>
    <span class="co">#Q = q + Vt</span>
    <span class="co">#post:  (mu|Dt) ~ N(f*, q*)</span>
    
    <span class="co">#f* = </span>
    <span class="co">#what is mu???</span>
    <span class="co">#f = F&#39;a which is</span>
    
    <span class="co">#prior mean and var of linear predictor, and adaptive vector</span>
    <span class="co">#compute approx prior Beta(r,s) params; update w/ numerical iterations for exact values</span>
    eft &lt;-<span class="st"> </span><span class="kw">exp</span>(ft)   <span class="co">#crude initial values</span>
    rt &lt;-<span class="st"> </span>(<span class="dv">1</span>+eft)/qt
    st &lt;-<span class="st"> </span>rt/eft
    rt &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="fl">0.5</span>, rt)
    st &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="fl">0.5</span>, st)
    
    
    

    <span class="co">#fts = ft* = posterior mean of ????</span>
    <span class="co">#qts = qt* = posterior variance of something ???</span>
    <span class="co">#iterative numerical solution (maybe comment out)</span>
    ep &lt;-<span class="st"> </span><span class="fl">0.5</span>; drt &lt;-<span class="st"> </span><span class="dv">1</span>; dst &lt;-<span class="st"> </span><span class="dv">1</span>; xt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(rt, st))
    while(<span class="kw">max</span>(drt, dst) &lt;<span class="st"> </span>ep){
      r0t &lt;-<span class="st"> </span><span class="kw">psigamma</span>(rt,<span class="dv">0</span>); s0t &lt;-<span class="st"> </span><span class="kw">psigamma</span>(st,<span class="dv">0</span>)
      r1t &lt;-<span class="st"> </span><span class="kw">psigamma</span>(rt,<span class="dv">1</span>); s1t &lt;-<span class="st"> </span><span class="kw">psigamma</span>(st,<span class="dv">1</span>)
      fxt &lt;-<span class="st"> </span><span class="kw">c</span>(r0t-s0t-ft, r1t+s1t-qt)
      Axt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(r1t, -s1t, <span class="kw">psigamma</span>(rt, <span class="dv">2</span>), <span class="kw">psigamma</span>(st, <span class="dv">2</span>)), <span class="dt">ncol=</span><span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
      xt &lt;-<span class="st"> </span>xt -<span class="st"> </span><span class="kw">solve</span>(Axt, fxt)
      drt &lt;-<span class="st"> </span>xt[<span class="dv">1</span>] -<span class="st"> </span>rt; dst &lt;-<span class="st"> </span>xt[<span class="dv">2</span>] -<span class="st"> </span>st
      rt &lt;-<span class="st"> </span>xt[<span class="dv">1</span>]; st &lt;-<span class="st"> </span>xt[<span class="dv">2</span>]
    }
    
    rtst[t,] &lt;-<span class="st"> </span><span class="kw">c</span>(rt, st)
    
    <span class="co"># if(rt &gt; 1000){</span>
    <span class="co">#   break</span>
    <span class="co"># }</span>
    
    lmlik[t] &lt;-<span class="st"> </span><span class="kw">lgamma</span>(rt+st) -<span class="st"> </span><span class="kw">lgamma</span>(rt) -<span class="st"> </span><span class="kw">lgamma</span>(st) +<span class="st"> </span>
<span class="st">                </span><span class="kw">lgamma</span>(rt+y[t]) +<span class="st"> </span><span class="kw">lgamma</span>(st<span class="dv">+1</span>-y[t]) -<span class="st"> </span><span class="kw">lgamma</span>(rt+st<span class="dv">+1</span>) +<span class="st"> </span>
<span class="st">                </span><span class="kw">lgamma</span>(<span class="dv">2</span>) -<span class="st"> </span><span class="kw">lgamma</span>(<span class="dv">1</span>+y[t]) -<span class="st"> </span><span class="kw">lgamma</span>(<span class="dv">2</span>-y[t])
    rts &lt;-<span class="st"> </span>rt +<span class="st"> </span>y[t]; sts &lt;-<span class="st"> </span>st +<span class="st"> </span><span class="dv">1</span>-y[t] <span class="co">#posterior beta params</span>
    <span class="co">#convert to mean and variance for linear predictor</span>
    fts &lt;-<span class="st"> </span><span class="kw">psigamma</span>(rts,<span class="dv">0</span>)-<span class="kw">psigamma</span>(sts,<span class="dv">0</span>); qts &lt;-<span class="st"> </span><span class="kw">psigamma</span>(rts,<span class="dv">1</span>)+<span class="kw">psigamma</span>(sts,<span class="dv">1</span>)
    spt[t] &lt;-<span class="st"> </span>rts/(sts+rts)
    
    <span class="co">#update state parameters</span>
    mt &lt;-<span class="st"> </span>mt+At%*%(fts-ft)
    Ct &lt;-<span class="st"> </span>Ct/delta -<span class="st"> </span>(At%*%<span class="kw">t</span>(At))*<span class="kw">as.numeric</span>(qt-qts)
    Ct &lt;-<span class="st"> </span>(Ct +<span class="st"> </span><span class="kw">t</span>(Ct))/<span class="dv">2</span>
    <span class="kw">c</span>(t, rt, st, mt)
    
    if(<span class="kw">any</span>(<span class="kw">is.nan</span>(mt))){
      <span class="kw">print</span>(<span class="st">&quot;stop&quot;</span>)
      break
    }
    
  }
  smt[,t] &lt;-<span class="st"> </span>mt; sCt[,,t] &lt;-<span class="st"> </span>Ct <span class="co">#saving</span>
}

<span class="kw">par</span>(<span class="dt">xpd=</span><span class="ot">TRUE</span>)
<span class="kw">plot</span>(smt[<span class="dv">1</span>,],<span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;shot index&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;online state mean&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Dynamic Parameters&quot;</span>)
<span class="kw">lines</span>(smt[<span class="dv">2</span>,],<span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;orange&quot;</span>)
<span class="kw">lines</span>(smt[<span class="dv">3</span>,],<span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;yellow&quot;</span>)
<span class="kw">legend</span>(<span class="dt">x=</span>T*.<span class="dv">75</span>, <span class="dt">y=</span><span class="dv">4</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;intercept&quot;</span>, <span class="st">&quot;angle&quot;</span>, <span class="st">&quot;log(distance)&quot;</span>), <span class="dt">pch =</span> <span class="kw">c</span>(<span class="dv">16</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;yellow&quot;</span>))

<span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dt">type=</span><span class="st">&quot;n&quot;</span>,<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">ylab =</span> <span class="st">&quot;probability&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;time index&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;DGLM Predictions&quot;</span>)
<span class="kw">points</span>(tshot, spt[tshot], <span class="dt">pch=</span><span class="dv">4</span>, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(tshot, y[tshot], <span class="dt">pch=</span><span class="dv">1</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">legend</span>(<span class="dt">x=</span>T*.<span class="dv">8</span>, <span class="dt">y=</span><span class="fl">1.21</span>, <span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;probability&quot;</span>, <span class="st">&quot;outcome&quot;</span>), <span class="dt">pch =</span> <span class="kw">c</span>(<span class="dv">4</span>,<span class="dv">1</span>), <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>))

<span class="co">#arm::binnedplot(x=spt[tshot], y=y[tshot]-spt[tshot])</span>




<span class="co">#Backward sampling</span>
nmc &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="co">#save posterior means and posterior success probs</span>
MCtheta &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="kw">c</span>(p, T, nmc)) 
MCq &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>, <span class="kw">c</span>(T, nmc))

<span class="co">#begin BS at timeunit T</span>
thetat &lt;-<span class="st"> </span><span class="kw">rmvnorm</span>(<span class="dt">n=</span>nmc, smt[,T], sCt[,,T]) <span class="co">#SOMETIMES sCT[,,T] IS NOT POSITIVE DEFINITE. DEPENDS ON RANDOM SEED.</span>
MCtheta[,T,] &lt;-<span class="st"> </span><span class="kw">t</span>(thetat)
MCq[T,] &lt;-<span class="st"> </span><span class="dv">1</span>/(<span class="dv">1</span>+<span class="kw">exp</span>(-thetat %*%<span class="st"> </span>F[,nshots]))

<span class="co">#then recurse backwards</span>
ishot &lt;-<span class="st"> </span>nshots +<span class="st"> </span><span class="dv">1</span>
for(t in (T<span class="dv">-1</span>):<span class="dv">1</span>){
  if(t %in%<span class="st"> </span>tshot){
    ht =<span class="st"> </span>(<span class="dv">1</span>-delta)*<span class="kw">t</span>(<span class="kw">array</span>(smt[,t], <span class="kw">c</span>(<span class="kw">dim</span>(smt)[<span class="dv">1</span>], nmc))) +<span class="st"> </span>delta*thetat
    <span class="co">#run a simulation for each row of ht and each 3rd dim of sCt</span>
    thetat &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(ht, <span class="dv">1</span>, rmvnorm, <span class="dt">n=</span><span class="dv">1</span>, <span class="dt">sigma =</span> sCt[,,t]*(<span class="dv">1</span>-delta)))
    MCtheta[,t,] &lt;-<span class="st"> </span><span class="kw">t</span>(thetat)
    ishot &lt;-<span class="st"> </span>ishot -<span class="st"> </span><span class="dv">1</span>; ti &lt;-<span class="st"> </span>tshot[ishot]
    MCq[t,] &lt;-<span class="st"> </span><span class="dv">1</span>/(<span class="dv">1</span>+<span class="kw">exp</span>(-thetat %*%<span class="st"> </span>F[,ishot]))
  }
}

<span class="co">#retrospective posterior summaries</span>
<span class="co">#posterior of shot probabilities?</span>
pr &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(MCq[tshot,], <span class="dv">1</span>, quantile, <span class="kw">c</span>(.<span class="dv">025</span>, .<span class="dv">25</span>, .<span class="dv">5</span>, .<span class="dv">75</span>, .<span class="dv">975</span>))) <span class="co">#get quantiles of each row</span>
<span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T), <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">main =</span> <span class="st">&quot;Posterior Probability&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;hit rate&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;time interval&quot;</span>) 
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">1</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">5</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
<span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">1</span>], <span class="kw">rev</span>(pr[,<span class="dv">5</span>])),
        <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">2</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">4</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
<span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">2</span>], <span class="kw">rev</span>(pr[,<span class="dv">4</span>])),
        <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
<span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">3</span>], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
<span class="kw">points</span>(<span class="dt">x=</span><span class="dv">1</span>:T, <span class="dt">y=</span>y, <span class="dt">pch=</span><span class="dv">1</span>)

<span class="co">#posteriors of parameters from DGLM</span>
posterior_labels &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Posterior Intercept&quot;</span>, <span class="st">&quot;Posterior Angle&quot;</span>, <span class="st">&quot;Posterior Log Distance&quot;</span>)
for(j in <span class="dv">1</span>:p){
  
  pr =<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(MCtheta[j,tshot,], <span class="dv">1</span>, quantile, <span class="kw">c</span>(.<span class="dv">025</span>, .<span class="dv">25</span>, .<span class="dv">5</span>, .<span class="dv">75</span>, .<span class="dv">975</span>)))
  <span class="kw">plot</span>(<span class="dv">0</span>,<span class="dv">0</span>, <span class="dt">type=</span><span class="st">&quot;n&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,T), <span class="dt">ylim =</span> <span class="kw">range</span>(pr), <span class="dt">main =</span> posterior_labels[j], <span class="dt">xlab =</span> <span class="st">&quot;time interval&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;state vector element&quot;</span>) 
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">1</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">5</span>], <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>)
  <span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">1</span>], <span class="kw">rev</span>(pr[,<span class="dv">5</span>])),
          <span class="dt">col =</span> <span class="st">&quot;gray&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">2</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
  <span class="kw">lines</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">4</span>], <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
  <span class="kw">polygon</span>(<span class="kw">c</span>(tshot, <span class="kw">rev</span>(tshot)), <span class="kw">c</span>(pr[,<span class="dv">2</span>], <span class="kw">rev</span>(pr[,<span class="dv">4</span>])),
          <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">border =</span> <span class="ot">NA</span>)
  <span class="kw">points</span>(<span class="dt">x=</span>tshot, <span class="dt">y=</span>pr[,<span class="dv">3</span>], <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">pch =</span> <span class="dv">4</span>)
  
}

<span class="kw">proc</span>(y,q, <span class="dt">main=</span><span class="st">&quot;ROC Curve for GLM&quot;</span>)
<span class="kw">proc</span>(y,spt, <span class="dt">main=</span><span class="st">&quot;ROC Curve for DGLM&quot;</span>)</code></pre></div>
</div>
<div id="hierarchichal-model" class="section level4">
<h4><span class="header-section-number">7.0.0.3</span> Hierarchichal Model</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># TODO:</span>
<span class="co"># for beta priors, build a glm on a few games without player-specific measurements.</span>
<span class="co">#   use means and precisions of these team glm betas as priors for gibbs betas</span>
<span class="co">#   these will give you prior means. and use generally wide prior variances.</span>
<span class="co"># investigate positive beta_r</span>


<span class="co"># model2 &lt;- function(){</span>
<span class="co">#     # N observations</span>
<span class="co">#     for(i in 1:N){</span>
<span class="co">#       result[i] ~ dbern(prob[i])</span>
<span class="co">#       logit(prob[i]) &lt;- beta_int*int[i] + e_int[player[i]] + beta_r*logr[i] + e_r[player[i]] + beta_theta*theta[i] + e_theta[player[i]] # a random &#39;e&#39; here or is that implied?</span>
<span class="co">#     }</span>
<span class="co">#     # priors on random player effects</span>
<span class="co">#     for(j in 1:M){</span>
<span class="co">#         e_int[j] ~ dnorm(beta_int,tau)</span>
<span class="co">#         e_r[j] ~ dnorm(beta_r,tau)</span>
<span class="co">#         e_theta[j] ~ dnorm(beta_theta,tau)</span>
<span class="co">#     }</span>
<span class="co">#     # Priors</span>
<span class="co">#     beta_int   ~ dnorm(0.0,0.1)</span>
<span class="co">#     beta_r     ~ dnorm(mu0r,0.1)</span>
<span class="co">#     beta_theta ~ dnorm(mu0theta,0.1)</span>
<span class="co"># </span>
<span class="co">#     # Hyperpriors</span>
<span class="co">#     tau ~ dgamma(0.1,0.1)</span>
<span class="co"># }</span>

model.hier &lt;-<span class="st"> </span>function(){
    <span class="co"># N observations</span>
    for(i in <span class="dv">1</span>:N){
      result[i] ~<span class="st"> </span><span class="kw">dbern</span>(prob[i])
      <span class="kw">logit</span>(prob[i]) &lt;-<span class="st"> </span>beta_int[player[i]]*int[i] +<span class="st"> </span>beta_r[player[i]]*logr[i] +<span class="st"> </span>beta_theta[player[i]]*theta[i]
    }
    <span class="co"># priors on random player effects</span>
    for(j in <span class="dv">1</span>:M){
        beta_int[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_int0,tau_int)
        beta_r[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_r0,tau_r)
        beta_theta[j] ~<span class="st"> </span><span class="kw">dnorm</span>(beta_theta0,tau_theta)
    }
    <span class="co"># Priors</span>
    beta_int0   ~<span class="st"> </span><span class="kw">dnorm</span>(<span class="dv">0</span>, <span class="fl">0.1</span>)
    beta_r0     ~<span class="st"> </span><span class="kw">dnorm</span>(mu0r, <span class="fl">0.01</span>) <span class="co">#would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.</span>
    beta_theta0 ~<span class="st"> </span><span class="kw">dnorm</span>(mu0theta, <span class="fl">0.1</span>)

    <span class="co"># Hyperpriors</span>
    tau_int ~<span class="st"> </span><span class="kw">dgamma</span>(<span class="dv">10</span>, <span class="dv">100</span>)
    tau_r ~<span class="st"> </span><span class="kw">dgamma</span>(<span class="dv">10</span>, <span class="fl">0.2</span>)
    tau_theta ~<span class="st"> </span><span class="kw">dgamma</span>(<span class="dv">10</span>, <span class="dv">10</span>)
}

datlist &lt;-<span class="st"> </span><span class="kw">list</span>(
                <span class="dt">logr =</span> <span class="kw">log</span>(allgameshots$r), 
                <span class="dt">theta =</span> allgameshots$theta, 
                <span class="dt">result =</span> allgameshots$result, 
                <span class="dt">player =</span> <span class="kw">as.integer</span>(<span class="kw">as.factor</span>(allgameshots$globalplayerid)),
                <span class="dt">N =</span> <span class="kw">nrow</span>(allgameshots), 
                <span class="dt">int =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(allgameshots)), 
                <span class="dt">M =</span> <span class="kw">n_distinct</span>(allgameshots$globalplayerid),
                <span class="dt">mu0r =</span> <span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Estimate&quot;</span>],
                <span class="dt">mu0theta =</span> <span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>],
                <span class="dt">tau0r =</span> <span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>]^<span class="dv">2</span>,
                <span class="dt">tau0theta =</span> <span class="kw">summary</span>(priormod)[[<span class="st">&quot;coefficients&quot;</span>]][<span class="st">&quot;r&quot;</span>,<span class="st">&quot;Std. Error&quot;</span>]^<span class="dv">2</span>

                )
params &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;beta_int&quot;</span>,<span class="st">&quot;beta_r&quot;</span>, <span class="st">&quot;beta_theta&quot;</span>,<span class="st">&quot;beta_int0&quot;</span>,<span class="st">&quot;beta_r0&quot;</span>, <span class="st">&quot;beta_theta0&quot;</span>, <span class="st">&quot;tau_int&quot;</span>, <span class="st">&quot;tau_r&quot;</span>, <span class="st">&quot;tau_theta&quot;</span>)


sim &lt;-<span class="st"> </span><span class="kw">jags</span>(<span class="dt">data =</span> datlist, 
            <span class="dt">n.iter =</span> <span class="dv">1000</span>, <span class="dt">n.chains =</span> <span class="dv">1</span>, <span class="dt">n.burnin =</span> <span class="dv">100</span>,
            <span class="co">#inits=list(list(p = rep(0.5, nrow(P0)))),</span>
            <span class="dt">parameters.to.save =</span> params,
            <span class="dt">model.file=</span>model.hier
)
sim.mcmc &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">as.mcmc</span>(sim)[[<span class="dv">1</span>]])
sim.mcmc.means &lt;-<span class="st"> </span><span class="kw">colMeans</span>(sim.mcmc)
sim.mcmc.means[!<span class="kw">grepl</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">[&quot;</span>, <span class="kw">names</span>(sim.mcmc.means))][<span class="dv">1</span>:<span class="dv">3</span>] -&gt;<span class="st"> </span>theta

factorid &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">factorid =</span> <span class="kw">as.integer</span>(<span class="kw">as.factor</span>(allgameshots$globalplayerid)),
  <span class="dt">globalplayerid =</span> allgameshots$globalplayerid
) %&gt;%<span class="st"> </span><span class="kw">unique</span>()

playermapshots &lt;-<span class="st"> </span><span class="kw">merge</span>(factorid, playermap, <span class="dt">by=</span><span class="st">&quot;globalplayerid&quot;</span>, <span class="dt">all=</span><span class="ot">TRUE</span>)
playermapparams &lt;-<span class="st"> </span>playermapshots %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">int =</span> <span class="ot">NA</span>, <span class="dt">r =</span> <span class="ot">NA</span>, <span class="dt">theta =</span> <span class="ot">NA</span>)
for(i in <span class="dv">1</span>:<span class="kw">nrow</span>(playermapshots)){
  fid &lt;-<span class="st"> </span>playermapparams$factorid[i]
  if(!<span class="kw">is.na</span>(fid)){
    theta_i &lt;-<span class="st"> </span>sim.mcmc.means[<span class="kw">grep</span>(<span class="kw">paste0</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">[&quot;</span>,fid,<span class="st">&quot;</span><span class="ch">\\</span><span class="st">]&quot;</span>), <span class="kw">names</span>(sim.mcmc.means))]
  }else{
    theta_i &lt;-<span class="st"> </span>theta
  }
  playermapparams[i,<span class="kw">c</span>(<span class="st">&quot;int&quot;</span>, <span class="st">&quot;r&quot;</span>, <span class="st">&quot;theta&quot;</span>)] &lt;-<span class="st"> </span>theta_i

}

post_prob &lt;-<span class="st"> </span>function(<span class="dt">newdata=</span><span class="ot">NA</span>){

  
  Z &lt;-<span class="st"> </span><span class="kw">merge</span>(newdata, factorid) %&gt;%<span class="st"> </span><span class="kw">arrange</span>(time)
  levels &lt;-<span class="st"> </span>Z$factorid
  B &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(<span class="kw">as.matrix</span>(levels), <span class="dv">1</span>, function(l){
    <span class="kw">matrix</span>(<span class="kw">c</span>(sim.mcmc.means[[<span class="kw">paste0</span>(<span class="st">&quot;beta_int[&quot;</span>,l,<span class="st">&quot;]&quot;</span>)]],
         sim.mcmc.means[[<span class="kw">paste0</span>(<span class="st">&quot;beta_r[&quot;</span>,l,<span class="st">&quot;]&quot;</span>)]],
         sim.mcmc.means[[<span class="kw">paste0</span>(<span class="st">&quot;beta_theta[&quot;</span>,l,<span class="st">&quot;]&quot;</span>)]]),<span class="dt">ncol=</span><span class="dv">3</span>,<span class="dt">byrow=</span><span class="ot">TRUE</span>
    )}
  ))
  
  X &lt;-<span class="st"> </span>Z %&gt;%<span class="st"> </span><span class="kw">mutate</span>(<span class="dt">logr =</span> <span class="kw">log</span>(r) -<span class="st"> </span><span class="kw">mean</span>(<span class="kw">log</span>(r)), <span class="dt">int=</span><span class="dv">1</span>) %&gt;%<span class="st"> </span><span class="kw">select</span>(int, logr, theta) %&gt;%<span class="st"> </span><span class="kw">as.matrix</span>()

  probs &lt;-<span class="st"> </span>B %&gt;%<span class="st"> &#39;%*%&#39;</span>(<span class="kw">t</span>(X)) %&gt;%<span class="st"> </span><span class="kw">diag</span>() %&gt;%<span class="st"> </span>arm::<span class="kw">invlogit</span>()

  <span class="co"># sim.results &lt;- arm::invlogit(sim.mcmc.means[[&quot;beta_int&quot;]] + sim.mcmc.means[[&quot;beta_r&quot;]] %*% t(Z[[&quot;logr&quot;]]) + sim.mcmc.means[[&quot;beta_theta&quot;]] %*% t(Z[[&quot;theta&quot;]]) + indiv_effect)</span>
  
  <span class="kw">return</span>(probs)
}

<span class="kw">roc</span>(allgameshots$result, <span class="kw">post_prob</span>(allgameshots))</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="6-EDA.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="8-disc.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": [["thesis.pdf", "PDF"], ["thesis.epub", "EPUB"], ["thesis.docx", "Word"]],
"toc": {
"collapse": "section"
}
});
});
</script>

</body>

</html>
