# Models {#model}


```{r, init, include=FALSE}

# TODO:
  # email mike your delta conundrum
    # time to settle on a "best" model!
  # communicate posteriors in terms of probability scale (p(make|average distance, etc.)) (standardize and log troubles...)
  # put diagnostic plots in the Appendix...but not all of them!
  # don't forget a "future considerations" section in your conclusion or something
  # make a calibration plot for each game.
    # another thing that would be useful is to look at histogram of probs within a  calibration bin.
      # then you see if bins are biased
  # also look at very low-usage players!
  # use the log likelihood on the training data, for delta, not testing
    # run the model only on home games too.
    # don't use a delta smaller than like 0.75, increments of 0.05
    # if "MLE" delta is 0, then that means the data is saying there is TOO MUCH game-to-game variation for the model.

rm(list=ls())

knitr::opts_chunk$set(warning = FALSE, message=FALSE, echo=FALSE)

#library(mvtnorm); 
library(dplyr); library(ggplot2); library(R2jags); library(knitr); library(reshape2); library(png); library(grid); library(gridExtra); library(stringr)

set.seed(493)
load_chains <- TRUE
rdatafiles <- "../rdatafiles/"
load(file=paste0(rdatafiles,"Xtot.RData"))
N <- nrow(Xtot)
testrows <- sample(x=1:N, size=floor(0.2*N), replace=FALSE)
Xtrain <- Xtot[-testrows,] %>% arrange(time)
Xtest <- Xtot[testrows,] %>% arrange(time)

XH <- Xtot[Xtot$home == 1,]
NH <- nrow(XH)
testrowsH <- sample(x=1:NH, size=floor(0.2*NH), replace=FALSE)
XtrainH <- Xtot[-testrowsH,] %>% arrange(time)
XtestH <- Xtot[testrowsH,] %>% arrange(time)


id1 <- 887665 
id2 <- 842301 
id3 <- 603106 
id4 <- 601140 
playerseasons <- matrix(
  c(id1,   2016,
    id2,   2015,
    id3,   2014,
    id4,   2015
  ),ncol=2,byrow = TRUE
)
colnames(playerseasons) <- c("globalplayerid" ,"season")

#deltas <- c(0.100, 0.250, 0.375, 0.500, 0.625, 0.750, 0.850, 0.900, 0.950, 0.975, 0.999)
deltas <- c(seq(0.75, 0.95, 0.05),0.999)
deltas_str <- as.character(deltas*1000)

playermap <- data.frame(
  factorid = as.integer(as.factor(Xtot$globalplayerid)),
  globalplayerid = Xtot$globalplayerid
) %>% unique()
rownames(playermap) <- NULL

gamemap <- data.frame(
  factorid = as.integer(as.factor(Xtot$gameid)),
  gameid   = Xtot$gameid
) %>% unique()
rownames(gamemap) <- NULL

```

For our models, we consider the shot location, the shooter identity, and shooting outcomes in previous games as factors that can affect a shot outcome. In every model, we use Gibbs sampling in the JAGS library to build a logistic regression model that provides the posterior distribution of the shot location parameters (distance and angle). The model does not account for covariance between these predictors. In addition, we build mixed effects and discounted likelihood models to control for shooter identity and game identity, respectively. These models will show us how consistent the show location parameters are between between shooters and between games. In our sampling method, we set priors using the Maximum Likelihood Estimates for the first four games in the dataset, and we initialize our chains using values of 0 for all means, and 1 for all variances.

Diagnostic plots for these models can be found in Appendix 1.

<!--
```{r}
theta <- "\u03b8"
root <- "\u221a"
pi <- "\u03c0"
paramstr <- c("distance","angle",
              paste0("r = ",root,"(x^2^ + y^2^)"), paste0(theta," = arctan(x/y)"),
              "r > 0", paste0("-",pi," < \u03b8 < ",pi))

paramtab <- matrix(paramstr,ncol=3)
colnames(paramtab) <- c("Parameter","Formula","Range")
kable(paramtab)
```
-->


#### Generalized Linear Model

The results of the credible intervals are reported for the same four players, in the same order.

```{r, glm, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]
tau0r <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


fit_glm <- function(dat, S = 10000, B = 500){

  model.glm <- function(){
  
    # N observations
    for(i in 1:N){
      logit(prob[i]) <- beta_int*int[i] + 
        beta_home*home[i] +
        beta_r*logr[i] + 
        beta_theta*theta[i]
      result[i] ~ dbern(prob[i])
    }

    # Priors
    beta_int   ~ dnorm(0, 0.1)
    beta_home  ~ dnorm(0, 0.1)
    beta_r     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta ~ dnorm(mu0theta, 0.1)
  }

  datlist.glm <-  list(
    int = rep(1, nrow(dat)),
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result,
    home = dat$home,
    N = nrow(dat), 
    mu0r = mu0r,
    mu0theta = mu0theta
  )
  
  params.glm <- c("beta_int","beta_home","beta_r", "beta_theta")

  initslist <- list(list("beta_int"=0, "beta_r"=0, "beta_theta"=0, "beta_home"=0))
                    
  sim <- jags(data = datlist.glm, 
              n.chains = 1, n.iter = S, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params.glm,
              model.file=model.glm
  )
  sim.mcmc <- as.data.frame(as.mcmc(sim)[[1]])
  sim.mcmc <- sim.mcmc %>% 
    mutate(beta_intA = beta_int,
           beta_intH = beta_int + beta_home) %>%
    select(beta_intA, beta_intH, beta_r, beta_theta)
  
  return(sim.mcmc)
}

plot_params <- function(sim.mcmc = NA){
  
    coefs <- sim.mcmc %>%
      apply(2, quantile, c(0.025,0.5,0.975)) %>%
      as.data.frame() %>%
      select(beta_intA, beta_intH, beta_r, beta_theta) %>% 
      t() %>%
      as.data.frame()
    
    colnames(coefs) <- c("lo", "mid", "hi")
    
    xtext <- c("Intercept (Away)","Intercept (Home)","Distance","Angle")
    xfact <- factor(xtext, levels=xtext)

    ggplot(data = coefs, aes(x=xfact , y=mid)) + 
      geom_point() + 
      geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + 
      geom_abline(intercept=0, slope=0, linetype=2) + 
      labs(title="GLM Posterior Parameters (95% Credible Intervals)",
           x="Predictor", 
           y="Estimate") + 
      theme_bw()
}

dat1 <- Xtrain %>% filter(globalplayerid %in% playerseasons[1,1] & 
                                season %in% playerseasons[1,2])
dat2 <- Xtrain %>% filter(globalplayerid %in% playerseasons[2,1] & 
                                season %in% playerseasons[2,2])
dat3 <- Xtrain %>% filter(globalplayerid %in% playerseasons[3,1] & 
                                season %in% playerseasons[3,2])
dat4 <- Xtrain %>% filter(globalplayerid %in% playerseasons[4,1] & 
                                season %in% playerseasons[4,2])


if(!load_chains){

  glm1 <- fit_glm(dat1)
  glm2 <- fit_glm(dat2)
  glm3 <- fit_glm(dat3)
  glm4 <- fit_glm(dat4)
  glmtot <- fit_glm(Xtrain)
   
  save(glm1, file=paste0(rdatafiles,"glm1.RData"))
  save(glm2, file=paste0(rdatafiles,"glm2.RData"))
  save(glm3, file=paste0(rdatafiles,"glm3.RData"))
  save(glm4, file=paste0(rdatafiles,"glm4.RData"))
  save(glmtot, file=paste0(rdatafiles,"glmtot.RData"))
  
}else{
  
  load(file=paste0(rdatafiles,"glm1.RData"))
  load(file=paste0(rdatafiles,"glm2.RData"))
  load(file=paste0(rdatafiles,"glm3.RData"))
  load(file=paste0(rdatafiles,"glm4.RData"))
  load(file=paste0(rdatafiles,"glmtot.RData"))
  
}

plot_params(glm1)
plot_params(glm2)
plot_params(glm3)
plot_params(glm4)
plot_params(glmtot)

```

The five plots above show the posteriors of the generalized linear model parameters for the four players and seasons that we investigated in the Exploratory Data Analysis section, and the parameters for the entire team over all seasons. From these plots, we see that the effect of the angle contains zero, and it is therefore probably not predictive of a made shot. We also see that the 95% credible interval on the effect of distance is completely negative, which follows the intuitive idea that the probability of a made shot significantly decreases as distance from the basket increases. 


#### Player-by-Player Hierarchical Model
```{r, hier, cache=TRUE}
priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]
tau0r <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2

fit_players <- function(dat = NA, S = 10000, B = 500){
  
  model.player <- function(){
    # N observations
    for(i in 1:N){
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
        beta_home[player[i]]*home[i] + 
        beta_r[player[i]]*logr[i] + 
        beta_theta[player[i]]*theta[i]
      result[i] ~ dbern(prob[i])
    }
    # priors on random player effects
    for(j in 1:M){
        beta_int[j] ~ dnorm(beta_int0,tau_int)
        beta_home[j]  ~ dnorm(beta_home0, tau_int)
        beta_r[j] ~ dnorm(beta_r0,tau_r)
        beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta0 ~ dnorm(mu0theta, 0.1)

    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }

  datlist.player <- list(
                logr = log(dat$r), 
                theta = dat$theta, 
                home = dat$home,
                result = dat$result, 
                player = as.integer(as.factor(dat$globalplayerid)),
                N = nrow(dat), 
                int = rep(1, nrow(dat)), 
                M = n_distinct(dat$globalplayerid),
                mu0r = mu0r,
                mu0theta = mu0theta
                )
  params <- c("beta_int", "beta_home", "beta_r", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- datlist.player$M
  initslist <- list(
    list("beta_int"=rep(0,M), "beta_home"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
          "beta_int0"=0,"beta_home0"=0,"beta_r0"=0, "beta_theta0"=0, 
          "tau_int"=1, "tau_r"=1, "tau_theta"=1
  ))

  sim.player <- jags(data = datlist.player, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params,
              model.file=model.player
  )
  sim.mcmc.player <- as.data.frame(as.mcmc(sim.player)[[1]])
  
  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")
  sim.mcmc.player <- eval(parse(text=
    
    paste0("sim.mcmc.player %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.player <- sim.mcmc.player[ , order(colnames(sim.mcmc.player))]
  
  factorids <- str_extract_all(names(sim.mcmc.player), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.player) <- str_replace_all(names(sim.mcmc.player), "[[:digit:]]+", as.character(gameids$globalplayerid))
  
  return(sim.mcmc.player)
  
}

get_player_params <- function(sim.mcmc.hier=NA){

  quants <- c(0.025,0.50,0.975)
  #sim.mcmc.means <- colMeans(sim.mcmc.hier)
  sim.mcmc.meds <- matrix(apply(sim.mcmc.hier, 2, quantile, quants), nrow=length(quants))
  rownames(sim.mcmc.meds) <- as.character(quants*100)
  colnames(sim.mcmc.meds) <- colnames(sim.mcmc.hier)

  playermapparams <- melt(sim.mcmc.meds, id="") %>%
    mutate(globalplayerid = as.numeric(str_extract_all(Var2, "[[:digit:]]+")),
           param = as.character(str_extract_all(Var2, "(intA)|(intH)|(r)|(theta)"))) %>%
    dcast(globalplayerid ~ param + Var1)
  
  colnames(playermapparams) <- gsub("_2.5", "_lo", colnames(playermapparams)) %>%
    gsub(x=., "_50", "") %>%
    gsub(x=., "_97.5","_hi")
  
  return(playermapparams)
}

if(!load_chains){
  player.mcmc <- fit_players(dat = Xtrain)
  player.params <- get_player_params(player.mcmc)
  save(player.mcmc, file=paste0(rdatafiles,"playermcmc.RData"))
  save(player.params, file=paste0(rdatafiles,"playerparams.RData"))
}else{
  
  load(paste0(rdatafiles,"playermcmc.RData"))
  load(paste0(rdatafiles,"playerparams.RData"))
}

fourparams <- merge(playerseasons, player.params ,all=FALSE) %>% select(globalplayerid, intH, intA, r, theta) %>% arrange(-globalplayerid)

g1 <- ggplot(data = player.mcmc, aes(x=beta_intA0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intA"]], col="red") + 
  geom_label(data=fourparams, aes(x=intA, y=0, label=1:4)) +
  labs(x="Intercept (Away)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())
  
g2 <- ggplot(data = player.mcmc, aes(x=beta_intH0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intH"]], col="red") + 
  geom_label(data=fourparams, aes(x=intH, y=0, label=1:4)) +
  labs(x="Intercept (Home)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())

g3 <- ggplot(data = player.mcmc, aes(x=beta_r0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["r"]], col="red") + 
  geom_label(data=fourparams, aes(x=r, y=0, label=1:4)) +
  labs(x="Distance", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
g4 <- ggplot(data = player.mcmc, aes(x=beta_theta0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["theta"]], col="red") + 
  geom_label(data=fourparams, aes(x=theta, y=0, label=1:4)) +
  labs(x="Angle", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
mainlab <- "Posterior Densities with Four Players"
gridExtra::grid.arrange(g1, g2, g3, g4, nrow=2, top = mainlab)
```

The hierarchical model shows us that our four high-usage players of interest do not appear to be randomly spread across the population of players. The intercept plot shows that all four are in or close to the top half of values, and the radius plot shows the opposite with the four players trending towards lower parameter values. The high intercepts make intuitive sense, because the players who take a lot of shots are generally more capable of making them under baseline conditions than their teammates are. However, the observation that these players would have a more drastic drop in field goal percentage than an average Duke player as they move farther from the basket is surprising.

In the plots below, we have contour plots showing players' expected field goal percentages at different locations on the court. Between our four players of interest, we can observe how player *1* is more effective on the ____ side of the basket than the others, and how player ____ is the ___ long-range shooter.

```{r contours}

get_raneffs <- function(sim.mcmc = player.mcmc, globalplayerid=NA){
  if(globalplayerid>0){
    raneffs <- sim.mcmc %>% 
               '['(grepl(x=names(.), pattern=paste0("\\[",globalplayerid,"\\]")))
  }else{
    raneffs <- sim.mcmc %>% 
               '['(grepl(x=names(.), pattern=paste0("0")) & 
                  !grepl(x=names(.), pattern="\\["))
  }
  return(raneffs)
}

mcmc_avg <- function(sim.mcmc = player.mcmc, globalplayerid = NA, MLE=FALSE, home=TRUE){
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4
  S <- nrow(sim.mcmc) 
  BETA <- as.matrix(get_raneffs(sim.mcmc, globalplayerid))
  if(MLE){ #faster, but underestimates variance
    S <- 1
    BETA <- matrix(colMeans(BETA), nrow=1)
  }
  
  if(home){
    BETA <- BETA[,c(2,3,4)]
  }else{
    BETA <- BETA[,c(1,3,4)]

  }
  
  PROBSXY <- array(data=NA, dim=c(length(all_x),length(all_y), S))

  # Monte Carlo Average
  for(s in 1:S){
    for(i in 1:length(all_x)){
      for(j in 1:length(all_y)){
        x <- all_x[i]
        y <- all_y[j]
        r <- log(sqrt(x^2+y^2))
        t <- atan(y/x)
        if(x < 0){
          t <- t + pi
        }
        t <- t - pi/2

        eBx <- exp(-t(BETA[s,]) %*% c(1, r, t))
        #eBx <- exp(-t(colMeans(BETA)) %*% c(1, r, t))
        p <- 1/(1+eBx)
        PROBSXY[i,j,s] <- p
      }
    }
  }

  probsxy <- apply(PROBSXY, c(1,2), mean)
  return(probsxy)
}

plot_contours <- function(probsxy = NA, main=""){
  
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4

  probsxy_melt <- melt(probsxy, c("x","y"))
  probsxy_melt$x <- rep(all_x, length = nrow(probsxy_melt))
  probsxy_melt$y <- rep(all_y, each = length(all_x))
  all_xn <- seq(min(all_x), max(all_x), length=nrow(probsxy_melt))
  
  #img.path <- "/home/grad/neb20/hothand/index/figure/Basketball-Court-Dimensions2.png"
  img.path <- "./figure/ncaa_bball_court2.png"
  img <- readPNG(img.path)

a <- 0.7
contplot <- ggplot(probsxy_melt, aes(x = x, y = y, z = value)) +
  annotation_custom(rasterGrob(img,
                               x=0.50, y=0.50,
                               width = .92, height = .92),
                    -Inf, Inf, -Inf, Inf) + 
  geom_tile(aes(fill = value), alpha=a) + # the color gradient
  #stat_contour(bins = 15) + # the lines
  scale_fill_gradient2(low = rgb(1,1,1), # white
                       mid = rgb(1,1,0), # yellow 
                       high= rgb(1,0,0), # red 
                       midpoint=0.45) +
  labs(title = main, y="", x="") +
  guides(fill = guide_colorbar(title = "Probability")) + # the legend
  theme_bw() + 
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

  contplot
}

if(!load_chains){
  avg1 <- mcmc_avg(player.mcmc, id1)
  avg2 <- mcmc_avg(player.mcmc, id2)
  avg3 <- mcmc_avg(player.mcmc, id3)
  avg4 <- mcmc_avg(player.mcmc, id4)
  avgtot <- mcmc_avg(player.mcmc, 0)
  
  save(avg1, file=paste0(rdatafiles,"avg1.RData"))
  save(avg2, file=paste0(rdatafiles,"avg2.RData"))
  save(avg3, file=paste0(rdatafiles,"avg3.RData"))
  save(avg4, file=paste0(rdatafiles,"avg4.RData"))
  save(avgtot, file=paste0(rdatafiles,"avgtot.RData"))
  
}else{
  
  load(paste0(rdatafiles,"avg1.RData"))
  load(paste0(rdatafiles,"avg2.RData"))
  load(paste0(rdatafiles,"avg3.RData"))
  load(paste0(rdatafiles,"avg4.RData"))
  load(paste0(rdatafiles,"avgtot.RData"))

}

plot_contours(avg1, "Hello")
plot_contours(avg2)
plot_contours(avg3)
plot_contours(avg4)
plot_contours(avgtot, "Team Effect")

```


#### Game-by-Game Hierarchical Model
```{r hier2}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]
tau0r <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2

fit_game <- function(dat = NA, anchor = NA, discount_wt = NA, S = 10000, B = 500){

  model.game <- function(){

    for(i in 1:N){
      #g <- games[i]             # index of current game
      delta[i] <- del^abs(games[i]-g0)  # discount rate for game g relative to anchor game t
      # player-level raneffs
      
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
                        beta_home[player[i]]*home[i] + 
                        beta_r[player[i]]*logr[i] + 
                        beta_theta[player[i]]*theta[i] 
    
      p1[i] <- prob[i]^result[i]
      p2[i] <- (1-prob[i])^(1-result[i])
      p[i] <- (p1[i] * p2[i])^delta[i]  # prob = likelihood, p = discounted likelihood
      
      #result[i] ~ dbern(prob[i])
      #y[i] <- 1 # "ones trick" dummy outcomes THIS LINE CAUSES PROBLEMS
      y[i] ~ dbern(p[i]) # defines correct discounted likelihood function
    }
    
    #same priors as player model.
    # priors on random player effects
    for(j in 1:M){
      beta_int[j] ~ dnorm(beta_int0,tau_int)
      beta_home[j] ~ dnorm(beta_home0, tau_int)
      beta_r[j] ~ dnorm(beta_r0,tau_r)
      beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance   increases.  
    beta_theta0 ~ dnorm(mu0theta, 0.1)
  
    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }
  
  datlist.game <- list(
    int = rep(1, nrow(dat)), 
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result, 
    home = dat$home,
    player = as.integer(as.factor(dat$globalplayerid)),
    N = nrow(dat), 
    M = n_distinct(dat$globalplayerid),
    mu0r = mu0r,
    mu0theta = mu0theta,
    del = discount_wt,
    games = as.integer(as.factor(dat$gameid)),
    g0 = anchor,
    y = rep(1, nrow(dat)) #"phantom data"
  )

  #same params as player model (may need to change)
  params <- c("beta_int","beta_r", "beta_home", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- n_distinct(dat$globalplayerid)
  initslist <- list(list("beta_int"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
                         "beta_int0"=0,"beta_r0"=0, "beta_theta0"=0, 
                         "tau_int"=1, "tau_r"=1, "tau_theta"=1
                         ))

  sim.game <- jags(data = datlist.game, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits = initslist,
              parameters.to.save = params,
              model.file=model.game
  )
  sim.mcmc.game <- as.data.frame(as.mcmc(sim.game)[[1]])

  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")

  sim.mcmc.game <- eval(parse(text=
    
    paste0("sim.mcmc.game %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.game <- sim.mcmc.game[ , order(colnames(sim.mcmc.game))]
  
  factorids <- str_extract_all(names(sim.mcmc.game), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.game) <- str_replace_all(names(sim.mcmc.game), "[[:digit:]]+", as.character(gameids$globalplayerid))

  return(sim.mcmc.game)

}

fit_games <- function(dat = NA, discount_wt = NA, S = 10000, B = 500){
    
  G <- n_distinct(dat$gameid)
  gnames <- unique(dat$gameid)
  M <- n_distinct(dat$globalplayerid)

  game.mcmc.list <- as.list(rep(NA, G))

  for(g in 1:G){
    print(paste(discount_wt, g, sep=" : "))
    game.mcmc <- fit_game(dat, g, discount_wt, S, B)
    game.mcmc.list[[ g ]] <- game.mcmc
  }
  
  names(game.mcmc.list) <- as.character(gamemap$gameid)
  return(game.mcmc.list)
}

get_game_params <- function(sim.mcmc.list=NA, dat=NA){
  
  G <- length(sim.mcmc.list)
  M <- n_distinct(as.character(str_extract_all(names(sim.mcmc.list[[1]]), "[[:digit:]]+")))

  for(g in 1:G){
    params.game <- get_player_params(sim.mcmc.list[[g]]) %>% filter(!is.na(globalplayerid))
    if(g==1){
       params.season <- data.frame(matrix(nrow = M*G, ncol = ncol(params.game)))
       colnames(params.season) <- c(colnames(params.game))
       gameids <- gamemap %>% arrange(factorid) %>% '[['("gameid")
       params.season$gameid <- rep(gameids, each=M)
     }
     params.season[(M*(g-1) + 1):(M*g), 1:ncol(params.game)] <- params.game
  }
  
  n2 <- dat %>% group_by(gameid, globalplayerid) %>% summarize(nshots = n()) %>% as.data.frame()
  params.season <- merge(params.season, n2, all=TRUE)
  params.season$nshots[is.na(params.season$nshots)] <- 0

  return(params.season)
}

#saves the list by its elements so it will fit in github
save_gamelist <- function(GL=NA, delta_str=NA, dir = rdatafiles){

  for(g in 1:length(GL)){
    if(g < 100){
      g_str <- formatC(g, digits=2, flag="0")
    }
    print(g_str)
    game <- GL[[g]]
    save(game, file = paste0(dir,"/gamemcmc",delta_str,"_",g_str,".RData"))
    #giving them all the same workspace name will make it easier to delete them.
  }

}


#takes the elements from the rdata files and formats them into a list
load_gamelist <- function(delta_str=NA, dir = rdatafiles){
  
  # load(file=paste0(dir,"/gamemcmclist",delta_str,".RData"), envir = globalenv())
  localenv <- new.env()
  GL <- list()
  filenames <- paste0(dir,"/",list.files(path=dir, pattern=paste0("gamemcmc", delta_str))) %>% '['(order(.))
  
  for(i in 1:length(filenames)){
    load(filenames[i], envir=localenv)
    GL[[i]] <- localenv$game
    if(length(localenv$game) == 0){
      eval(parse(
        text=paste0("GL[[i]] <- localenv$game.mcmc.",delta_str,"_",formatC(i, digits=2, flag="0"))
      ))
    }

  }
  names(GL) <- as.character(gamemap$gameid)

  return(GL)
}


plot_time_effect <- function(game.params = NA, id = NA, parameter = NA, main=NA, only_fga_games = TRUE){
  
  # param_map <- list()
  # param_map[["intA"]] <- "Intercept (Away)"
  # param_map[["intH"]] <- "Intercept (Home)"
  # param_map[["r"]] <- "Distance"
  # param_map[["theta"]] <- "Angle"

  if(id != 0 & only_fga_games){
    #only consider this argument if we are looking at individual effects
    game.params <- game.params %>% filter(nshots > 0)
  }
  plotdat <- game.params %>% 
    filter(globalplayerid == id) %>% 
    select(gameid, 
           lo  = paste0(parameter,"_lo"),
           mid = paste0(parameter),
           hi  = paste0(parameter,"_hi")) %>%
    melt(id = "gameid") %>%
    select(gameid, type = variable, y = value) %>%
    arrange(gameid, type)
  
    ggplot(data = plotdat, 
         aes(x=as.integer(as.factor(gameid)), y=y, z=type, linetype=(type!="mid"))) + 
    guides(linetype=FALSE) + 
    geom_line() +   
    theme_bw() +
    labs(title=main, y="Estimate", x="Game") + 
    theme(panel.grid = element_blank())
  
}


if(!load_chains){
  
  eval(parse(
    text=paste0("game.mcmc.list.",deltas_str," <- fit_games(Xtrain,0.",deltas_str,",10000,500);\n    save_gamelist(game.mcmc.list.",deltas_str,",",deltas_str,");\n")
  ))
  
  eval(parse(
    text=paste0("game.params.",deltas_str," <- get_game_params(dat=Xtrain, game.mcmc.list.",deltas_str,");\n      save(game.params.",deltas_str,", file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))
  
}else{
  
  eval(parse(
    text=paste0("game.mcmc.list.",deltas_str," <- load_gamelist(",deltas_str,");\n")
  ))
  
  eval(parse(
    text=paste0("load(file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))


}

game.params <- game.params.500
g1 <- plot_time_effect(game.params, id=id1, parameter="intH", main="Intercept (Home) Player 1")
g2 <- plot_time_effect(game.params, id=id2, parameter="intH", main="Intercept (Home) Player 2")
g3 <- plot_time_effect(game.params, id=id3, parameter="intH", main="Intercept (Home) Player 3")
g4 <- plot_time_effect(game.params, id=id4, parameter="intH", main="Intercept (Home) Player 4")
g5 <- plot_time_effect(game.params, id=0, parameter="intH", main="Intercept (Home) Team")
gridExtra::grid.arrange(g1,g2,g3,g4, nrow=2)
g5
```




```{r preds}
# posterior mean   --> minimize sq err
# posterior median --> minimize abs err

#formats the data to return three parameters for every combination of globalplayerid and gameid

load(file=paste0(rdatafiles,"glmtot.RData"))

# MCMC Averages
Xpred <- Xtrain

# we want S predictions per shot. an N x S matrix. then we take MCMC average.
pred_glm <- function(Xpred = NA, MCMC = NA){
  
  Xmat <- Xpred %>% 
    mutate(logr = log(r),
           away = 1-home) %>%
    arrange(time) %>%
    select(away, home, logr, theta) %>% 
    as.matrix()

  # the baseline 1 intercept = "away"
  # we should only multiply by that one if home = 0
  #params.glm <- t(MCMC)
  A <- Xmat
  B <- t(MCMC)
  pred.glm <-  arm::invlogit(A %*% B) %>% apply(., 1, median) #MCMC median
  
  return(as.matrix(pred.glm))
}

pred_me <- function(Xpred = NA, MCMC = NA){

  Xmat <- Xpred %>% 
    mutate(logr = log(r),
           away = 1-home) %>%
    arrange(time) %>%
    select(away, home, logr, theta, globalplayerid) %>% 
    as.matrix()

  pred.me <- array(NA, c(nrow(Xmat), 1))
  for(r in 1:nrow(Xmat)){
    gpid <- Xmat[r,"globalplayerid"]
    Asub <- Xmat[r,1:4] # 1 x p
    Bsub <- t(MCMC[,grep(gpid, colnames(MCMC))]) # p x S
    pred.me[r,] <- median(arm::invlogit(Asub %*% Bsub)) #MCMC avg
  }

  return(pred.me)
}

pred_disc <- function(Xpred = NA, MCMC.LIST=NA){
  
  pred.disc.large <- lapply(X=MCMC.LIST, FUN=pred_me, Xpred=Xpred) %>% 
    as.data.frame() %>%
    as.matrix()
  
  rownames(pred.disc.large) <- Xpred$gameid   #N
  colnames(pred.disc.large) <- gamemap$gameid #G, from the list
  
  pred.disc <- array(NA, c(nrow(Xpred), 1))

  for(i in 1:nrow(Xpred)){
    keepcol <- colnames(pred.disc.large) == Xpred[i,"gameid"]
    pred.disc[i,] <- pred.disc.large[i, keepcol]
  }

  return(pred.disc)
  
}


eval_pred <- function(observed = NA, predicted = NA, cutoff = 0.5, nbins = 20, gameids = NA){
  
  eval.list <- list()
  
  if(is.na(gameids[1])){
    gameids <- 1
  }
  
  for(i in 1:n_distinct(gameids)){
    g <- unique(gameids)[i]
    pred <- predicted[gameids == g]
    obs <- observed[gameids == g]
    
    tab <- array(NA, c(2,2))
    rownames(tab) <- c("predicted miss", "predicted make")
    colnames(tab) <- c("observed miss", "observed make")
    pred01 <- ifelse(pred < cutoff, 0, 1)
    
    tab[1,1] <- sum(obs==0 & pred01==0)
    tab[1,2] <- sum(obs==1 & pred01==0)
    tab[2,1] <- sum(obs==0 & pred01==1)
    tab[2,2] <- sum(obs==1 & pred01==1)
    
    rate <- (tab[1,1]+tab[2,2])/length(obs)
    
    #log likelihood
    loglik <- sum(obs*log(pred) + (1-obs)*log(1-pred))
    
    MSE <- mean((obs - pred)^2)
    
    if(n_distinct(pred) < nbins){
      calib <- NA
    }else{
      
      predquants <- c(0, quantile(pred, (1:nbins)/nbins))
      predmidpts <- ((predquants + c(0,predquants[-length(predquants)]))/2) %>% '['(-1)
    
      pred1N <- sapply(pred, findInterval, vec=predquants, all.inside=TRUE, rightmost.closed=TRUE, left.open=TRUE)
  
      calibtab <- table(pred1N, obs)
      rownames(calibtab) <- predmidpts
      calib <- calibtab %>% 
        as.data.frame() %>%
        dcast(pred1N ~ obs, value.var = "Freq") %>%
        mutate(p  = `1`/(`0`+`1`),
               pl = p - 2*sqrt(p*(1-p)/(`0` + `1`)),
               pu = p + 2*sqrt(p*(1-p)/(`0` + `1`)),
               binl = predquants[-(nrow(.)+1)],
               binu = predquants[-1])
      colnames(calib) <- c("bin", "obs0", "obs1", "p", "pl", "pu", "binl", "binu")

    }
    eval.list[[i]] <-  list(
      confusionmat = tab, 
      classificationrate = rate, 
      loglik = loglik,
      mse = MSE,
      calibrationdat = calib)
  }
    return(eval.list)
}

plot_calibration <- function(dat, title="Calibration Plot"){
  ggplot(data = dat, aes(x=as.numeric(as.character(bin)), y=p, group=0)) + 
    geom_errorbar(aes(ymin=pl, ymax=pu), width=0) + 
    geom_errorbarh(aes(xmin=binl, xmax=binu), height=0) + 
    geom_abline(slope=1, color="red") +
    coord_cartesian(xlim=c(0,1), ylim=c(0,1)) + 
    theme(panel.grid = element_blank()
          #,panel.border = element_blank(), axis.text = element_blank(), axis.ticks =   element_blank()
          ) + 
    theme_bw() + 
    labs(x="bin", title=title)
}


Xmine <- data.frame(
  result = rep(c(0,1),each=5),
  home   = 1,
  r      = 10,
  theta  = 0,
  globalplayerid = c(937663,937674,937647,937669,937650),
  gameid = c(201501170314,201501190173),
  time = 1:10
)

eval(parse(
   text=paste0("mine.game.", deltas_str," <- pred_disc(Xmine, game.mcmc.list.", deltas_str, ");\n eval.mine.",deltas_str," <- eval_pred(Xmine$result, mine.game.",deltas_str,");\n print(",deltas_str,");\n")
))
eval(parse(
  text=paste0("c(",paste0("eval.mine.",deltas_str,"[[1]]$loglik", collapse = ", "),")")
))



if(!load_chains){
  
  pred.team     <- pred_glm(Xtest, glmtot)
  pred.player   <- pred_me(Xtest, player.mcmc)
  eval(parse(
    text=paste0("pred.game.",deltas_str," <- pred_disc(Xtest, game.mcmc.list.", deltas_str, ");\n")
  ))
  pred.0        <- rep(0, nrow(Xtest))
  pred.1        <- rep(1, nrow(Xtest))

  savepreds <- ls() %>% grep(pattern="pred.",fixed=TRUE,value=TRUE)
  temp <- lapply(as.list(savepreds), function(x){
    save(list=x, 
         file=paste0(rdatafiles,gsub(patt=".",rep="",x=x,fixed=TRUE),".RData"))
    })
  
  fitted.team     <- pred_glm(Xtrain, glmtot)
  fitted.player   <- pred_me(Xtrain, player.mcmc)
  eval(parse(
    text=paste0("fitted.game.", deltas_str," <- pred_disc(Xtrain, game.mcmc.list.", deltas_str, ");\n")
  ))
  fitted.0        <- rep(0, nrow(Xtrain))
  fitted.1        <- rep(1, nrow(Xtrain))
  
  savefitteds <- ls() %>% grep(pattern="fitted.",fixed=TRUE,value=TRUE)
  temp <- lapply(as.list(savefitteds), function(x){
    save(list=x, 
         file=paste0(rdatafiles,gsub(patt=".",rep="",x=x,fixed=TRUE),".RData"))
  })
  

}else{
  
  loadpreds <- list.files(rdatafiles, pattern="pred")
  temp <- lapply(as.list(loadpreds), function(x){
    load(file=paste0(rdatafiles,x), envir = globalenv())
  })
  
  loadfitteds <- list.files(rdatafiles, pattern="fitted")
  temp <- lapply(as.list(loadfitteds), function(x){
    load(file=paste0(rdatafiles,x), envir = globalenv())
  })

  
}

eval.team.p   <- eval_pred(Xtest$result, pred.team)
eval.player.p <- eval_pred(Xtest$result, pred.player)
eval(parse(
  text=paste0("eval.",deltas_str,".p <- eval_pred(Xtest$result, pred.game.", deltas_str, ");\n")
  ))

eval.team.f   <- eval_pred(Xtrain$result, fitted.team)
eval.player.f <- eval_pred(Xtrain$result, fitted.player)
eval(parse(
  text=paste0("eval.",deltas_str,".f <- eval_pred(Xtrain$result, fitted.game.", deltas_str, ");\n")
  ))

```


```{r model-eval}

logliks_delta <- eval(parse(
  text=paste0("c(",paste0("eval.",deltas_str,".f[[1]]$loglik", collapse = ", "),")")
))

classrates_delta <- eval(parse(
  text=paste0("c(",paste0("eval.",deltas_str,".p[[1]]$classificationrate", collapse = ", "),")")
))

mses_delta <- eval(parse(
  text=paste0("c(",paste0("eval.",deltas_str,".p[[1]]$mse", collapse = ", "),")")
))

classrates <- c(eval.team.p[[1]]$classificationrate, eval.player.p[[1]]$classificationrate)

logliks <- c(eval.team.f[[1]]$loglik, eval.player.f[[1]]$loglik)

mses <- c(eval.team.p[[1]]$mse, eval.player.p[[1]]$mse)

df_delta <- data.frame(d = deltas, classrates_delta, logliks_delta, mses_delta)
df <- data.frame(type=c("Team Effect", "Mixed Effects"), classrates, logliks, mses)

g1 <- ggplot(data=df_delta, aes(x=d,y=classrates_delta)) +
  geom_point() + 
  geom_hline(data=df, aes(yintercept=classrates, linetype=type))

g2 <- ggplot(data=df_delta, aes(x=d,y=logliks_delta)) +
  geom_point() + 
  geom_hline(data=df, aes(yintercept=logliks, linetype=type))

g3 <- ggplot(data=df_delta, aes(x=d,y=mses_delta)) +
  geom_point() + 
  geom_hline(data=df, aes(yintercept=mses, linetype=type))

gridExtra::grid.arrange(g1, g2, g3, nrow=2)

```

From these plots, we can observe that all of the models have different strengths. The simple model that does not account for player effects or game-by-game variation has the highest classification rate (with a 0.50 probability cutoff) and the smallest Mean Squared Error. However, the model with player effects and discounted likelihood based on game index has the highest likelihood. Upon investigating why the smallest delta has the best likelihood, but the worst classification rate and MSE, we noticed that as delta decreases, the distribution of the fitted values becomes smoother. *insert graph* This explains how ___.



```{r onestest, eval=FALSE}
model.ones <- function(){
  for(i in 1:N) {
    
    likelihood[i] <- (theta^(1-outcome[i]))/(1-theta)
    #likelihood[i] <- (theta^outcome[i]) * (1-theta)^(1-outcome[i])
    probability[i] <- likelihood[i] / constant
    outcome.ones[i] ~ dbern(probability[i])
  }
  #prior for theta
  theta ~ dunif(0,2)

  
}

constant = 1
N = 100
outcome.ones <- rep(1,N)
outcome = rbinom(n=N,size=1,prob=1/2)
#likelihood = runif(n=N)

sim.ones <- jags(data = c("constant","N","outcome", "outcome.ones"), 
            n.iter = 1000, n.chains = 1, n.burnin = 500, n.thin = 1,
            parameters.to.save = "theta",
            model.file=model.ones
)
sim.mcmc.ones <- as.data.frame(as.mcmc(sim.ones)[[1]])

```     

