# Models & Analysis {#models}

## Description of Models

For our models, we consider the shot location, a home court indicator, the shooter's identity, and his shooting outcomes in nearby games as factors that can affect a shot's outcome. We use the Just Another Gibbs Sampler library in R (`R2jags`) to build these models. Each one is based on a logistic regression model that provides the posterior distribution of the shot location parameters (distance and angle) and an additional intercept to capture the influence of home-court advantage. The models do not account for covariance between these predictors. We expand upon this model by adding mixed effects and discounted likelihood models to control for shooter identity and between-game variability, respectively. In our Gibbs Samplers, we  estimate the posterior distributions using 10,000 simulations and a burn-in of 500. Our prior distributions are constructed from the corresponding maximum likelihood estimates for the first four games in the dataset, and we initialize our Monte Carlo Markov Chains using values of 0 for all means, and 1 for all variances. The `R2jags` code used to build these models can be found in Appendix A.


### Generalized Linear Model

We start with a logistic regression model for each shot attempt $i$:

$$
\text{logit}(p_{i}) = 
\beta_{\text{int}} +
x_{\text{r,i}}\beta_{\text{r}} +
x_{\theta,\text{i}}\beta_{\theta} +
x_{\text{H,i}}\beta_{\text{H}}.
$$

In this model, the $x$ refers to the data, and the $\beta$s are the parameters from the model. The subscripts $\textit{int}$, $\textit{r}$, $\theta$, and $\textit{H}$ respectively refer to the intercept, the log-distance of the shot, the angle of the shot, and whether shot was taken on Duke's home court or another gym. This fourth $\beta$ accounts for the possibility of "home-court advantage", which can affect shot outcomes.

### Hierarchical Generalized Linear Model

Our second model is a hierarchical model, with random effects on the $\textit{j}$ players in the dataset. These random effects occur for each of the four parameters of interest---the intercept, the distance effect, the angle effect, and the home effect. Each individual player's parameter values are sampled from a Normal distribution centered at the population values. A benefit of this type of model is that the parameters for players with few shot attempts are shrunk towards the population means. The model has the form below for each player $j$ and shot attempt $i$:


$$
\text{logit}(p_{\text{ji}}) = 
\beta_{\text{int, j}} +
x_{\text{r,ji}}\beta_{\text{r, j}} +
x_{\theta,\text{ji}}\beta_{\theta, \text{j}} +
x_{\text{H, ji}}\beta_{\text{H, j}},
$$
$$
\beta_{\text{int, j}} \sim N(\beta_{\text{int}}, \tau^2_{\text{int}}),
$$
$$
\beta_{\text{r, j}} \sim N(\beta_{\text{r}}, \tau^2_{\text{r}}),
$$
$$
\beta_{\theta, j} \sim N(\beta_{\theta}, \tau^2_{\theta}),
$$
$$
\beta_{\text{H, j}} \sim N(\beta_{\text{H}}, \tau^2_{\text{H}}).
$$


### Discounted Likelihood Hierarchical Model

In the discounted likelihood models, the likelihood function for all model parameters at a given time is more heavily influenced by the observations close to that specific time point than the observations far away from it. We measure the "distance" between observations by the number of games between them; a shot attempt that occurs in the next or the preceding game will influence the likelihood function for the parameters "anchored" at that game more than a shot that occurs two games away. <!--BEGIN MIKE WEST EDITS!!! --> We chose to analyze time-dependency in the data using a discounted likelihood model instead of a full dynamic model because a discounted likelihood model would have fewer complications in the context of a hierarchical model. <!--(**what are my citations for this claim?**)--> The methodology behind our discounted likelihood model relates closely to Bayesian dynamic modeling that uses power discounting to reduce the effect of data that occurs further in the past. We begin defining this model with the concept of forward filtering. This is implied by a power-discount Bayesian time series model (Smith, 1979) that uses a "discounted" Bayes Theorem in which the posterior disitribution of the model parameters at any chosen time $t$ is proportional to the product of the prior, $p(\Theta)$, and the discount likelihood function, which has the form

```{r, fig.height=0.5}
ggblank
```

\pagebreak

$$
p_t(X_{1:t}|\Theta) = p_t(X_{1:t-1}|\Theta)p(X_t|\Theta),
$$

where

$$
p_t(X_{1:t-1}|\Theta) \propto
p(X_{1}  |\Theta)^{\delta^{t-1}}...
p(X_{t-2}|\Theta)^{\delta^{2}}
p(X_{t-1}|\Theta)^{\delta}
$$

for some discount factor $0 < \delta < 1$, typically closer to 1 to allow for the discounting of past data without omitting its information content.

This equation shows that as distance increases backward in time, the effect on the likelihood function---and hence on the resulting posterior for $\Theta$ at our current time $t$---decreases. The corresponding discount likelihood for $\Theta$ at time $t$ given both past and future data up to a time $T > t$ has a similar form, but with two-sided discounting. This relates to dynamic models with time-varying parameters, which apply backwards updating to update their posteriors. The form of the two-sided likelihood function of $\Theta$ at a chosen time $t$ is:

$$
p_t(X_{1:T}|\Theta) = 
p_t(X_{1:t-1}|\Theta)
p(X_{t}|\Theta)
p_t(X_{t+1:T}|\Theta),
$$

where the past data component $p_t(X_{1:t-1}|\Theta)$ is the same as above, and the future data component is:

$$
p_t(X_{t+1:T}|\Theta) \propto
p(X_{t+1}|\Theta)^{\delta}
p(X_{t+2}|\Theta)^{\delta^2}...
p(X_{T}|\Theta)^{\delta^{T-t}}.
$$

Specifically for our model, given an observed shot $\textit{i}$ in game $g$, attempted by player $\textit{j}$, we apply the above reasoning to discount the likelihood of a made shot in the hierarchical model. First we begin with a hierarchical logistic regression model:

$$
\text{logit}(p_{\text{gji}}) = 
\beta_{\text{int, gj}} +
x_{\text{r,gji}}\beta_{\text{r, gj}} +
x_{\theta,\text{gji}}\beta_{\theta, \text{gj}} +
x_{\text{H, gji}}\beta_{\text{H, gj}},
$$
$$
\beta_{\text{int, j}} \sim N(\beta_{\text{int}}, \tau^2_{\text{int}}),
$$
$$
\beta_{\text{r, j}} \sim N(\beta_{\text{r}}, \tau^2_{\text{r}}),
$$
$$
\beta_{\theta, j} \sim N(\beta_{\theta}, \tau^2_{\theta}),
$$
$$
\beta_{\text{H, j}} \sim N(\beta_{\text{H}}, \tau^2_{\text{H}}).
$$

Without discounting, the likelihood term controbuted from a shot's outcome, $\text{y}_\text{gji}$, that is attempted by player $\textit{j}$ in game $\textit{g}$, is:

$$
L_\text{gj}(\Theta) =
\prod_{\text{i}=1}^{\text{n}_\text{gj}}{
  p(\text{y}_{\text{gji}} | \Theta) 
}
\propto 
\prod_{\text{i}=1}^{\text{n}_\text{gj}}{
  p_\text{gji}^{\text{y}_\text{gji}} 
  (1 - p_\text{gji})^{1-\text{y}_\text{gji}}
}.
$$

When we apply the exponential discounting to the outcomes like so:

$$
\pi_{\text{gji}} =
\left(
  p_\text{gji}^{\text{y}_\text{gji}} 
  (1 - p_\text{gji})^{1-\text{y}_\text{gji}}
\right)
^{\delta^{|g-g_0|}},
$$

our likelihood becomes:

$$
\Lambda_{\text{gj}}(\Theta) = 
\prod_{\text{i}=1}^{\text{n}_\text{gj}}
  \pi_{\text{gji}},
$$

where ${g}$ is the game index of the current shot $\textit{i}$, and $g_0$ is a fixed game index, which we refer to as the "anchor game". 


In this model, $p$ represents the binomial probability, and $\pi$ is the discounted probability. Both of these quantities are probabilities that are bounded in the interval [0,1]. Similarly, $L$ is the likelihood and $\Lambda$ is the discounted likelihood. <!-- The contribution of shot outcomes (in the anchor game $g_0$) to the likelihood of the current shot outcome (in game $g$) decreases as the distance between the observations increases, and as $\delta$ decreases.--> The contribution of shot outcomes from games $g$ that are more distant from the anchor game $g_0$ are more heavily discounted, and the discounting increases for smaller values of $\delta$. In a model with $\delta$ = 0, only shots taken in the same game as shot $i$ can contribute to the likelihood, while $\delta$ = 1 is equivalent to a model with no discounting. If models with larger values of $\delta$ best fit the data, this suggests that shooting success is consistent throughout a career. If smaller values of $\delta$ are more likely in the data, however, then we can assume there is a substantial amount of time variation, or "streakiness", in the data on the game level. <!-- This model specification results in an MCMC chain for each combination of $g_0$ and $\delta$--> Figure \@ref(fig:discplot) illustrates how the exponential weight on the likelihood depends on the selected value of $\delta$ and the distance from the anchor game ($g - g_0$).

```{r, fig.height=3}
ggblank
```

\pagebreak

```{r discplot, fig.height=5, fig.cap = "Illustration of Discounted Weighting"}
t <- as.matrix(seq(-10, 10))
#D <- as.matrix(seq(0.1, 1, by=0.1))
D <- as.matrix(c(seq(0.75, 0.95, 0.05),0.999))
weights <- as.data.frame(apply(D, 1, '^', abs(t)))
colnames(weights) <- D
weights$t <- t
weightslong <- melt(weights, id="t") %>% 
  rename(D=variable,
         y=value)

discplot <- ggplot(weightslong, aes(x=t, y=y, color=D)) + 
  geom_line(size=1.25) + 
  labs(color = expression(delta) ,
       y = expression(delta[i]^abs(g - g[0])),
       x = expression(g - g[0])) +
  theme_bw() +
  theme(legend.title = element_text(size=10,face="bold"),
        axis.title.y = element_text(angle = 0, vjust=0.5)) +
  scale_y_continuous(minor_breaks = seq(0, 1, .25)) +
  scale_x_continuous(minor_breaks = seq(-10, 10, 5))
  
discplot
```


This model specification is specific to the chosen anchor game $g_0$, so that the resulting posterior distribution for all model parameters is indexed by $g_0$ and represents inferences "local" to that game. Repeating the analysis across all games as anchors results in a sequence of posteriors, where their differences reflect time variation. As a result, we refit the model using MCMC for each combination of game index and $\delta$, which involves substantial computation.

```{r, fig.height=1}
ggblank
```

\pagebreak

To build these discounted likelihood models in the `R2jags` library, we apply the "ones trick". This technique allows us to use a sampling distribution that does not exist in the library by modifying a common distribution---in this case, the Binomial. The probability $p$ is estimated in the same way as the Bayesian hierarchical model. We discount this probability to estimate $\pi$, and then we specify that it comes from Binomial data that consists only of ones; this is equivalent to sampling from a distribution with discounted outcomes. In the code excerpt below, `result` and `prob` are the binomial outcomes and probabilities, while `y` represents the "trick" outcomes (a vector of 1s), and `pi` is the discounted probability. 

```{r, fig.height=0.5}
ggblank
```

```{r eval=FALSE, echo=TRUE}
    for(i in 1:N){
      
      # delta = discount rate for game g relative to anchor game g0
      wt[i] <- delta^abs(games[i]-g0)  
      
      # player-level random effects
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
                        beta_home[player[i]]*home[i] + 
                        beta_r[player[i]]*logr[i] + 
                        beta_theta[player[i]]*theta[i] 

      # likelihood function
      p1[i] <- prob[i]^result[i]
      p2[i] <- (1-prob[i])^(1-result[i])
      
      # discounted likelihood function
      pi[i] <- (p1[i] * p2[i])^wt[i]  
      
      # defines correct discounted likelihood function
      y[i] ~ dbern(pi[i]) 
      
    }
    
    # Priors
    for(j in 1:M){
      beta_int[j] ~ dnorm(beta_int0,tau_int)
      beta_home[j] ~ dnorm(beta_home0, tau_int)
      beta_r[j] ~ dnorm(beta_r0,tau_r)
      beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
```

See Appendix A.3 for the full `R` code. 

 
## Analysis

```{r init, include=FALSE}

# srv <- ""
# k0 <- as.numeric(strsplit(srv, "")[[1]][1])
# ltr <- strsplit(srv, "")[[1]][2]
# fldr <- strsplit(srv, "")[[1]][3]
# if(ltr == "A"){
#   deltas <- c(0.750, 0.800, 0.850)
# }else if(ltr == "B"){
#   deltas <- c(0.900, 0.950, 0.999)
# }
# if(fldr == "H"){
#   home_only <- TRUE
#   season_2015 <- FALSE
# }else if(fldr == "2"){
#   home_only <- FALSE
#   season_2015 <- TRUE
# }

# TODO:
  # put some raw means and stuff  and shot distributions nad home/away splits on EDA section. simple things
  # put diagnostic plots in the Appendix...but not all of them!

set.seed(49301)

k <- 5 #k-fold cross-validation
k0 <- 1
load_chains <- TRUE
season_2015 <- FALSE
home_only <- FALSE

deltas <- c(seq(0.75, 0.95, 0.05),0.999)
deltas_str <- as.character(deltas*1000)

get_rdatafiles <- function(k=NA, home_only=FALSE, season_2015=FALSE){

  base <- "../rdatafiles/"
  
  if(home_only){
    base <- "../rdatafilesH/"
  }
  
  if(season_2015){
    base <- "../rdatafiles2015/"
  }
  
  load(file=paste0(base, "Xtot.RData"), envir= globalenv())
  
  if(k<1){
    return(base)
  }else{
    return(paste0(base,"k",k,"/"))
  }
}


rdatafiles <- get_rdatafiles(k0, home_only = home_only, season_2015 = season_2015)

N <- nrow(Xtot)
kgroups <- rmultinom(n=N, size=1, prob = rep(1/k,k)) %>% '=='(1) %>% apply(2,which)
testrows <- which(kgroups == k0)
Xtrain <- Xtot[-testrows,] %>% arrange(time)
Xtest <- Xtot[testrows,] %>% arrange(time)

playermap <- data.frame(
  factorid = as.integer(as.factor(Xtot$globalplayerid)),
  globalplayerid = Xtot$globalplayerid
) %>% unique()
rownames(playermap) <- NULL

gamemap <- data.frame(
  factorid = as.integer(as.factor(Xtot$gameid)),
  gameid   = Xtot$gameid
) %>% unique()
rownames(gamemap) <- NULL

```


### Generalized Linear Model

In our generalized linear model, we only look at shot location and the home court indicator as predictors of shot outcome. This is a logistic regression model where the intercepts correspond to the log-odds of making a shot when the angle is zero (the middle of the court) and the log-distance is zero (one foot away from the rim). To illustrate these effects for individual players, we simply subset the dataset to include only shots attempted by that player before running the Gibbs Sampler. In Figure \@ref(fig:glmplot), The 95% credible intervals of the posterior parameters are reported for the same four players that were introduced in Figure \@ref(fig:smoothplot).  

```{r, fig.height=0.5}
ggblank
```

```{r glmfxns, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


fit_glm <- function(dat, S = 10000, B = 500){

  model.glm <- function(){
  
    # N observations
    for(i in 1:N){
      logit(prob[i]) <- beta_int*int[i] + 
        beta_home*home[i] +
        beta_r*logr[i] + 
        beta_theta*theta[i]
      result[i] ~ dbern(prob[i])
    }

    # Priors
    beta_int   ~ dnorm(0, 0.1)
    beta_home  ~ dnorm(0, 0.1)
    beta_r     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta ~ dnorm(mu0theta, 0.1)
  }

  datlist.glm <-  list(
    int = rep(1, nrow(dat)),
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result,
    home = dat$home,
    N = nrow(dat), 
    mu0r = mu0r,
    mu0theta = mu0theta
  )
  
  params.glm <- c("beta_int","beta_home","beta_r", "beta_theta")

  initslist <- list(list("beta_int"=0, "beta_r"=0, "beta_theta"=0, "beta_home"=0))
                    
  sim <- jags(data = datlist.glm, 
              n.chains = 1, n.iter = S, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params.glm,
              model.file=model.glm
  )
  sim.mcmc <- as.data.frame(as.mcmc(sim)[[1]])
  sim.mcmc <- sim.mcmc %>% 
    mutate(beta_intA = beta_int,
           beta_intH = beta_int + beta_home) %>%
    select(beta_intA, beta_intH, beta_r, beta_theta)
  
  return(sim.mcmc)
}

plot_params <- function(sim.mcmc = NA, main=""){
  
    coefs <- sim.mcmc %>%
      apply(2, quantile, c(0.025,0.5,0.975)) %>%
      as.data.frame() %>%
      mutate(beta_theta = -beta_theta) %>% 
      select(beta_intA, beta_intH, beta_r, beta_theta) %>% 
      t() %>%
      as.data.frame()
    
    colnames(coefs) <- c("lo", "mid", "hi")
    
    xtext <- c("Intercept\n(Away)","Intercept\n(Home)","Distance","Angle")
    xfact <- factor(xtext, levels=xtext)

    ggplot(data = coefs, aes(x=xfact , y=mid)) + 
      geom_point() + 
      geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + 
      geom_abline(intercept=0, slope=0, linetype=2) + 
      labs(title=main,
           x="Predictor", 
           y="Estimate") + 
      theme_bw()
}

dat1 <- Xtrain %>% filter(globalplayerid %in% playerseasons[1,1] & 
                                season %in% playerseasons[1,2])
dat2 <- Xtrain %>% filter(globalplayerid %in% playerseasons[2,1] & 
                                season %in% playerseasons[2,2])
dat3 <- Xtrain %>% filter(globalplayerid %in% playerseasons[3,1] & 
                                season %in% playerseasons[3,2])
dat4 <- Xtrain %>% filter(globalplayerid %in% playerseasons[4,1] & 
                                season %in% playerseasons[4,2])


if(!load_chains){

  glmtot <- fit_glm(Xtrain)

  if(nrow(dat1) > 0) glm1 <- fit_glm(dat1) else glm1 <- glmtot
  if(nrow(dat2) > 0) glm2 <- fit_glm(dat2) else glm2 <- glmtot
  if(nrow(dat3) > 0) glm3 <- fit_glm(dat3) else glm3 <- glmtot
  if(nrow(dat4) > 0) glm4 <- fit_glm(dat4) else glm4 <- glmtot
  
  save(glm1, file=paste0(rdatafiles,"glm1.RData"))
  save(glm2, file=paste0(rdatafiles,"glm2.RData"))
  save(glm3, file=paste0(rdatafiles,"glm3.RData"))
  save(glm4, file=paste0(rdatafiles,"glm4.RData"))
  save(glmtot, file=paste0(rdatafiles,"glmtot.RData"))
  
}else{
  
  load(file=paste0(rdatafiles,"glm1.RData"))
  load(file=paste0(rdatafiles,"glm2.RData"))
  load(file=paste0(rdatafiles,"glm3.RData"))
  load(file=paste0(rdatafiles,"glm4.RData"))
  load(file=paste0(rdatafiles,"glmtot.RData"))
  
}

glmplot1 <- plot_params(glm1, "Player 1")
glmplot2 <- plot_params(glm2, "Player 2")
glmplot3 <- plot_params(glm3, "Player 3")
glmplot4 <- plot_params(glm4, "Player 4")
glmplot5 <- plot_params(glmtot, "Team Effects")

```

```{r glmplot0, fig.align="center"}
grid.arrange(glmplot1,glmplot2,glmplot3,glmplot4, nrow=2)
```

```{r glmplot, fig.cap = "GLM Posterior Distributions for Four Players", fig.height=3, fig.width=5, fig.align="center", cache=TRUE}
glmplot5
```

From these plots, we see that the team-wide 95% credible interval of the angle effect is centered at zero, and it is therefore probably not predictive of a made shot. The average distance effect shows us that the log-odds of a made shot decrease by $\beta_r =$ `r x <- median(glmtot[["beta_r"]]); abs(round(x,4))` as the log-distance increases by one unit and the other predictors remain constant. This effect is translated to the probability scale using the expression

$$
\frac{\text{e}^{\beta_r}}{1 + \text{e}^{\beta_r}},
$$

which equals `r round(exp(x)/(1+exp(x)), 4)`.

We also see that the 95% credible interval on the effect of distance is completely negative, which follows the intuitive idea that the probability of a made shot significantly decreases as distance from the basket increases. The intercepts show us that there is not a substantial difference in baseline shooting performance between home games and away games. The interval for away games is wider because there are fewer of them in the dataset.

### Hierarchical Generalized Linear Model

To make the hierarchical model, we add random effects that allow the parameters to vary for each player in the dataset. For every linear covariate in the model, we model player-specific effects as sampled from a Normal distribution roughly centered at the covariate's population mean. We present the results in Figure \@ref(fig:hierplot) by comparing the effects of the four high-usage players of interest to the population density of each covariate. 

\pagebreak

```{r hierfxns, cache=TRUE}
priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2

fit_players <- function(dat = NA, S = 10000, B = 500){
  
  model.player <- function(){
    # N observations
    for(i in 1:N){
      
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
        beta_home[player[i]]*home[i] + 
        beta_r[player[i]]*logr[i] + 
        beta_theta[player[i]]*theta[i]
      
      result[i] ~ dbern(prob[i])
    }
    # priors on random player effects
    for(j in 1:M){
        beta_int[j] ~ dnorm(beta_int0,tau_int)
        beta_home[j]  ~ dnorm(beta_home0, tau_int)
        beta_r[j] ~ dnorm(beta_r0,tau_r)
        beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Hyperpriors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta0 ~ dnorm(mu0theta, 0.1)

    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }

  datlist.player <- list(
                logr = log(dat$r), 
                theta = dat$theta, 
                home = dat$home,
                result = dat$result, 
                player = as.integer(as.factor(dat$globalplayerid)),
                N = nrow(dat), 
                int = rep(1, nrow(dat)), 
                M = n_distinct(dat$globalplayerid),
                mu0r = mu0r,
                mu0theta = mu0theta
                )
  params <- c("beta_int", "beta_home", "beta_r", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- datlist.player$M
  initslist <- list(
    list("beta_int"=rep(0,M), "beta_home"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
          "beta_int0"=0,"beta_home0"=0,"beta_r0"=0, "beta_theta0"=0, 
          "tau_int"=1, "tau_r"=1, "tau_theta"=1
  ))

  sim.player <- jags(data = datlist.player, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params,
              model.file=model.player
  )
  sim.mcmc.player <- as.data.frame(as.mcmc(sim.player)[[1]])
  
  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")
  sim.mcmc.player <- eval(parse(text=
    
    paste0("sim.mcmc.player %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.player <- sim.mcmc.player[ , order(colnames(sim.mcmc.player))]
  
  factorids <- str_extract_all(names(sim.mcmc.player), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.player) <- str_replace_all(names(sim.mcmc.player), "[[:digit:]]+", as.character(gameids$globalplayerid))
  -
  return(sim.mcmc.player)
  
}

get_player_params <- function(sim.mcmc.hier=NA){

  quants <- c(0.025,0.50,0.975)
  #sim.mcmc.means <- colMeans(sim.mcmc.hier)
  sim.mcmc.meds <- matrix(apply(sim.mcmc.hier, 2, quantile, quants), nrow=length(quants))
  rownames(sim.mcmc.meds) <- as.character(quants*100)
  colnames(sim.mcmc.meds) <- colnames(sim.mcmc.hier)

  playermapparams <- melt(sim.mcmc.meds, id="") %>%
    mutate(globalplayerid = as.numeric(str_extract_all(Var2, "[[:digit:]]+")),
           param = as.character(str_extract_all(Var2, "(intA)|(intH)|(r)|(theta)"))) %>%
    dcast(globalplayerid ~ param + Var1)
  
  colnames(playermapparams) <- gsub("_2.5", "_lo", colnames(playermapparams)) %>%
    gsub(x=., "_50", "") %>%
    gsub(x=., "_97.5","_hi")
  
  #because of an error in the definition of angle, theta actually = -theta
  playermapparams <- 
    playermapparams %>% mutate(theta = -theta,
                             theta_hi_save = theta_hi,
                             theta_hi = -theta_lo,
                             theta_lo = -theta_hi_save,
                             theta_hi_save = NULL)
  
  return(playermapparams)
}

if(!load_chains){
  
  player.mcmc <- fit_players(dat = Xtrain)
  player.params <- get_player_params(player.mcmc)
  
  save(player.mcmc, file=paste0(rdatafiles,"playermcmc.RData"))
  save(player.params, file=paste0(rdatafiles,"playerparams.RData"))

}else{
  
  load(paste0(rdatafiles,"playermcmc.RData"))
  load(paste0(rdatafiles,"playerparams.RData"))
}

fourparams <- merge(playerseasons, player.params ,all=FALSE) %>% select(globalplayerid, intH, intA, r, theta) %>% arrange(-globalplayerid)

```

```{r hierplot, fig.cap = "Population Distribution with Four Player Effects"}

meplotA <- ggplot(data = player.mcmc, aes(x=beta_intA0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intA"]], col="red") + 
  geom_label(data=fourparams, aes(x=intA, y=0, label=1:4)) +
  labs(x="Intercept (Away)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())
  
meplotH <- ggplot(data = player.mcmc, aes(x=beta_intH0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intH"]], col="red") + 
  geom_label(data=fourparams, aes(x=intH, y=0, label=1:4)) +
  labs(x="Intercept (Home)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())

meplotr <- ggplot(data = player.mcmc, aes(x=beta_r0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["r"]], col="red") + 
  geom_label(data=fourparams, aes(x=r, y=0, label=1:4)) +
  labs(x="Distance", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
meplottheta <- ggplot(data = player.mcmc, aes(x= -beta_theta0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["theta"]], col="red") + 
  geom_label(data=fourparams, aes(x= theta, y=0, label=1:4)) +
  labs(x="Angle", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
grid.arrange(meplotA, meplotH, meplotr, meplottheta, nrow=2)
```


The plots in Figure \@ref(fig:hierplot) show us that Player 2 excels at scoring under baseline conditions (close to the basket), but he has a steeper-than-average drop in his odds of scoring as his distance from the basket increases. We can also see that Player 1 strongly increases his odds of scoring when his angle is negative, which corresponds to the left side of the basket, while the other three players' effects are all close to zero.

In Figure \@ref(fig:contplot), we present contour plots showing the players' expected field goal percentages at all locations on the half of the court where they are shooting. We compute these from the fitted probabilities of shot success from the hierarchical model. This plot confirms that Player 1 is more effective on the left side of the basket than the others. Other takeaways that were not noticeable in Figure \@ref(fig:hierplot) are that Player 2 has the darkest overall contour plot, which suggests that he has the highest overall probability of scoring, and that Player 4 has lightest plot, suggesting he is the least reliable scorer among these four players.

```{r contfxns, cache=TRUE}

get_raneffs <- function(sim.mcmc = player.mcmc, globalplayerid=NA){
  
  id_inds <- which(grepl(x=names(sim.mcmc), pattern=paste0("\\[",globalplayerid,"\\]")))
  
  #if you can't find the player effects for the input id, use the team effects
  if(length(id_inds) > 0){
    raneffs <- sim.mcmc[,id_inds]
  }else{
    raneffs <- sim.mcmc %>% 
               '['(grepl(x=names(.), pattern=paste0("0")) & 
                  !grepl(x=names(.), pattern="\\["))
  }
  return(raneffs)
}

mcmc_avg <- function(sim.mcmc = player.mcmc, globalplayerid = NA, MLE=FALSE,home=TRUE){
  
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4
  
  S <- nrow(sim.mcmc) 
  BETA <- as.matrix(get_raneffs(sim.mcmc, globalplayerid))
  if(MLE){ #faster, but underestimates variance
    S <- 1
    BETA <- matrix(colMeans(BETA), nrow=1)
  }
  
  if(home){
    BETA <- matrix(BETA[,c(2,3,4)], nrow=1)
  }else{
    BETA <- matrix(BETA[,c(1,3,4)], nrow=1)

  }
  
  PROBSXY <- array(data=NA, dim=c(length(all_x),length(all_y), S))

  # Monte Carlo Average
  for(s in 1:S){
    for(i in 1:length(all_x)){
      for(j in 1:length(all_y)){
        x <- all_x[i]
        y <- all_y[j]
        r <- log(sqrt(x^2+y^2))
        t <- atan(y/x)
        if(x < 0){
          t <- t + pi
        }
        t <- t - pi/2
        t <- -t

        eBx <- exp(-t(BETA[s,]) %*% c(1, r, t))
        #eBx <- exp(-t(colMeans(BETA)) %*% c(1, r, t))
        p <- 1/(1+eBx)
        PROBSXY[i,j,s] <- p
      }
    }
  }

  probsxy <- apply(PROBSXY, c(1,2), mean)
  return(probsxy)
}

plot_contours <- function(probsxy = NA, flipx=FALSE, main=""){
  
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4

  if(flipx){
    all_x <- -all_x
  }

  probsxy_melt <- melt(probsxy, c("x","y"))
  probsxy_melt$x <- rep(all_x, length = nrow(probsxy_melt))
  probsxy_melt$y <- rep(all_y, each = length(all_x))
  all_xn <- seq(min(all_x), max(all_x), length=nrow(probsxy_melt))
  
  #img.path <- "/home/grad/neb20/hothand/index/figure/Basketball-Court-Dimensions2.png"
  img.path <- "./figure/ncaa_bball_court2.png"
  img <- readPNG(img.path)

a <- 0.7
contplot <- ggplot(probsxy_melt, aes(x = -x, y = y, z = value)) +
  annotation_custom(rasterGrob(img,
                               x=0.50, y=0.50,
                               width = .92, height = .92),
                    -Inf, Inf, -Inf, Inf) + 
  geom_tile(aes(fill = value), alpha=a) + # the color gradient
  #stat_contour(bins = 15) + # the lines
  scale_fill_gradient2(low = rgb(1,1,1), # white
                       mid = rgb(1,1,0), # yellow 
                       high= rgb(1,0,0), # red 
                       midpoint=0.45) +
  labs(title = main, y="", x="") +
  guides(fill = guide_colorbar(title = "Probability")) + # the legend
  theme_bw() + 
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

  contplot
}

if(!load_chains){
  avg1 <- mcmc_avg(player.mcmc, id1)
  avg2 <- mcmc_avg(player.mcmc, id2)
  avg3 <- mcmc_avg(player.mcmc, id3)
  avg4 <- mcmc_avg(player.mcmc, id4)
  avgtot <- mcmc_avg(player.mcmc, 0)
  
  save(avg1, file=paste0(rdatafiles,"avg1.RData"))
  save(avg2, file=paste0(rdatafiles,"avg2.RData"))
  save(avg3, file=paste0(rdatafiles,"avg3.RData"))
  save(avg4, file=paste0(rdatafiles,"avg4.RData"))
  save(avgtot, file=paste0(rdatafiles,"avgtot.RData"))
  
}else{
  
  load(paste0(rdatafiles,"avg1.RData"))
  load(paste0(rdatafiles,"avg2.RData"))
  load(paste0(rdatafiles,"avg3.RData"))
  load(paste0(rdatafiles,"avg4.RData"))
  load(paste0(rdatafiles,"avgtot.RData"))

}

contplot1 <- plot_contours(avg1, main="Player 1")
contplot2 <- plot_contours(avg2, main="Player 2")
contplot3 <- plot_contours(avg3, main="Player 3")
contplot4 <- plot_contours(avg4, main="Player 4")
contplotteam <- plot_contours(avgtot, main="Team Effect")
```

```{r contplot0}
grid.arrange(contplot1, contplot2, contplot3, contplot4, nrow=2)
```

```{r contplot, fig.cap = "Contour Plots for Four Players and Population of Players", out.width="90%", fig.align="right"}
contplotteam
```


### Discounted Likelihood Hierarchical Model

The values of $\delta$ that we use to fit the discounted likelihood models are 0.750, 0.800, 0.850, 0.900, 0.950, and 0.999. For each of these values, we refit the model to generate a full MCMC sample from the posterior, using every game as the anchor game $g_0$. We calculate predictions and fitted values for a particular shot in game $g$ using the posterior median of the MCMC chain where $g$ is the anchor game $g_0$. The plots in Figure \@ref(fig:discplot750) and \@ref(fig:discplot999) show how the posterior parameter distributions (95% credible intervals) change over the course of one season on the team level and for two players (the other two players are not shown here because they did not play during this season). Figure \@ref(fig:discplot750) illustrates the results for our smallest value of $\delta$, 0.750, and \@ref(fig:discplot999) shows them for our largest value of $\delta$, 0.999. 

```{r discfxns, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


#saves the list by its elements so it will fit in github
save_gamelist <- function(GL=NA, delta_str=NA, g_str=NA, dir = rdatafiles){

  for(g in 1:length(GL)){
    if(is.na(g_str[g])){
      g_str2 <- formatC(g, digits=2, flag="0")
    }else{
      g_str2 <- g_str[g]
    }
    
    game <- GL[[g]]
    save(game, file = paste0(dir,"gamemcmc",delta_str,"_",g_str2,".RData"))
    #giving them all the same workspace name will make it easier to delete them.
  }

}

#takes the elements from the rdata files and formats them into a list
load_gamelist <- function(delta_str=NA, dir = rdatafiles){
  
  localenv <- new.env()
  GL <- list()
  filenames <- paste0(dir,"/",list.files(path=dir, pattern=paste0("gamemcmc", delta_str))) %>% '['(order(.))
  
  for(i in 1:length(filenames)){
    load(filenames[i], envir=localenv)
    GL[[i]] <- localenv$game
    if(length(localenv$game) == 0){
      eval(parse(
        text=paste0("GL[[i]] <- localenv$game.mcmc.",delta_str,"_",formatC(i, digits=2, flag="0"))
      ))
    }

  }
  names(GL) <- as.character(gamemap$gameid)

  return(GL)
}

fit_game <- function(dat = NA, anchor = NA, discount_wt = NA, S = 10000, B = 500){

  model.game <- function(){

    for(i in 1:N){
      delta[i] <- del^abs(games[i]-g0)  # discount rate for game g relative to anchor game g0
      
      # player-level raneffs
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
                        beta_home[player[i]]*home[i] + 
                        beta_r[player[i]]*logr[i] + 
                        beta_theta[player[i]]*theta[i] 
    
      p1[i] <- prob[i]^result[i]
      p2[i] <- (1-prob[i])^(1-result[i])
      p[i] <- (p1[i] * p2[i])^delta[i]  
      # prob = likelihood, p = discounted likelihood
      
      # closer game index -> larger delta
      # larger discount weight -> larger delta
      # larger delta -> larger effect on likelihood
      # delta=1 -> all shots contribute to the likelihood like a normal independent binomial model.
      # delta=0 -> only the shots taken in the same game contribute to the likelihood
      
      #y[i] <- 1 # "ones trick" dummy outcomes
      y[i] ~ dbern(p[i]) # defines correct discounted likelihood function
    }
    
    #same priors as player model.
    # priors on random player effects
    for(j in 1:M){
      beta_int[j] ~ dnorm(beta_int0,tau_int)
      beta_home[j] ~ dnorm(beta_home0, tau_int)
      beta_r[j] ~ dnorm(beta_r0,tau_r)
      beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance   increases.  
    beta_theta0 ~ dnorm(mu0theta, 0.1)
  
    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }
  
  datlist.game <- list(
    int = rep(1, nrow(dat)), 
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result, 
    home = dat$home,
    player = as.integer(as.factor(dat$globalplayerid)),
    N = nrow(dat), 
    M = n_distinct(dat$globalplayerid),
    mu0r = mu0r,
    mu0theta = mu0theta,
    del = discount_wt,
    games = as.integer(as.factor(dat$gameid)),
    g0 = anchor,
    y = rep(1, nrow(dat)) #"phantom data"
  )

  #same params as player model (may need to change)
  params <- c("beta_int","beta_r", "beta_home", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- n_distinct(dat$globalplayerid)
  initslist <- list(list("beta_int"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
                         "beta_int0"=0,"beta_r0"=0, "beta_theta0"=0, 
                         "tau_int"=1, "tau_r"=1, "tau_theta"=1
                         ))

  sim.game <- jags(data = datlist.game, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits = initslist,
              parameters.to.save = params,
              model.file=model.game
  )
  sim.mcmc.game <- as.data.frame(as.mcmc(sim.game)[[1]])

  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")

  sim.mcmc.game <- eval(parse(text=
    
    paste0("sim.mcmc.game %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.game <- sim.mcmc.game[ , order(colnames(sim.mcmc.game))]
  
  factorids <- str_extract_all(names(sim.mcmc.game), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.game) <- str_replace_all(names(sim.mcmc.game), "[[:digit:]]+", as.character(gameids$globalplayerid))

  return(sim.mcmc.game)

}

fit_games <- function(dat = NA, discount_wt = NA, gstart = 1, S = 10000, B = 500){
    
  G <- n_distinct(dat$gameid)
  gnames <- unique(dat$gameid)
  M <- n_distinct(dat$globalplayerid)

  game.mcmc.list <- as.list(rep(NA, G))

  for(g in gstart:G){
    print(paste(k0, discount_wt, g, sep=" : "))
    game.mcmc <- fit_game(dat, g, discount_wt, S, B)
    game.mcmc.list[[ g ]] <- game.mcmc
    
    save_gamelist(game.mcmc.list[g], delta_str=1000*discount_wt, g_str=formatC(g, digits=2, flag="0"))
  }
  
  names(game.mcmc.list) <- as.character(gamemap$gameid)
  return(game.mcmc.list)
}

get_game_params <- function(sim.mcmc.list=NA, dat=NA){
  
  G <- length(sim.mcmc.list)
  M <- n_distinct(as.character(str_extract_all(names(sim.mcmc.list[[1]]), "[[:digit:]]+")))

  for(g in 1:G){
    params.game <- get_player_params(sim.mcmc.list[[g]]) %>% filter(!is.na(globalplayerid))
    if(g==1){
       params.season <- data.frame(matrix(nrow = M*G, ncol = ncol(params.game)))
       colnames(params.season) <- c(colnames(params.game))
       gameids <- gamemap %>% arrange(factorid) %>% '[['("gameid")
       params.season$gameid <- rep(gameids, each=M)
     }
     params.season[(M*(g-1) + 1):(M*g), 1:ncol(params.game)] <- params.game
  }
  
  n2 <- dat %>% group_by(gameid, globalplayerid) %>% summarize(nshots = n()) %>% as.data.frame()
  params.season <- merge(params.season, n2, all=TRUE)
  params.season$nshots[is.na(params.season$nshots)] <- 0

  return(params.season)
}

plot_time_effect <- function(game.params = NA, ids = NA, parameters = NA, main=NA, zlab=NULL, only_fga_games = TRUE, yrange = c(NULL,NULL)){
  
  if(only_fga_games & ids[1] != 0){
    #only consider this argument if we are looking at individual effects
    game.params <- game.params %>% filter(nshots > 0)
  }
  
  # ids <- factor(ids, levels=ids)
  # parameters <- factor(parameters, levels=parameters)

  plotdat <- game.params %>% 
    filter(globalplayerid %in% ids) %>% 
    select(gameid, 
           lo  = paste0(parameters,"_lo"),
           mid = paste0(parameters),
           hi  = paste0(parameters,"_hi"),
           globalplayerid) %>%
    melt(id = c("gameid", "globalplayerid")) %>%
    select(globalplayerid, gameid, type = variable, y = value) %>%
    arrange(globalplayerid, gameid, type) %>%
    mutate(clr_p = str_extract(type, "[[:digit:]]+"),
           clr_p = parameters[as.numeric(clr_p)],
           clr_p = ifelse(is.na(clr_p), 0, clr_p),
           clr_p = factor(clr_p, levels=parameters),
           clr_i = factor(globalplayerid, levels=ids))
  
  if(length(ids) == 1){
    
    ggplot(data = plotdat, 
           aes(x=as.integer(as.factor(gameid)), 
               y=y, 
               z=type, 
               linetype=(!type %in% paste0("mid", c("",1:length(parameters)))),
               size = as.numeric(type %in% paste0("mid", c("",1:length(parameters)))),
               color=clr_p)) + 
      scale_size(range=c(0.5, 3)) +
      guides(linetype=FALSE, size=FALSE) + 
      geom_line() +   
      theme_bw() +
      labs(title=main, y="Estimate", x="Game Index", color = "Parameters") +
      scale_color_manual(values = 1:length(parameters), labels = zlab) + 
      theme(panel.grid = element_blank()) +
      coord_cartesian(ylim = yrange) 
    
  }else if(length(ids) > 1 & length(parameters) == 1){
    
    ggplot(data = plotdat, 
           aes(x=as.integer(as.factor(gameid)), 
               y=y, 
               z=type, 
               linetype=(!type %in% paste0("mid", c("",1:length(parameters)))),
               size = as.numeric(type %in% paste0("mid", c("",1:length(parameters)))),
               color=clr_i)) + 
      scale_size(range=c(0.5, 3)) +
      guides(linetype=FALSE, size=FALSE) + 
      geom_line() +   
      theme_bw() +
      labs(title=main, y="Estimate", x="Game Index", color = "Players") +
      scale_color_manual(values = 1:length(ids), labels = zlab) + 
      theme(panel.grid = element_blank()) +
      coord_cartesian(ylim = yrange) 

  }
}

get_season <- function(gameid=NA){
  season <- as.numeric(substr(gameid,1,4))
  increment <- as.numeric(substr(gameid,5,6)) > 4
  season[increment] <- season[increment] + 1
  return(season)
}

if(!load_chains){
  
  eval(parse(
    text=paste0("game.mcmc.list.",deltas_str," <- fit_games(Xtrain,0.",deltas_str,", gstart=1, S=10000, B=500)\n    save_gamelist(game.mcmc.list.",deltas_str,",",deltas_str,");\n")
   ))
  
  eval(parse(
    text=paste0("game.params.",deltas_str," <- get_game_params(dat=Xtrain, game.mcmc.list.",deltas_str,");\n      save(game.params.",deltas_str,", file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))
  
}else{
  
   # eval(parse(
   #   text=paste0("game.mcmc.list.",deltas_str," <- load_gamelist(",deltas_str,");\n")
   # ))
  
  eval(parse(
    text=paste0("load(file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))

}

game.params.750_sub <- game.params.750 %>% 
  mutate(season = get_season(gameid)) %>% 
  filter(season == 2016)
game.params.999_sub <- game.params.999 %>% 
  mutate(season = get_season(gameid)) %>% 
  filter(season == 2016)
IDS <- c(0, id1, id4) 
z_IDS <- c("Team", "Player 1", "Player 4")

discplot750H <- plot_time_effect(game.params.750_sub, ids=IDS, parameters="intH", main="Intercept (Home)", zlab = z_IDS, yrange = c(-2, 4))
discplot750A <- plot_time_effect(game.params.750_sub, ids=IDS, parameters="intA", main="Intercept (Away)", zlab = z_IDS, yrange = c(-2, 4))
discplot750r <- plot_time_effect(game.params.750_sub, ids=IDS, parameters="r", main="Distance", zlab = z_IDS, yrange = c(-1, 0.1))
discplot750theta <- plot_time_effect(game.params.750_sub, ids=IDS, parameters="theta", main="Angle", zlab = z_IDS, yrange = c(-1.5, 0.75))

discplot999H <- plot_time_effect(game.params.999_sub, ids=IDS, parameters="intH", main="Intercept (Home)", zlab = z_IDS, yrange = c(-2, 4))
discplot999A <- plot_time_effect(game.params.999_sub, ids=IDS, parameters="intA", main="Intercept (Away)", zlab = z_IDS, yrange = c(-2, 4))
discplot999r <- plot_time_effect(game.params.999_sub, ids=IDS, parameters="r", main="Distance", zlab = z_IDS, yrange = c(-1, 0.1))
discplot999theta <- plot_time_effect(game.params.999_sub, ids=IDS, parameters="theta", main="Angle", zlab = z_IDS, yrange = c(-1.5, 0.75))

```

```{r discplot750, fig.cap="Parameters for Two Players and Population over Time, $\\delta$ = 0.750", fig.align="center"}
grid.arrange(discplot750H,discplot750A,discplot750r,discplot750theta, nrow=2)
```

```{r discplot999, fig.cap="Parameters for Two Players and Population over Time, $\\delta$ = 0.999", fig.align="center"}
grid.arrange(discplot999H,discplot999A,discplot999r,discplot999theta, nrow=2)
```

These plots illustrate how smaller values of $\delta$ allow for more variation in the posteriors over time. Another observation from this plot is that the credible intervals are wider when $\delta$ is smaller. Between the two plots of the home game intercepts, we can see that the 95% credible in the first game when $\delta$ = 0.750 ranges from about -1 to 3, while the corresponding interval in the plot where $\delta$ = 0.999 ranges from about 0 to 2. The uncertainty in the posteriors increases as the discounting parameter $\delta$ decreases because a smaller $\delta$ corresponds to fewer observations contributing to the likelihood.