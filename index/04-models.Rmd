# Models {#model}

## Description of Models

Using the time-stamped sequence of shot locations and binary outcomes, we fit Bayesian logistic generalized linear models, hierarchichal models, and discounted likelihood models. The discounted likelihood models allow us to observe how strongly shot success rate in the current game is affected by performance in games that are close to it. 

### Generalized Linear Model

$$
p \sim Binom
$$

### Hierarchical Generalized Linear Model

$$

$$


### Discounted Likelihood Hierarchical Model

$$

$$

We deal with the missing data by comparing the results over all games to the results on only home games, since no home games are missing in the dataset. The formal Bayesian analysis allows us to produce full quantified inferences on these patterns over time, with probabilistic summaries of the between-game outcomes. For each provided game, we will analyze player shooting tendencies and outcomes, which provides understanding of inherent variability (or "randomness") for the players, and formal assessments of differences in patterns game-to-game.

## Analysis

```{r init, include=FALSE}

#### TODO: uncomment these lines when finished multi-processing ####
# rm(list=ls())
k0 <- 1 #between 1 and k, inclusive

# k0 <- as.numeric(strsplit(srv, "")[[1]][1])
# ltr <- strsplit(srv, "")[[1]][2]
# if(ltr == "A"){
#   deltas <- c(0.750, 0.800)
# }else if(ltr == "B"){
#   deltas <- c(0.850, 0.900)
# }else if(ltr == "C"){
#   deltas <- c(0.950, 0.999)
# }

# TODO:
  # put some raw means and stuff  and shot distributions nad home/away splits on EDA section. simple things
  # REPEAT ALL ANALYSIS ON ONLY HOME GAMES!!!
  # make a 2015 folder, and a H folder, and a normal folder
    #then 5 k's within each of those :)
  # communicate posteriors in terms of probability scale (p(make|average distance, etc.)) (standardize and log troubles...)
  # put diagnostic plots in the Appendix...but not all of them!
  # don't forget a "future considerations" section in your conclusion or something
  # make a calibration plot for each game.
    # another thing that would be useful is to look at histogram of probs within a  calibration bin.
      # then you see if bins are biased
  # put EDA in Data
# put Procedure in Models & Analysis
  # highlight ones trick and MCMC things and math notation.
  # show them you used 15 servers for cross validation. brag a little. 
# you do not need to show diagnostic plots. just state that they mostly looked fine.

# rm(list=ls())

knitr::opts_chunk$set(warning = FALSE, message=FALSE, echo=FALSE)

library(knitr)     # for knitting
library(dplyr)     # used throughout
library(ggplot2)
library(stringr)
library(reshape2)
library(R2jags)    # for MCMC
library(png)       # for graphics
library(grid)
library(gridExtra)

set.seed(49301)

load_chains <- TRUE
season_2015 <- FALSE
home_only <- FALSE
k <- 5 #k-fold cross-validation
deltas <- c(seq(0.75, 0.95, 0.05),0.999)
deltas_str <- as.character(deltas*1000)

get_rdatafiles <- function(k=NA, home_only=FALSE, season_2015=FALSE){

  base <- "../rdatafiles/"
  
  if(home_only){
    base <- "../rdatafilesH/"
  }
  
  if(season_2015){
    base <- "../rdatafiles2015/"
  }
  
  load(file=paste0(base, "Xtot.RData"), envir= globalenv())
  
  if(k<1){
    return(base)
  }else{
    return(paste0(base,"k",k,"/"))
  }
}

id1 <- 887665 
id2 <- 842301 
id3 <- 603106 
id4 <- 842296 
playerseasons <- matrix(
  c(id1,   2016,
    id2,   2015,
    id3,   2014,
    id4,   2016
  ),ncol=2,byrow = TRUE
)
colnames(playerseasons) <- c("globalplayerid" ,"season")

if(season_2015){

  rdatafiles <- get_rdatafiles(k0, season_2015 = TRUE)

}else if(home_only){

  rdatafiles <- get_rdatafiles(k0, home_only = TRUE)

}else{
  
  rdatafiles <- get_rdatafiles(k0)

}

N <- nrow(Xtot)
kgroups <- rmultinom(n=N, size=1, prob = rep(1/k,k)) %>% '=='(1) %>% apply(2,which)
testrows <- which(kgroups == k0)
Xtrain <- Xtot[-testrows,] %>% arrange(time)
Xtest <- Xtot[testrows,] %>% arrange(time)


#deltas <- c(0.100, 0.250, 0.375, 0.500, 0.625, 0.750, 0.850, 0.900, 0.950, 0.975, 0.999)
# deltas <- c(seq(0.75, 0.95, 0.05),0.999)

playermap <- data.frame(
  factorid = as.integer(as.factor(Xtot$globalplayerid)),
  globalplayerid = Xtot$globalplayerid
) %>% unique()
rownames(playermap) <- NULL

gamemap <- data.frame(
  factorid = as.integer(as.factor(Xtot$gameid)),
  gameid   = Xtot$gameid
) %>% unique()
rownames(gamemap) <- NULL

```

For our models, we consider the shot location, the shooter identity, a home court indicator, and the shooting outcomes of nearby games as factors that can affect a shot outcome. In every model, we use Gibbs sampling in the JAGS library to build a logistic regression model that provides the posterior distribution of the shot location parameters (distance and angle). The model does not account for covariance between these predictors. In addition, we build mixed effects and discounted likelihood models to control for shooter identity and game identity, respectively. These models will show us how consistent the show location parameters are between shooters and between games. In our sampling method, we set priors using the Maximum Likelihood Estimates for the first four games in the dataset, and we initialize our chains using values of 0 for all means, and 1 for all variances.

Diagnostic plots for these models can be found in Appendix *number*.

### Generalized Linear Model

In our logistic regression model, we only look at shot location and the home court indicator as predictors for the shot outcome. To look at these effects for particular players, we simply subset the dataset to shots attempted by that player before running the Markov chain. The results of the credible intervals are reported for the same four players, in the same order as they were previously presented in the Exploratory Data Analysis section.

```{r glm, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


fit_glm <- function(dat, S = 10000, B = 500){

  model.glm <- function(){
  
    # N observations
    for(i in 1:N){
      logit(prob[i]) <- beta_int*int[i] + 
        beta_home*home[i] +
        beta_r*logr[i] + 
        beta_theta*theta[i]
      result[i] ~ dbern(prob[i])
    }

    # Priors
    beta_int   ~ dnorm(0, 0.1)
    beta_home  ~ dnorm(0, 0.1)
    beta_r     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta ~ dnorm(mu0theta, 0.1)
  }

  datlist.glm <-  list(
    int = rep(1, nrow(dat)),
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result,
    home = dat$home,
    N = nrow(dat), 
    mu0r = mu0r,
    mu0theta = mu0theta
  )
  
  params.glm <- c("beta_int","beta_home","beta_r", "beta_theta")

  initslist <- list(list("beta_int"=0, "beta_r"=0, "beta_theta"=0, "beta_home"=0))
                    
  sim <- jags(data = datlist.glm, 
              n.chains = 1, n.iter = S, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params.glm,
              model.file=model.glm
  )
  sim.mcmc <- as.data.frame(as.mcmc(sim)[[1]])
  sim.mcmc <- sim.mcmc %>% 
    mutate(beta_intA = beta_int,
           beta_intH = beta_int + beta_home) %>%
    select(beta_intA, beta_intH, beta_r, beta_theta)
  
  return(sim.mcmc)
}

plot_params <- function(sim.mcmc = NA, main=""){
  
    coefs <- sim.mcmc %>%
      apply(2, quantile, c(0.025,0.5,0.975)) %>%
      as.data.frame() %>%
      select(beta_intA, beta_intH, beta_r, beta_theta) %>% 
      t() %>%
      as.data.frame()
    
    colnames(coefs) <- c("lo", "mid", "hi")
    
    xtext <- c("Intercept (Away)","Intercept (Home)","Distance","Angle")
    xfact <- factor(xtext, levels=xtext)

    ggplot(data = coefs, aes(x=xfact , y=mid)) + 
      geom_point() + 
      geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + 
      geom_abline(intercept=0, slope=0, linetype=2) + 
      labs(title=main,
           x="Predictor", 
           y="Estimate") + 
      theme_bw()
}

dat1 <- Xtrain %>% filter(globalplayerid %in% playerseasons[1,1] & 
                                season %in% playerseasons[1,2])
dat2 <- Xtrain %>% filter(globalplayerid %in% playerseasons[2,1] & 
                                season %in% playerseasons[2,2])
dat3 <- Xtrain %>% filter(globalplayerid %in% playerseasons[3,1] & 
                                season %in% playerseasons[3,2])
dat4 <- Xtrain %>% filter(globalplayerid %in% playerseasons[4,1] & 
                                season %in% playerseasons[4,2])


if(!load_chains){

  glm1 <- fit_glm(dat1)
  glm2 <- fit_glm(dat2)
  glm3 <- fit_glm(dat3)
  glm4 <- fit_glm(dat4)
  glmtot <- fit_glm(Xtrain)
   
  save(glm1, file=paste0(rdatafiles,"glm1.RData"))
  save(glm2, file=paste0(rdatafiles,"glm2.RData"))
  save(glm3, file=paste0(rdatafiles,"glm3.RData"))
  save(glm4, file=paste0(rdatafiles,"glm4.RData"))
  save(glmtot, file=paste0(rdatafiles,"glmtot.RData"))
  
}else{
  
  load(file=paste0(rdatafiles,"glm1.RData"))
  load(file=paste0(rdatafiles,"glm2.RData"))
  load(file=paste0(rdatafiles,"glm3.RData"))
  load(file=paste0(rdatafiles,"glm4.RData"))
  load(file=paste0(rdatafiles,"glmtot.RData"))
  
}

glmplot1 <- plot_params(glm1, "Player 1")
glmplot2 <- plot_params(glm2, "Player 2")
glmplot3 <- plot_params(glm3, "Player 3")
glmplot4 <- plot_params(glm4, "Player 4")
glmplot5 <- plot_params(glmtot, "Team Effect")
grid.arrange(glmplot1,glmplot2,glmplot3,glmplot4, nrow=2, top= "GLM Posterior Parameters")
glmplot5
```

From these plots, we see that the team-wide 95% credible interval of the angle effect contains zero, and it is therefore probably not predictive of a made shot. The average distance effect shows us that the log-odds of a made shot decrease by $\beta_r = $ `r x <- median(glmtot[["beta_r"]]); round(x,4)` as the log distance increases by one and the other predictors remain constant. In the probability scale, this means that the probability of a made shot dereases by 

$$
\frac{e^{\beta_r}}{1 + e^{\beta_r}} 
$$

which is equal to `r round(exp(x)/(1+exp(x)), 4)`.

We also see that the 95% credible interval on the effect of distance is completely negative, which follows the intuitive idea that the probability of a made shot significantly decreases as distance from the basket increases. 

### Hierarchical Generalized Linear Model

In this hierarchical model, we add random effects to allow the parameters to vary for each player in the dataset. We present the results below using densities of how the four players of interest compare to the team distribution, and by using contour plots that illustrate each player's probability of a made shot by their location on the court.

```{r hier, cache=TRUE}
priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2

fit_players <- function(dat = NA, S = 10000, B = 500){
  
  model.player <- function(){
    # N observations
    for(i in 1:N){
      
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
        beta_home[player[i]]*home[i] + 
        beta_r[player[i]]*logr[i] + 
        beta_theta[player[i]]*theta[i]
      
      
      result[i] ~ dbern(prob[i])
    }
    # priors on random player effects
    for(j in 1:M){
        beta_int[j] ~ dnorm(beta_int0,tau_int)
        beta_home[j]  ~ dnorm(beta_home0, tau_int)
        beta_r[j] ~ dnorm(beta_r0,tau_r)
        beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta0 ~ dnorm(mu0theta, 0.1)

    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }

  datlist.player <- list(
                logr = log(dat$r), 
                theta = dat$theta, 
                home = dat$home,
                result = dat$result, 
                player = as.integer(as.factor(dat$globalplayerid)),
                N = nrow(dat), 
                int = rep(1, nrow(dat)), 
                M = n_distinct(dat$globalplayerid),
                mu0r = mu0r,
                mu0theta = mu0theta
                )
  params <- c("beta_int", "beta_home", "beta_r", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- datlist.player$M
  initslist <- list(
    list("beta_int"=rep(0,M), "beta_home"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
          "beta_int0"=0,"beta_home0"=0,"beta_r0"=0, "beta_theta0"=0, 
          "tau_int"=1, "tau_r"=1, "tau_theta"=1
  ))

  sim.player <- jags(data = datlist.player, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params,
              model.file=model.player
  )
  sim.mcmc.player <- as.data.frame(as.mcmc(sim.player)[[1]])
  
  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")
  sim.mcmc.player <- eval(parse(text=
    
    paste0("sim.mcmc.player %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.player <- sim.mcmc.player[ , order(colnames(sim.mcmc.player))]
  
  factorids <- str_extract_all(names(sim.mcmc.player), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.player) <- str_replace_all(names(sim.mcmc.player), "[[:digit:]]+", as.character(gameids$globalplayerid))
  
  return(sim.mcmc.player)
  
}

get_player_params <- function(sim.mcmc.hier=NA){

  quants <- c(0.025,0.50,0.975)
  #sim.mcmc.means <- colMeans(sim.mcmc.hier)
  sim.mcmc.meds <- matrix(apply(sim.mcmc.hier, 2, quantile, quants), nrow=length(quants))
  rownames(sim.mcmc.meds) <- as.character(quants*100)
  colnames(sim.mcmc.meds) <- colnames(sim.mcmc.hier)

  playermapparams <- melt(sim.mcmc.meds, id="") %>%
    mutate(globalplayerid = as.numeric(str_extract_all(Var2, "[[:digit:]]+")),
           param = as.character(str_extract_all(Var2, "(intA)|(intH)|(r)|(theta)"))) %>%
    dcast(globalplayerid ~ param + Var1)
  
  colnames(playermapparams) <- gsub("_2.5", "_lo", colnames(playermapparams)) %>%
    gsub(x=., "_50", "") %>%
    gsub(x=., "_97.5","_hi")
  
  return(playermapparams)
}

if(!load_chains){
  
  player.mcmc <- fit_players(dat = Xtrain)
  player.params <- get_player_params(player.mcmc)
  
  save(player.mcmc, file=paste0(rdatafiles,"playermcmc.RData"))
  save(player.params, file=paste0(rdatafiles,"playerparams.RData"))

}else{
  
  load(paste0(rdatafiles,"playermcmc.RData"))
  load(paste0(rdatafiles,"playerparams.RData"))
}

fourparams <- merge(playerseasons, player.params ,all=FALSE) %>% select(globalplayerid, intH, intA, r, theta) %>% arrange(-globalplayerid)

meplotA <- ggplot(data = player.mcmc, aes(x=beta_intA0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intA"]], col="red") + 
  geom_label(data=fourparams, aes(x=intA, y=0, label=1:4)) +
  labs(x="Intercept (Away)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())
  
meplotH <- ggplot(data = player.mcmc, aes(x=beta_intH0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intH"]], col="red") + 
  geom_label(data=fourparams, aes(x=intH, y=0, label=1:4)) +
  labs(x="Intercept (Home)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())

meplotr <- ggplot(data = player.mcmc, aes(x=beta_r0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["r"]], col="red") + 
  geom_label(data=fourparams, aes(x=r, y=0, label=1:4)) +
  labs(x="Distance", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
meplottheta <- ggplot(data = player.mcmc, aes(x=beta_theta0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["theta"]], col="red") + 
  geom_label(data=fourparams, aes(x=theta, y=0, label=1:4)) +
  labs(x="Angle", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
mainlab <- "Posterior Densities with Four Players"
grid.arrange(meplotA, meplotH, meplotr, meplottheta, nrow=2, top = mainlab)
```

The hierarchical model shows us that our four high-usage players of interest do not appear to be randomly spread across the population of players. The intercept plot shows that all four are in or close to the top half of values, and the radius plot shows the opposite with the four players trending towards lower parameter values. The high intercepts make intuitive sense, because the players who take a lot of shots are generally more capable of making them under baseline conditions than their teammates are. However, the observation that these players would have a more drastic drop in field goal percentage than an average Duke player as they move farther from the basket is surprising.

In the plots below, we have contour plots showing players' expected field goal percentages at different locations on the court. Between our four players of interest, we can observe how player *1* is more effective on the ____ side of the basket than the others, and how player ____ is the ___ long-range shooter.

```{r contours, cache=TRUE}

get_raneffs <- function(sim.mcmc = player.mcmc, globalplayerid=NA){
  if(globalplayerid>0){
    raneffs <- sim.mcmc %>% 
               '['(grepl(x=names(.), pattern=paste0("\\[",globalplayerid,"\\]")))
  }else{
    raneffs <- sim.mcmc %>% 
               '['(grepl(x=names(.), pattern=paste0("0")) & 
                  !grepl(x=names(.), pattern="\\["))
  }
  return(raneffs)
}

mcmc_avg <- function(sim.mcmc = player.mcmc, globalplayerid = NA, MLE=FALSE, home=TRUE){
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4
  S <- nrow(sim.mcmc) 
  BETA <- as.matrix(get_raneffs(sim.mcmc, globalplayerid))
  if(MLE){ #faster, but underestimates variance
    S <- 1
    BETA <- matrix(colMeans(BETA), nrow=1)
  }
  
  if(home){
    BETA <- BETA[,c(2,3,4)]
  }else{
    BETA <- BETA[,c(1,3,4)]

  }
  
  PROBSXY <- array(data=NA, dim=c(length(all_x),length(all_y), S))

  # Monte Carlo Average
  for(s in 1:S){
    for(i in 1:length(all_x)){
      for(j in 1:length(all_y)){
        x <- all_x[i]
        y <- all_y[j]
        r <- log(sqrt(x^2+y^2))
        t <- atan(y/x)
        if(x < 0){
          t <- t + pi
        }
        t <- t - pi/2

        eBx <- exp(-t(BETA[s,]) %*% c(1, r, t))
        #eBx <- exp(-t(colMeans(BETA)) %*% c(1, r, t))
        p <- 1/(1+eBx)
        PROBSXY[i,j,s] <- p
      }
    }
  }

  probsxy <- apply(PROBSXY, c(1,2), mean)
  return(probsxy)
}

plot_contours <- function(probsxy = NA, main=""){
  
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4

  probsxy_melt <- melt(probsxy, c("x","y"))
  probsxy_melt$x <- rep(all_x, length = nrow(probsxy_melt))
  probsxy_melt$y <- rep(all_y, each = length(all_x))
  all_xn <- seq(min(all_x), max(all_x), length=nrow(probsxy_melt))
  
  #img.path <- "/home/grad/neb20/hothand/index/figure/Basketball-Court-Dimensions2.png"
  img.path <- "./figure/ncaa_bball_court2.png"
  img <- readPNG(img.path)

a <- 0.7
contplot <- ggplot(probsxy_melt, aes(x = x, y = y, z = value)) +
  annotation_custom(rasterGrob(img,
                               x=0.50, y=0.50,
                               width = .92, height = .92),
                    -Inf, Inf, -Inf, Inf) + 
  geom_tile(aes(fill = value), alpha=a) + # the color gradient
  #stat_contour(bins = 15) + # the lines
  scale_fill_gradient2(low = rgb(1,1,1), # white
                       mid = rgb(1,1,0), # yellow 
                       high= rgb(1,0,0), # red 
                       midpoint=0.45) +
  labs(title = main, y="", x="") +
  guides(fill = guide_colorbar(title = "Probability")) + # the legend
  theme_bw() + 
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

  contplot
}

if(!load_chains){
  avg1 <- mcmc_avg(player.mcmc, id1)
  avg2 <- mcmc_avg(player.mcmc, id2)
  avg3 <- mcmc_avg(player.mcmc, id3)
  avg4 <- mcmc_avg(player.mcmc, id4)
  avgtot <- mcmc_avg(player.mcmc, 0)
  
  save(avg1, file=paste0(rdatafiles,"avg1.RData"))
  save(avg2, file=paste0(rdatafiles,"avg2.RData"))
  save(avg3, file=paste0(rdatafiles,"avg3.RData"))
  save(avg4, file=paste0(rdatafiles,"avg4.RData"))
  save(avgtot, file=paste0(rdatafiles,"avgtot.RData"))
  
}else{
  
  load(paste0(rdatafiles,"avg1.RData"))
  load(paste0(rdatafiles,"avg2.RData"))
  load(paste0(rdatafiles,"avg3.RData"))
  load(paste0(rdatafiles,"avg4.RData"))
  load(paste0(rdatafiles,"avgtot.RData"))

}

contplot1 <- plot_contours(avg1)
contplot2 <- plot_contours(avg2)
contplot3 <- plot_contours(avg3)
contplot4 <- plot_contours(avg4)
contplotteam <- plot_contours(avgtot, "Team Effect")

grid.arrange(contplot1, contplot2, contplot3, contplot4, nrow=2)
contplotteam

```


### Discounted Likelihood Hierarchical Model

In the discounted likelihood models, the likelihood of a single observation is more heavily influenced by the observations close to it than the observations far away from it. We measure the "distance" between observations by the number of games between them; a shot attempt that occurs in the next or the preceding game will influence the likelihood of the observation more than a shot that occurs two games away.

The effect of an observed shot on the likelihood of another shot decreases as the distance between the observations increases, and as $\delta$ decreases. If larger values of $\delta$ fit the data better, this suggests that shooting success is consistent, throughout a career. If smaller values of $\delta$ are more likely in the data, however, then we can assume there is a substantial amount of time variation in the data on the game level. The values of delta that we fit the discounted likelihood model on are 0.750, 0.800, 0.850, 0.900, 0.950, and 0.999.

*discuss discounted likelihood and implications of time-variation for different values of delta*

```{r hier-disc, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


#saves the list by its elements so it will fit in github
save_gamelist <- function(GL=NA, delta_str=NA, g_str=NA, dir = rdatafiles){

  for(g in 1:length(GL)){
    if(is.na(g_str[g])){
      g_str2 <- formatC(g, digits=2, flag="0")
    }else{
      g_str2 <- g_str[g]
    }
    
    game <- GL[[g]]
    save(game, file = paste0(dir,"gamemcmc",delta_str,"_",g_str2,".RData"))
    #giving them all the same workspace name will make it easier to delete them.
  }

}

#takes the elements from the rdata files and formats them into a list
load_gamelist <- function(delta_str=NA, dir = rdatafiles){
  
  # load(file=paste0(dir,"/gamemcmclist",delta_str,".RData"), envir = globalenv())
  localenv <- new.env()
  GL <- list()
  filenames <- paste0(dir,"/",list.files(path=dir, pattern=paste0("gamemcmc", delta_str))) %>% '['(order(.))
  
  for(i in 1:length(filenames)){
    load(filenames[i], envir=localenv)
    GL[[i]] <- localenv$game
    if(length(localenv$game) == 0){
      eval(parse(
        text=paste0("GL[[i]] <- localenv$game.mcmc.",delta_str,"_",formatC(i, digits=2, flag="0"))
      ))
    }

  }
  names(GL) <- as.character(gamemap$gameid)

  return(GL)
}

fit_game <- function(dat = NA, anchor = NA, discount_wt = NA, S = 10000, B = 500){

  model.game <- function(){

    for(i in 1:N){
      #g <- games[i]             # index of current game
      delta[i] <- del^abs(games[i]-g0)  # discount rate for game g relative to anchor game g0
      
      # player-level raneffs
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
                        beta_home[player[i]]*home[i] + 
                        beta_r[player[i]]*logr[i] + 
                        beta_theta[player[i]]*theta[i] 
    
      p1[i] <- prob[i]^result[i]
      p2[i] <- (1-prob[i])^(1-result[i])
      p[i] <- (p1[i] * p2[i])^delta[i]  
      # prob = likelihood, p = discounted likelihood
      
      # closer game index --> larger delta
      # larger discount weight --> larger delta
      # larger delta --> larger effect on likelihood
      # delta=1 --> all shots contribute to the likelihood like a normal independent binomial model.
      # delta=0 --> only the shots taken in the same game contribute to the likelihood
      
      #result[i] ~ dbern(prob[i])
      #y[i] <- 1 # "ones trick" dummy outcomes THIS LINE CAUSES PROBLEMS
      y[i] ~ dbern(p[i]) # defines correct discounted likelihood function
    }
    
    #same priors as player model.
    # priors on random player effects
    for(j in 1:M){
      beta_int[j] ~ dnorm(beta_int0,tau_int)
      beta_home[j] ~ dnorm(beta_home0, tau_int)
      beta_r[j] ~ dnorm(beta_r0,tau_r)
      beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance   increases.  
    beta_theta0 ~ dnorm(mu0theta, 0.1)
  
    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }
  
  datlist.game <- list(
    int = rep(1, nrow(dat)), 
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result, 
    home = dat$home,
    player = as.integer(as.factor(dat$globalplayerid)),
    N = nrow(dat), 
    M = n_distinct(dat$globalplayerid),
    mu0r = mu0r,
    mu0theta = mu0theta,
    del = discount_wt,
    games = as.integer(as.factor(dat$gameid)),
    g0 = anchor,
    y = rep(1, nrow(dat)) #"phantom data"
  )

  #same params as player model (may need to change)
  params <- c("beta_int","beta_r", "beta_home", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- n_distinct(dat$globalplayerid)
  initslist <- list(list("beta_int"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
                         "beta_int0"=0,"beta_r0"=0, "beta_theta0"=0, 
                         "tau_int"=1, "tau_r"=1, "tau_theta"=1
                         ))

  sim.game <- jags(data = datlist.game, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits = initslist,
              parameters.to.save = params,
              model.file=model.game
  )
  sim.mcmc.game <- as.data.frame(as.mcmc(sim.game)[[1]])

  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")

  sim.mcmc.game <- eval(parse(text=
    
    paste0("sim.mcmc.game %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.game <- sim.mcmc.game[ , order(colnames(sim.mcmc.game))]
  
  factorids <- str_extract_all(names(sim.mcmc.game), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.game) <- str_replace_all(names(sim.mcmc.game), "[[:digit:]]+", as.character(gameids$globalplayerid))

  return(sim.mcmc.game)

}

fit_games <- function(dat = NA, discount_wt = NA, gstart = 1, S = 10000, B = 500){
    
  G <- n_distinct(dat$gameid)
  gnames <- unique(dat$gameid)
  M <- n_distinct(dat$globalplayerid)

  game.mcmc.list <- as.list(rep(NA, G))

  for(g in gstart:G){
    print(paste(k0, discount_wt, g, sep=" : "))
    game.mcmc <- fit_game(dat, g, discount_wt, S, B)
    game.mcmc.list[[ g ]] <- game.mcmc
    
    save_gamelist(game.mcmc.list[g], delta_str=1000*discount_wt, g_str=formatC(g, digits=2, flag="0"))
  }
  
  names(game.mcmc.list) <- as.character(gamemap$gameid)
  return(game.mcmc.list)
}

get_game_params <- function(sim.mcmc.list=NA, dat=NA){
  
  G <- length(sim.mcmc.list)
  M <- n_distinct(as.character(str_extract_all(names(sim.mcmc.list[[1]]), "[[:digit:]]+")))

  for(g in 1:G){
    params.game <- get_player_params(sim.mcmc.list[[g]]) %>% filter(!is.na(globalplayerid))
    if(g==1){
       params.season <- data.frame(matrix(nrow = M*G, ncol = ncol(params.game)))
       colnames(params.season) <- c(colnames(params.game))
       gameids <- gamemap %>% arrange(factorid) %>% '[['("gameid")
       params.season$gameid <- rep(gameids, each=M)
     }
     params.season[(M*(g-1) + 1):(M*g), 1:ncol(params.game)] <- params.game
  }
  
  n2 <- dat %>% group_by(gameid, globalplayerid) %>% summarize(nshots = n()) %>% as.data.frame()
  params.season <- merge(params.season, n2, all=TRUE)
  params.season$nshots[is.na(params.season$nshots)] <- 0

  return(params.season)
}

plot_time_effect <- function(game.params = NA, id = NA, parameter = NA, main=NA, only_fga_games = TRUE){
  
  if(id != 0 & only_fga_games){
    #only consider this argument if we are looking at individual effects
    game.params <- game.params %>% filter(nshots > 0)
  }
  plotdat <- game.params %>% 
    filter(globalplayerid == id) %>% 
    select(gameid, 
           lo  = paste0(parameter,"_lo"),
           mid = paste0(parameter),
           hi  = paste0(parameter,"_hi")) %>%
    melt(id = "gameid") %>%
    select(gameid, type = variable, y = value) %>%
    arrange(gameid, type)
  
    ggplot(data = plotdat, 
         aes(x=as.integer(as.factor(gameid)), y=y, z=type, linetype=(type!="mid"))) + 
    guides(linetype=FALSE) + 
    geom_line() +   
    theme_bw() +
    labs(title=main, y="Estimate", x="Game") + 
    theme(panel.grid = element_blank())
  
}


if(!load_chains){
  
  eval(parse(
    text=paste0("game.mcmc.list.",deltas_str," <- fit_games(Xtrain,0.",deltas_str,", gstart=1, S=10000, B=500)\n    save_gamelist(game.mcmc.list.",deltas_str,",",deltas_str,");\n")
   ))
  
  eval(parse(
    text=paste0("game.params.",deltas_str," <- get_game_params(dat=Xtrain, game.mcmc.list.",deltas_str,");\n      save(game.params.",deltas_str,", file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))
  
}else{
  
  # eval(parse(
  #   text=paste0("game.mcmc.list.",deltas_str," <- load_gamelist(",deltas_str,");\n")
  # ))
  
  eval(parse(
    text=paste0("load(file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))


}

game.params <- game.params.750
discplot1 <- plot_time_effect(game.params, id=id1, parameter="intH", main="Intercept (Home) Player 1")
discplot2 <- plot_time_effect(game.params, id=id2, parameter="intH", main="Intercept (Home) Player 2")
discplot3 <- plot_time_effect(game.params, id=id3, parameter="intH", main="Intercept (Home) Player 3")
discplot4 <- plot_time_effect(game.params, id=id4, parameter="intH", main="Intercept (Home) Player 4")
discplot5 <- plot_time_effect(game.params, id=0, parameter="intH", main="Intercept (Home) Team")

grid.arrange(discplot1,discplot2,discplot3,discplot4, nrow=2)
discplot5
```

*talk about your illustrations*
The plots above illustrate...


## Evaluation of Models

To evaluate these models, we use 5-fold cross validation. In each train-test split, we evaluate a model's out-of-sample classification rate (using a cutoff probability of 0.5), Brier score (mean squared error), and log likelihood. The predictions and fitted values are obtained using MCMC averages over ___. The results are plotted below:

```{r preds, cache=TRUE}
# posterior mean   --> minimize sq err
# posterior median --> minimize abs err

# we want S predictions per shot. an N x S matrix. then we take MCMC average.
pred_glm <- function(Xpred = NA, MCMC = NA){
  
  Xmat <- Xpred %>% 
    mutate(logr = log(r),
           away = 1-home) %>%
    arrange(time) %>%
    select(away, home, logr, theta) %>% 
    as.matrix()

  # the baseline 1 intercept = "away"
  # we should only multiply by that one if home = 0
  #params.glm <- t(MCMC)
  A <- Xmat
  B <- t(MCMC)
  pred.glm <-  arm::invlogit(A %*% B) %>% apply(., 1, median) #MCMC median
  
  return(as.matrix(pred.glm))
}

pred_me <- function(Xpred = NA, MCMC = NA){

  Xmat <- Xpred %>% 
    mutate(logr = log(r),
           away = 1-home) %>%
    arrange(time) %>%
    select(away, home, logr, theta, globalplayerid) %>% 
    as.matrix()

  pred.me <- array(NA, c(nrow(Xmat), 1))
  for(r in 1:nrow(Xmat)){
    gpid <- Xmat[r,"globalplayerid"]
    Asub <- Xmat[r,1:4] # 1 x p
    playerinds <- grep(gpid, colnames(MCMC))
    Bsub <- t(MCMC[,playerinds]) # p x S
    if(length(playerinds) == 0){
      Bsub <- t(MCMC[,which(!grepl("\\]", colnames(MCMC)))])
    }
    pred.me[r,] <- median(arm::invlogit(Asub %*% Bsub)) #MCMC avg
  }

  return(pred.me)
}

pred_disc <- function(Xpred = NA, MCMC.LIST=NA){
  
  pred.disc.large <- lapply(X=MCMC.LIST, FUN=pred_me, Xpred=Xpred) %>% 
    as.data.frame() %>%
    as.matrix()
  
  rownames(pred.disc.large) <- Xpred$gameid   #N
  colnames(pred.disc.large) <- gamemap$gameid #G, from the list
  
  pred.disc <- array(NA, c(nrow(Xpred), 1))

  for(i in 1:nrow(Xpred)){
    keepcol <- colnames(pred.disc.large) == Xpred[i,"gameid"]
    pred.disc[i,] <- pred.disc.large[i, keepcol]
  }

  return(pred.disc)
  
}


if(!load_chains){
  
  pred.team     <- pred_glm(Xtest, glmtot)
  pred.player   <- pred_me(Xtest, player.mcmc)
  eval(parse(
    text=paste0("pred.game.",deltas_str," <- pred_disc(Xtest, game.mcmc.list.", deltas_str, ");\nprint(",deltas_str,");")
  ))
  savepreds <- ls() %>% grep(pattern="pred.",fixed=TRUE,value=TRUE)
  temp <- lapply(as.list(savepreds), function(x){
    save(list=x, 
         file=paste0(rdatafiles,gsub(patt=".",rep="",x=x,fixed=TRUE),".RData"))
    })
  
  fitted.team     <- pred_glm(Xtrain, glmtot)
  fitted.player   <- pred_me(Xtrain, player.mcmc)
  eval(parse(
    text=paste0("fitted.game.", deltas_str," <- pred_disc(Xtrain, game.mcmc.list.", deltas_str, ");\nprint(",deltas_str,");")
  ))
  savefitteds <- ls() %>% grep(pattern="fitted.",fixed=TRUE,value=TRUE)
  temp <- lapply(as.list(savefitteds), function(x){
    save(list=x, 
         file=paste0(rdatafiles,gsub(patt=".",rep="",x=x,fixed=TRUE),".RData"))
  })
  

}else{
  
  prefixes <- c("pred", "fitted")
  suffixes <- paste0(c("team", "player", paste0("game",deltas_str)),".RData")
  loadfiles <- merge(prefixes, suffixes) %>% apply(1, paste0, collapse="") %>% paste0(rdatafiles, .)
  temp <- lapply(as.list(loadfiles), load, envir=globalenv())

}

```


## Evaluation of Models

```{r model-eval, cache=TRUE}

#confusion matrix, classification rate, and brier score
classify <- function(observed = NA, predicted = NA, cutoff = 0.5, gameids = NA){

  eval.list <- list()
  
  if(is.na(gameids[1])){
    gameids <- 1
  }
  
  for(i in 1:n_distinct(gameids)){
    g <- unique(gameids)[i]
    pred <- predicted[gameids == g]
    obs <- observed[gameids == g]
    
    tab <- array(NA, c(2,2))
    rownames(tab) <- c("predicted miss", "predicted make")
    colnames(tab) <- c("observed miss", "observed make")
    pred01 <- ifelse(pred < cutoff, 0, 1)
    
    tab[1,1] <- sum(obs==0 & pred01==0)
    tab[1,2] <- sum(obs==1 & pred01==0)
    tab[2,1] <- sum(obs==0 & pred01==1)
    tab[2,2] <- sum(obs==1 & pred01==1)
    
    rate <- (tab[1,1]+tab[2,2])/length(obs)
    
    eval.list[[as.character(g)]] <-  rate
  }
    
  if(gameids == 1){
    return(rate)
  }else{
    return(eval.list)
  }
}

meansquare <- function(observed = NA, predicted = NA, gameids = NA){

  eval.list <- list()
  
  if(is.na(gameids[1])){
    gameids <- 1
  }
  
  for(i in 1:n_distinct(gameids)){
    g <- unique(gameids)[i]
    pred <- predicted[gameids == g]
    obs <- observed[gameids == g]
    
    MSE <- mean((obs - pred)^2)
    
    eval.list[[as.character(g)]] <-  MSE
  }
    
  if(gameids == 1){
    return(MSE)
  }else{
    return(eval.list)
  }
}

loglikelify <- function(observed = NA, predicted = NA, gameids = NA){

  eval.list <- list()
  
  if(is.na(gameids[1])){
    gameids <- 1
  }
  
  for(i in 1:n_distinct(gameids)){
    g <- unique(gameids)[i]
    pred <- predicted[gameids == g]
    obs <- observed[gameids == g]
    
    #deviance
    loglik <- sum(
      obs*log(pred) + (1-obs)*log((1-pred))
    )
    eval.list[[as.character(g)]] <-  loglik
  }
  
  if(gameids == 1){
    return(loglik)
  }else{
    return(eval.list)
  }
}

#data for calibration plots
calibrate <- function(observed = NA, predicted = NA, nbins = 20, gameids = NA){

  eval.list <- list()
  
  if(is.na(gameids[1])){
    gameids <- 1
  }
  
  for(i in 1:n_distinct(gameids)){
    g <- unique(gameids)[i]
    pred <- predicted[gameids == g]
    obs <- observed[gameids == g]

    if(n_distinct(pred) < nbins){
      calib <- NA
    }else{
      
      predquants <- c(0, quantile(pred, (1:nbins)/nbins))
      predmidpts <- ((predquants + c(0,predquants[-length(predquants)]))/2) %>% '['(-1)
    
      pred1N <- sapply(pred, findInterval, vec=predquants, all.inside=TRUE, rightmost.closed=TRUE, left.open=TRUE)
  
      calibtab <- table(pred1N, obs)
      rownames(calibtab) <- predmidpts
      calib <- calibtab %>% 
        as.data.frame() %>%
        dcast(pred1N ~ obs, value.var = "Freq") %>%
        mutate(p  = `1`/(`0`+`1`),
               pl = p - 2*sqrt(p*(1-p)/(`0` + `1`)),
               pu = p + 2*sqrt(p*(1-p)/(`0` + `1`)),
               binl = predquants[-(nrow(.)+1)],
               binu = predquants[-1])
      colnames(calib) <- c("bin", "obs0", "obs1", "p", "pl", "pu", "binl", "binu")

    }
    
    eval.list[[as.character(g)]] <- calib
  }
  
  if(gameids == 1){
    return(calib)
  }else{
    return(eval.list)
  }
}

plot_calibration <- function(dat, title="Calibration Plot"){
  ggplot(data = dat, aes(x=as.numeric(as.character(bin)), y=p, group=0)) + 
    geom_errorbar(aes(ymin=pl, ymax=pu), width=0) + 
    geom_errorbarh(aes(xmin=binl, xmax=binu), height=0) + 
    geom_abline(slope=1, color="red") +
    coord_cartesian(xlim=c(0,1), ylim=c(0,1)) + 
    theme(panel.grid = element_blank()
          #,panel.border = element_blank(), axis.text = element_blank(), axis.ticks =   element_blank()
          ) + 
    theme_bw() + 
    labs(x="bin", title=title)
}

if(!load_chains){
  
  class.team  <- classify(Xtest$result, pred.team)
  class.player <- classify(Xtest$result, pred.player)
  eval(parse(
    text=paste0("class.games <- c(",
           paste0("classify(Xtest$result,pred.game.",deltas_str,collapse="),"),"))"
         )
  ))

  mse.team  <- meansquare(Xtest$result, pred.team)
  mse.player <- meansquare(Xtest$result, pred.player)
  eval(parse(
    text=paste0("mse.games <- c(",
           paste0("meansquare(Xtest$result, pred.game.",deltas_str,collapse="),"),"))"
          )
    ))
  
  lik.team  <- loglikelify(Xtrain$result, fitted.team)
  lik.player <- loglikelify(Xtrain$result, fitted.player)
  eval(parse(
    text=paste0("lik.games <- c(",
           paste0("loglikelify(Xtrain$result, fitted.game.",deltas_str,collapse="),"),"))"
          )
    ))
  eval.df <- data.frame(
    class = c(class.team, class.player, class.games),
    mse = c(mse.team, mse.player, mse.games),
    lik = c(lik.team, lik.player, lik.games),
    type = c("GLM", "Mixed Effects",rep("Discount Likelihood", length(deltas))),
    delta = c(NA, NA, deltas_str),
    k = k0
  )

  save(eval.df, file=paste0(rdatafiles, "evaldf.RData"))
  
}else{
  
  tempenv <- new.env()
  eval.df <- NULL
  for(i in 1:k){
    
    load(file = paste0(get_rdatafiles(i), "evaldf.RData"), tempenv)
    eval.df <- rbind(eval.df, tempenv$eval.df)
    eval.df$k <- as.factor(eval.df$k)
    
  }
}

df_delta <- eval.df %>% filter(!is.na(delta))
df <- eval.df %>% filter(is.na(delta))
g1 <- ggplot(data=df_delta, aes(x=delta,y=class, col=k)) +
   geom_point() + 
   geom_hline(data=df, aes(yintercept=class, linetype=type, col=k)) +
   theme_bw() + 
   labs(y="Classification Rate \n (0.5 cutoff)", x="delta", linetype = "", col = "")

g2 <- ggplot(data=df_delta, aes(x=delta,y=lik, col=k)) +
  geom_point() +
  geom_hline(data=df, aes(yintercept=lik, linetype=type, col=k)) +
  theme_bw() +
  labs(y="Log Likelihood", x="delta", linetype = "")

g3 <- ggplot(data=df_delta, aes(x=delta,y=mse, col=k)) +
  geom_point() +
  geom_hline(data=df, aes(yintercept=mse, linetype=type, col=k)) +
  theme_bw() +
  labs(y="Brier Score (MSE)", x="delta", linetype = "")

grid.arrange(g1, g2, g3, nrow=2)

```


From these plots, we can observe that all of the models have different strengths. The discounted likelihood model with the smallest $\delta$ consistently has the highest likelihood. However, it does not test as well as the other models in areas of out-of-sample classification rate and Brier score. This suggests that a smaller value of $\delta$ leads to overfitting the model to the training data, since the likelihood of a particular shot is only influenced by shots close to it.

To account for possible unexplained variation between seasons, and in missing road games, I repeated this analysis on a subset of the data that only consisted of shots from the 2015 season, and a subset that was only home games. *results!* (show these results in Appendix?)

For the remainder of this paper, we will 

