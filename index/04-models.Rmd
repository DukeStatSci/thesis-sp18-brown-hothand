---
output:
  thesisdowndss::thesis_gitbook: default
  thesisdowndss::thesis_pdf: default
---

# Models & Analysis {#models}

<!--


-->

## Description of Models

For our models, we consider the shot location, the shooter identity, a home court indicator, and a player's shooting success rate in nearby games as factors that can affect a shot outcome. In every model, we use the Just Another Gibbs Sampler library in R (`R2jags`). Each model is based off of a logistic regression model that provides the posterior distribution of the shot location parameters (distance and angle). The models do not account for covariance between these predictors. We expand upon this model by adding mixed effects and discounted likelihood models to control for shooter identity and game identity, respectively. These models will show us how consistent the shot location parameters are between shooters and between games. In our Gibbs Samplers, we  estimate the posterior distributions using 10,000 simulations and a burn-in of 500. Our priors are made from the corresponding Maximum Likelihood Estimates for the first four games in the dataset, and we initialize our Monte Carlo Markov Chains using values of 0 for all means, and 1 for all variances. 

The `R2jags` code used to build these models, as well as some diagnostic plots, can be found in Appendices **number** and **number**, respectively.


### Generalized Linear Model

First, we build a logistic regression model of the following form:

$$
\text{log} \left( \frac{p}{1-p} \right) = 
\beta_{\text{int}} +
x_{\text{r}}\beta_{\text{r}} +
x_{\theta}\beta_{\theta} +
x_{\text{H}}\beta_{\text{H}}.
$$

In this model, the $x$ refers to the data, and the $\beta$s are the pareters from the model. The subscripts $\textit{int}$, $\textit{r}$, $\theta$, and $\textit{H}$ respectively refer to the intercept, the log-distance of the shot, the angle of the shot, and whether shot was taken on Duke's home court or another gym.

### Hierarchical Generalized Linear Model

Our second model is a hierarchical model, with random effects on the $\textit{j}$ players in the dataset. These random effects occur for each of the four parameters of interest---the intercept, the home effect, the distance effect, and the angle effect. Each individual player's parameter values are sampled from a Normal distribution centered at the population values. The parameters for players without a lot of shot attemps are shrunk towards the population means.


$$
\text{log} \left( \frac{p}{1-p} \right) = 
\beta_{\text{int, j}} +
x_{\text{r}}\beta_{\text{r, j}} +
x_{\theta}\beta_{\theta, j} +
x_{\text{H}}\beta_{\text{H, j}},
$$
$$
\beta_{\text{int, j}} \sim N(\beta_{\text{int}}, \tau^2_{\text{int}}),
$$
$$
\beta_{\text{r, j}} \sim N(\beta_{\text{r}}, \tau^2_{\text{r}}),
$$
$$
\beta_{\theta, j} \sim N(\beta_{\theta}, \tau^2_{\theta}),
$$
$$
\beta_{\text{H, j}} \sim N(\beta_{\text{H}}, \tau^2_{\text{H}}).
$$

### Discounted Likelihood Hierarchical Model

In the discounted likelihood models, the likelihood of a single observation at time $\textit{t}$ is more heavily influenced by the observations close to it than the observations far away from it. We measure the "distance" between observations by the number of games between them; a shot attempt that occurs in the next or the preceding game will influence the likelihood of the observation more than a shot that occurs two games away. To conceptualize this model, we first start with a Forward Filtering model that uses a discounted Bayes Theorem. The discounted Bayes Theorem, like the traditional Bayes Theorem, states that the posterior is proportional to the product of the likelihood and the prior, but it weights the most recent data higher than the earlier data, which is weighted higher than the prior. 

In other words, given the parameters:
$$
\Theta = (\beta_{\text{int}}, \beta_{\text{r}}, \beta_{\theta}, \beta_\text{H}, \tau^2_{\text{int}}, \tau^2_{\text{r}}, \tau^2_{\theta})
$$
the joint posterior distribution of the parameters given the data up to time unit $\textit{t}$, $X_t$, is:
$$
P_{g_t}(\Theta | X_t) \propto 
P(\Theta)^{\delta^t}
P(X_1|\Theta)^{\delta^{t-1}}
P(X_2|\Theta)^{\delta^{t-2}}...
P(X_{t-2}|\Theta)^{\delta^2}
P(X_{t-1}|\Theta)^{\delta}
P(X_t|\Theta)
$$
$$
0 < \delta < 1
$$
This equation shows that as distance from time $\textit{t}$ increases, the effect on the posterior distribution decreases. The Reverse Updating extension of this concept allows the effect to take place as the distance from $\textit{t}$ increases in either the positive or negative direction.
$$
P_{g_t}(\Theta | X_t) \propto 
P(\Theta)^{\delta^t}...
P(X_{t-2}|\Theta)^{\delta^2}
P(X_{t-1}|\Theta)^{\delta}
P(X_t|\Theta)
P(X_{t+1}|\Theta)^{\delta}
P(X_{t+2}|\Theta)^{\delta^2}...
$$
Specifically for our model, given an observed shot $\textit{i}$ in game $g_i$, attempted by player $\textit{j}$, we use the above concept to discount the probability of a made shot in the hierarchical model.
$$
\text{log} \left( \frac{p}{1-p} \right) = 
\beta_{\text{int, j}} +
x_{\text{r}}\beta_{\text{r, j}} +
x_{\theta}\beta_{\theta, j} +
x_{\text{H}}\beta_{\text{H, j}},
$$
$$
L(p) = 
\Pi_{\text{i=1}}^\text{n}p^{\text{y}_i} (1 - p)^{1-\text{y}_i},
$$
$$
\delta_i = \Delta^{|g_i - g_t|},
$$

$$
\pi = L(p)^{\delta_i},
$$
$$
\beta_{\text{int, j}} \sim N(\beta_{\text{int}}, \tau^2_{\text{int}}),
$$
$$
\beta_{\text{r, j}} \sim N(\beta_{\text{r}}, \tau^2_{\text{r}}),
$$
$$
\beta_{\theta, j} \sim N(\beta_{\theta}, \tau^2_{\theta}),
$$
$$
\beta_{\text{H, j}} \sim N(\beta_{\text{H}}, \tau^2_{\text{H}}).
$$
In this model, $p$ represents the binomial likelihood, and $\pi$ is the discounted likelihood. Both of these quantities are probabilities that are bounded in the interval [0,1]. The contribution of shot outcomes (in the "anchor game" $g_t$) to the likelihood of the current shot outcome (in game $g_i$) decreases as the distance between the observations increases, and as $\Delta$ decreases. In a model with $\Delta$ = 0, only shots taken in the same game as $g_i$ can contribute to the likelihood, while $\Delta$ = 1 is equivalent to a model with no discounting. If models with larger values of $\Delta$ best fit the data, this suggests that shooting success is consistent throughout a career. If smaller values of $\Delta$ are more likely in the data, however, then we can assume there is a substantial amount of time variation, or "streakinss" in the data on the game level. This model specification results in an MCMC chain for each combination of $g_t$ and $\Delta$. Figure \@ref(fig:discplot) illustrates how the likelihood weight of $\delta$ depends on the selected value of $\Delta$ and the distance from the anchor game ($|g_i - g_t|$).

<!--
$$
\text{log} \left( \frac{p}{1-p} \right) = 
\beta_{\text{int, j}} +
x_{\text{r}}\beta_{\text{r, j}} +
x_{\theta}\beta_{\theta, j} +
x_{\text{H}}\beta_{\text{H, j}} 
$$
$$
L(p) = 
\Pi_{\text{i=1}}^\text{n}(p_i)^{\text{y}_i} (1 - p_i)^{1-\text{y}_i} = 
\mu 
$$
$$
\pi = \mu^{\delta_i}
$$
$$
\delta_i = \Delta^{|g_i - g_0|}
$$
$$
\beta_{\text{int, j}} \sim N(\beta_{\text{int}}, \tau^2_{\text{int}})
$$
$$
\beta_{\text{r, j}} \sim N(\beta_{\text{r}}, \tau^2_{\text{r}})
$$
$$
\beta_{\theta, j} \sim N(\beta_{\theta}, \tau^2_{\theta})
$$
$$
\beta_{\text{H, j}} \sim N(\beta_{\text{H}}, \tau^2_{\text{H}})
$$

In this model, $\mu$ represents the likelihood of the binomial events $y_i$, while $\pi$ represents the discounted likelihood. These equations show us that the contribution of an observed shot (in the "anchor game" $g_0$) to the likelihood of the current shot (in game $g_i$) decreases as the distance between the observations increases, and as $\Delta$ decreases. In a model with $\Delta$ = 0, then only shots taken in the same game as $g_i$ can contribute to the likelihood, while $\Delta$ = 1 is equivalent to a model with no discounting. This model specification results in an MCMC chain for each combination of $g_0$ and $\Delta$. Figure \@ref(fig:discplot) illustrates how the likelihood weight of $\delta$ depends on the selected value of $\Delta$ and the distance from the anchor game.
-->
```{r discplot, fig.cap = "Illustration of Discounted Weighting"}
t <- as.matrix(seq(-10, 10))
#D <- as.matrix(seq(0.1, 1, by=0.1))
D <- as.matrix(c(seq(0.75, 0.95, 0.05),0.999))
weights <- as.data.frame(apply(D, 1, '^', abs(t)))
colnames(weights) <- D
weights$t <- t
weightslong <- melt(weights, id="t") %>% 
  rename(D=variable,
         y=value)

discplot <- ggplot(weightslong, aes(x=t, y=y, color=D)) + 
  geom_line(size=1.25) + 
  labs(color = expression(Delta) ,
       y = expression(delta[i]),
       x = expression(g[i] - g[t])) +
  theme_bw() +
  theme(legend.title = element_text(size=10,face="bold"),
        axis.title.y = element_text(angle = 0, vjust=0.5)) +
  scale_y_continuous(minor_breaks = seq(0, 1, .25)) +
  scale_x_continuous(minor_breaks = seq(-10, 10, 5))
  
discplot
```

To build these discounted likelihood models in the `R2jags` library, we apply the "ones trick". This technique allows us to do a sampling distribution that do not exist in the library by modifying a common distribution---in this case, the Binomial. The probability $p$ is estimated using the Bayesian hierarchical model. We discount this probability to estimate $\pi$, and then specify that artificial data that consists only of ones comes from a Binomial distribution with the discounted probability; this is equivalent to sampling from a distribution with discounted outcomes.   **insert a snippet of the cde**. See Appendix **number** for the full `R` code. 

<!--
We deal with the missing data by reproducing the results over all games to the results on only home games, since no home games are missing in the dataset. The formal Bayesian analysis allows us to produce full quantified inferences on these patterns over time, with probabilistic summaries of the between-game outcomes. For each provided game, we will analyze player shooting tendencies and outcomes, which provides understanding of inherent variability (or "randomness") for the players, and formal assessments of differences in patterns game-to-game. These results are illustrated in Appendix **number**.
-->

## Analysis

```{r init, include=FALSE}

# srv <- ""
# k0 <- as.numeric(strsplit(srv, "")[[1]][1])
# ltr <- strsplit(srv, "")[[1]][2]
# fldr <- strsplit(srv, "")[[1]][3]
# if(ltr == "A"){
#   deltas <- c(0.750, 0.800, 0.850)
# }else if(ltr == "B"){
#   deltas <- c(0.900, 0.950, 0.999)
# }
# if(fldr == "H"){
#   home_only <- TRUE
#   season_2015 <- FALSE
# }else if(fldr == "2"){
#   home_only <- FALSE
#   season_2015 <- TRUE
# }

# TODO:
  # put some raw means and stuff  and shot distributions nad home/away splits on EDA section. simple things
  # put diagnostic plots in the Appendix...but not all of them!
  # make a calibration plot (for each game?)

set.seed(49301)

k <- 5 #k-fold cross-validation
k0 <- 1
load_chains <- TRUE
season_2015 <- FALSE
home_only <- FALSE

deltas <- c(seq(0.75, 0.95, 0.05),0.999)
deltas_str <- as.character(deltas*1000)

get_rdatafiles <- function(k=NA, home_only=FALSE, season_2015=FALSE){

  base <- "../rdatafiles/"
  
  if(home_only){
    base <- "../rdatafilesH/"
  }
  
  if(season_2015){
    base <- "../rdatafiles2015/"
  }
  
  load(file=paste0(base, "Xtot.RData"), envir= globalenv())
  
  if(k<1){
    return(base)
  }else{
    return(paste0(base,"k",k,"/"))
  }
}


rdatafiles <- get_rdatafiles(k0, home_only = home_only, season_2015 = season_2015)

N <- nrow(Xtot)
kgroups <- rmultinom(n=N, size=1, prob = rep(1/k,k)) %>% '=='(1) %>% apply(2,which)
testrows <- which(kgroups == k0)
Xtrain <- Xtot[-testrows,] %>% arrange(time)
Xtest <- Xtot[testrows,] %>% arrange(time)

playermap <- data.frame(
  factorid = as.integer(as.factor(Xtot$globalplayerid)),
  globalplayerid = Xtot$globalplayerid
) %>% unique()
rownames(playermap) <- NULL

gamemap <- data.frame(
  factorid = as.integer(as.factor(Xtot$gameid)),
  gameid   = Xtot$gameid
) %>% unique()
rownames(gamemap) <- NULL

```


### Generalized Linear Model

In our logistic regression model, we only look at shot location and the home court indicator as predictors for the shot outcome. To look at these effects for particular players, we simply subset the dataset to shots attempted by that player before running the Gibbs Sampler. Below in Figure \@ref(fig:glmplot), The 95% credible intervals of the posterior parameters are reported for the same four players that were introduced in Figure \@ref(fig:smoothplot).  

```{r glmfxns, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


fit_glm <- function(dat, S = 10000, B = 500){

  model.glm <- function(){
  
    # N observations
    for(i in 1:N){
      logit(prob[i]) <- beta_int*int[i] + 
        beta_home*home[i] +
        beta_r*logr[i] + 
        beta_theta*theta[i]
      result[i] ~ dbern(prob[i])
    }

    # Priors
    beta_int   ~ dnorm(0, 0.1)
    beta_home  ~ dnorm(0, 0.1)
    beta_r     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta ~ dnorm(mu0theta, 0.1)
  }

  datlist.glm <-  list(
    int = rep(1, nrow(dat)),
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result,
    home = dat$home,
    N = nrow(dat), 
    mu0r = mu0r,
    mu0theta = mu0theta
  )
  
  params.glm <- c("beta_int","beta_home","beta_r", "beta_theta")

  initslist <- list(list("beta_int"=0, "beta_r"=0, "beta_theta"=0, "beta_home"=0))
                    
  sim <- jags(data = datlist.glm, 
              n.chains = 1, n.iter = S, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params.glm,
              model.file=model.glm
  )
  sim.mcmc <- as.data.frame(as.mcmc(sim)[[1]])
  sim.mcmc <- sim.mcmc %>% 
    mutate(beta_intA = beta_int,
           beta_intH = beta_int + beta_home) %>%
    select(beta_intA, beta_intH, beta_r, beta_theta)
  
  return(sim.mcmc)
}

plot_params <- function(sim.mcmc = NA, main=""){
  
    coefs <- sim.mcmc %>%
      apply(2, quantile, c(0.025,0.5,0.975)) %>%
      as.data.frame() %>%
      mutate(beta_theta = -beta_theta) %>% 
      select(beta_intA, beta_intH, beta_r, beta_theta) %>% 
      t() %>%
      as.data.frame()
    
    colnames(coefs) <- c("lo", "mid", "hi")
    
    xtext <- c("Intercept\n(Away)","Intercept\n(Home)","Distance","Angle")
    xfact <- factor(xtext, levels=xtext)

    ggplot(data = coefs, aes(x=xfact , y=mid)) + 
      geom_point() + 
      geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + 
      geom_abline(intercept=0, slope=0, linetype=2) + 
      labs(title=main,
           x="Predictor", 
           y="Estimate") + 
      theme_bw()
}

dat1 <- Xtrain %>% filter(globalplayerid %in% playerseasons[1,1] & 
                                season %in% playerseasons[1,2])
dat2 <- Xtrain %>% filter(globalplayerid %in% playerseasons[2,1] & 
                                season %in% playerseasons[2,2])
dat3 <- Xtrain %>% filter(globalplayerid %in% playerseasons[3,1] & 
                                season %in% playerseasons[3,2])
dat4 <- Xtrain %>% filter(globalplayerid %in% playerseasons[4,1] & 
                                season %in% playerseasons[4,2])


if(!load_chains){

  glmtot <- fit_glm(Xtrain)

  if(nrow(dat1) > 0) glm1 <- fit_glm(dat1) else glm1 <- glmtot
  if(nrow(dat2) > 0) glm2 <- fit_glm(dat2) else glm2 <- glmtot
  if(nrow(dat3) > 0) glm3 <- fit_glm(dat3) else glm3 <- glmtot
  if(nrow(dat4) > 0) glm4 <- fit_glm(dat4) else glm4 <- glmtot
  
  save(glm1, file=paste0(rdatafiles,"glm1.RData"))
  save(glm2, file=paste0(rdatafiles,"glm2.RData"))
  save(glm3, file=paste0(rdatafiles,"glm3.RData"))
  save(glm4, file=paste0(rdatafiles,"glm4.RData"))
  save(glmtot, file=paste0(rdatafiles,"glmtot.RData"))
  
}else{
  
  load(file=paste0(rdatafiles,"glm1.RData"))
  load(file=paste0(rdatafiles,"glm2.RData"))
  load(file=paste0(rdatafiles,"glm3.RData"))
  load(file=paste0(rdatafiles,"glm4.RData"))
  load(file=paste0(rdatafiles,"glmtot.RData"))
  
}

glmplot1 <- plot_params(glm1, "Player 1")
glmplot2 <- plot_params(glm2, "Player 2")
glmplot3 <- plot_params(glm3, "Player 3")
glmplot4 <- plot_params(glm4, "Player 4")
glmplot5 <- plot_params(glmtot, "Team Effects")

```

```{r glmplot0}
grid.arrange(glmplot1,glmplot2,glmplot3,glmplot4, nrow=2)
```

```{r glmplot, fig.cap = "GLM Posterior Distributions for Four Players", out.width="90%", fig.align="right", cache=TRUE}
glmplot5
```


In the generalized linear model, the intercepts correspond to the log-odds of making a shot when angle is zero (the middle of the court) and the log distance is zero (one foot away from the hoop). 

From these plots, we see that the team-wide 95% credible interval of the angle effect contains zero, and it is therefore probably not predictive of a made shot. The average distance effect shows us that the log-odds of a made shot decrease by $\beta_r =$ `r x <- median(glmtot[["beta_r"]]); abs(round(x,4))` as the log distance increases by one unit and the other predictors remain constant. In the probability scale, this decrease is: 

$$
\frac{\text{e}^{\beta_r}}{1 + \text{e}^{\beta_r}} 
$$

which is equal to `r round(exp(x)/(1+exp(x)), 4)`.

We also see that the 95% credible interval on the effect of distance is completely negative, which follows the intuitive idea that the probability of a made shot significantly decreases as distance from the basket increases. The intercepts show us that there is not a substantial diference in baseline shooting performance between home games and away games.

### Hierarchical Generalized Linear Model

In this hierarchical model, we add random effects to allow the parameters to vary for each player in the dataset. We present the results below using densities of how the four players of interest compare to the population distribution, and by using contour plots that illustrate each player's probability of a made shot given their location on the court for a game at home.

```{r hierfxns, cache=TRUE}
priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2

fit_players <- function(dat = NA, S = 10000, B = 500){
  
  model.player <- function(){
    # N observations
    for(i in 1:N){
      
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
        beta_home[player[i]]*home[i] + 
        beta_r[player[i]]*logr[i] + 
        beta_theta[player[i]]*theta[i]
      
      result[i] ~ dbern(prob[i])
    }
    # priors on random player effects
    for(j in 1:M){
        beta_int[j] ~ dnorm(beta_int0,tau_int)
        beta_home[j]  ~ dnorm(beta_home0, tau_int)
        beta_r[j] ~ dnorm(beta_r0,tau_r)
        beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Hyperpriors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta0 ~ dnorm(mu0theta, 0.1)

    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }

  datlist.player <- list(
                logr = log(dat$r), 
                theta = dat$theta, 
                home = dat$home,
                result = dat$result, 
                player = as.integer(as.factor(dat$globalplayerid)),
                N = nrow(dat), 
                int = rep(1, nrow(dat)), 
                M = n_distinct(dat$globalplayerid),
                mu0r = mu0r,
                mu0theta = mu0theta
                )
  params <- c("beta_int", "beta_home", "beta_r", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- datlist.player$M
  initslist <- list(
    list("beta_int"=rep(0,M), "beta_home"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
          "beta_int0"=0,"beta_home0"=0,"beta_r0"=0, "beta_theta0"=0, 
          "tau_int"=1, "tau_r"=1, "tau_theta"=1
  ))

  sim.player <- jags(data = datlist.player, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits=initslist,
              parameters.to.save = params,
              model.file=model.player
  )
  sim.mcmc.player <- as.data.frame(as.mcmc(sim.player)[[1]])
  
  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")
  sim.mcmc.player <- eval(parse(text=
    
    paste0("sim.mcmc.player %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.player <- sim.mcmc.player[ , order(colnames(sim.mcmc.player))]
  
  factorids <- str_extract_all(names(sim.mcmc.player), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.player) <- str_replace_all(names(sim.mcmc.player), "[[:digit:]]+", as.character(gameids$globalplayerid))
  -
  return(sim.mcmc.player)
  
}

get_player_params <- function(sim.mcmc.hier=NA){

  quants <- c(0.025,0.50,0.975)
  #sim.mcmc.means <- colMeans(sim.mcmc.hier)
  sim.mcmc.meds <- matrix(apply(sim.mcmc.hier, 2, quantile, quants), nrow=length(quants))
  rownames(sim.mcmc.meds) <- as.character(quants*100)
  colnames(sim.mcmc.meds) <- colnames(sim.mcmc.hier)

  playermapparams <- melt(sim.mcmc.meds, id="") %>%
    mutate(globalplayerid = as.numeric(str_extract_all(Var2, "[[:digit:]]+")),
           param = as.character(str_extract_all(Var2, "(intA)|(intH)|(r)|(theta)"))) %>%
    dcast(globalplayerid ~ param + Var1)
  
  colnames(playermapparams) <- gsub("_2.5", "_lo", colnames(playermapparams)) %>%
    gsub(x=., "_50", "") %>%
    gsub(x=., "_97.5","_hi")
  
  #because of an error in the definition of angle, theta actually = -theta
  playermapparams %>% mutate(theta = -theta,
                             theta_hi_save = theta_hi,
                             theta_hi = -theta_lo,
                             theta_lo = -theta_hi_save,
                             theta_hi_save = NULL)
  
  return(playermapparams)
}

if(!load_chains){
  
  player.mcmc <- fit_players(dat = Xtrain)
  player.params <- get_player_params(player.mcmc)
  
  save(player.mcmc, file=paste0(rdatafiles,"playermcmc.RData"))
  save(player.params, file=paste0(rdatafiles,"playerparams.RData"))

}else{
  
  load(paste0(rdatafiles,"playermcmc.RData"))
  load(paste0(rdatafiles,"playerparams.RData"))
}

fourparams <- merge(playerseasons, player.params ,all=FALSE) %>% select(globalplayerid, intH, intA, r, theta) %>% arrange(-globalplayerid)

```

```{r hierplot, fig.cap = "Population Distribution with Four Player Effects"}

meplotA <- ggplot(data = player.mcmc, aes(x=beta_intA0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intA"]], col="red") + 
  geom_label(data=fourparams, aes(x=intA, y=0, label=1:4)) +
  labs(x="Intercept (Away)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())
  
meplotH <- ggplot(data = player.mcmc, aes(x=beta_intH0)) + 
  geom_density() + 
  geom_vline(xintercept=fourparams[["intH"]], col="red") + 
  geom_label(data=fourparams, aes(x=intH, y=0, label=1:4)) +
  labs(x="Intercept (Home)", y="Density") + 
  theme_bw() + 
  theme(panel.grid = element_blank())

meplotr <- ggplot(data = player.mcmc, aes(x=beta_r0)) + 
  geom_density() + 
  geom_vline(xintercept = fourparams[["r"]], col="red") + 
  geom_label(data=fourparams, aes(x=r, y=0, label=1:4)) +
  labs(x="Distance", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
meplottheta <- ggplot(data = player.mcmc, aes(x= beta_theta0)) + 
  geom_density() + 
  geom_vline(xintercept = -fourparams[["theta"]], col="red") + 
  geom_label(data=fourparams, aes(x= -theta, y=0, label=1:4)) +
  labs(x="Angle", y="Density") + 
  theme_bw() +
  theme(panel.grid = element_blank())
  
grid.arrange(meplotA, meplotH, meplotr, meplottheta, nrow=2)
```

These hierarchical model results show us characteristics of our four high-usage players of interest compared to the population of players in the dataset. For example, the intercept plots show us that Player 2 is excellent at finishing under baseline conditions, but he also has a steeper-than-averge drop in his odds of scoring as his distance from the basket increases. This means that most of his scoring occurs close to the basket. We can also see that Player 1 strongly increases his odds of scoring when his angle is negative, which corresponds to the left side of the basket.

In the figures below, we have contour plots showing players' expected field goal percentages at different locations on the court. Between our four players of interest, we can observe how Player 1 is more effective on the left side of the basket than the others, and how Player 2 has the darkest overall contour plot, suggesting he has the highest probability of scoring among those four.

```{r contfxns, cache=TRUE}

get_raneffs <- function(sim.mcmc = player.mcmc, globalplayerid=NA){
  
  id_inds <- which(grepl(x=names(sim.mcmc), pattern=paste0("\\[",globalplayerid,"\\]")))
  
  #if you can't find the player effects for the input id, use the team effects
  if(length(id_inds) > 0){
    raneffs <- sim.mcmc[,id_inds]
  }else{
    raneffs <- sim.mcmc %>% 
               '['(grepl(x=names(.), pattern=paste0("0")) & 
                  !grepl(x=names(.), pattern="\\["))
  }
  return(raneffs)
}

mcmc_avg <- function(sim.mcmc = player.mcmc, globalplayerid = NA, MLE=FALSE, home=TRUE){
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4
  S <- nrow(sim.mcmc) 
  BETA <- as.matrix(get_raneffs(sim.mcmc, globalplayerid))
  if(MLE){ #faster, but underestimates variance
    S <- 1
    BETA <- matrix(colMeans(BETA), nrow=1)
  }
  
  if(home){
    BETA <- BETA[,c(2,3,4)]
  }else{
    BETA <- BETA[,c(1,3,4)]

  }
  
  PROBSXY <- array(data=NA, dim=c(length(all_x),length(all_y), S))

  # Monte Carlo Average
  for(s in 1:S){
    for(i in 1:length(all_x)){
      for(j in 1:length(all_y)){
        x <- all_x[i]
        y <- all_y[j]
        r <- log(sqrt(x^2+y^2))
        t <- atan(y/x)
        if(x < 0){
          t <- t + pi
        }
        t <- t - pi/2
        t <- -t

        eBx <- exp(-t(BETA[s,]) %*% c(1, r, t))
        #eBx <- exp(-t(colMeans(BETA)) %*% c(1, r, t))
        p <- 1/(1+eBx)
        PROBSXY[i,j,s] <- p
      }
    }
  }

  probsxy <- apply(PROBSXY, c(1,2), mean)
  return(probsxy)
}

plot_contours <- function(probsxy = NA, main=""){
  
  all_x <- seq(-25,25, 1)
  all_y <- seq(0,94/2, 1) - 4

  probsxy_melt <- melt(probsxy, c("x","y"))
  probsxy_melt$x <- rep(all_x, length = nrow(probsxy_melt))
  probsxy_melt$y <- rep(all_y, each = length(all_x))
  all_xn <- seq(min(all_x), max(all_x), length=nrow(probsxy_melt))
  
  #img.path <- "/home/grad/neb20/hothand/index/figure/Basketball-Court-Dimensions2.png"
  img.path <- "./figure/ncaa_bball_court2.png"
  img <- readPNG(img.path)

a <- 0.7
contplot <- ggplot(probsxy_melt, aes(x = -x, y = y, z = value)) +
  annotation_custom(rasterGrob(img,
                               x=0.50, y=0.50,
                               width = .92, height = .92),
                    -Inf, Inf, -Inf, Inf) + 
  geom_tile(aes(fill = value), alpha=a) + # the color gradient
  #stat_contour(bins = 15) + # the lines
  scale_fill_gradient2(low = rgb(1,1,1), # white
                       mid = rgb(1,1,0), # yellow 
                       high= rgb(1,0,0), # red 
                       midpoint=0.45) +
  labs(title = main, y="", x="") +
  guides(fill = guide_colorbar(title = "Probability")) + # the legend
  theme_bw() + 
  theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text = element_blank(), axis.ticks = element_blank())

  contplot
}

if(!load_chains){
  avg1 <- mcmc_avg(player.mcmc, id1)
  avg2 <- mcmc_avg(player.mcmc, id2)
  avg3 <- mcmc_avg(player.mcmc, id3)
  avg4 <- mcmc_avg(player.mcmc, id4)
  avgtot <- mcmc_avg(player.mcmc, 0)
  
  save(avg1, file=paste0(rdatafiles,"avg1.RData"))
  save(avg2, file=paste0(rdatafiles,"avg2.RData"))
  save(avg3, file=paste0(rdatafiles,"avg3.RData"))
  save(avg4, file=paste0(rdatafiles,"avg4.RData"))
  save(avgtot, file=paste0(rdatafiles,"avgtot.RData"))
  
}else{
  
  load(paste0(rdatafiles,"avg1.RData"))
  load(paste0(rdatafiles,"avg2.RData"))
  load(paste0(rdatafiles,"avg3.RData"))
  load(paste0(rdatafiles,"avg4.RData"))
  load(paste0(rdatafiles,"avgtot.RData"))

}

contplot1 <- plot_contours(avg1, "Player 1")
contplot2 <- plot_contours(avg2, "Player 2")
contplot3 <- plot_contours(avg3, "Player 3")
contplot4 <- plot_contours(avg4, "Player 4")
contplotteam <- plot_contours(avgtot, "Team Effect")
```

```{r contplot0}
grid.arrange(contplot1, contplot2, contplot3, contplot4, nrow=2)
```

```{r contplot, fig.cap = "Contour Plots for Four Players and Population of Players", out.width="90%", fig.align="right"}
contplotteam
```


### Discounted Likelihood Hierarchical Model

The values of $\Delta$ that we use to fit the discounted likelihood models are 0.750, 0.800, 0.850, 0.900, 0.950, and 0.999. We also build an MCMC chain to estimate the posterior using every game as $g_t$. We calculate predictions and fitted values for a particular shot in game $g_i$ using the posterior median of the MCMC chain where $g_i$ is the anchor game $g_t$.

```{r discfxns, cache=TRUE}

priormod <- glm(result ~ log(r) + theta, data=Xtrain %>% filter(as.integer(as.factor(gameid)) < 5), family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["log(r)","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["theta","Estimate"]
tau0r <- summary(priormod)[["coefficients"]]["log(r)","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["theta","Std. Error"]^2


#saves the list by its elements so it will fit in github
save_gamelist <- function(GL=NA, delta_str=NA, g_str=NA, dir = rdatafiles){

  for(g in 1:length(GL)){
    if(is.na(g_str[g])){
      g_str2 <- formatC(g, digits=2, flag="0")
    }else{
      g_str2 <- g_str[g]
    }
    
    game <- GL[[g]]
    save(game, file = paste0(dir,"gamemcmc",delta_str,"_",g_str2,".RData"))
    #giving them all the same workspace name will make it easier to delete them.
  }

}

#takes the elements from the rdata files and formats them into a list
load_gamelist <- function(delta_str=NA, dir = rdatafiles){
  
  localenv <- new.env()
  GL <- list()
  filenames <- paste0(dir,"/",list.files(path=dir, pattern=paste0("gamemcmc", delta_str))) %>% '['(order(.))
  
  for(i in 1:length(filenames)){
    load(filenames[i], envir=localenv)
    GL[[i]] <- localenv$game
    if(length(localenv$game) == 0){
      eval(parse(
        text=paste0("GL[[i]] <- localenv$game.mcmc.",delta_str,"_",formatC(i, digits=2, flag="0"))
      ))
    }

  }
  names(GL) <- as.character(gamemap$gameid)

  return(GL)
}

fit_game <- function(dat = NA, anchor = NA, discount_wt = NA, S = 10000, B = 500){

  model.game <- function(){

    for(i in 1:N){
      delta[i] <- del^abs(games[i]-g0)  # discount rate for game g relative to anchor game g0
      
      # player-level raneffs
      logit(prob[i]) <- beta_int[player[i]]*int[i] + 
                        beta_home[player[i]]*home[i] + 
                        beta_r[player[i]]*logr[i] + 
                        beta_theta[player[i]]*theta[i] 
    
      p1[i] <- prob[i]^result[i]
      p2[i] <- (1-prob[i])^(1-result[i])
      p[i] <- (p1[i] * p2[i])^delta[i]  
      # prob = likelihood, p = discounted likelihood
      
      # closer game index --> larger delta
      # larger discount weight --> larger delta
      # larger delta --> larger effect on likelihood
      # delta=1 --> all shots contribute to the likelihood like a normal independent binomial model.
      # delta=0 --> only the shots taken in the same game contribute to the likelihood
      
      #y[i] <- 1 # "ones trick" dummy outcomes
      y[i] ~ dbern(p[i]) # defines correct discounted likelihood function
    }
    
    #same priors as player model.
    # priors on random player effects
    for(j in 1:M){
      beta_int[j] ~ dnorm(beta_int0,tau_int)
      beta_home[j] ~ dnorm(beta_home0, tau_int)
      beta_r[j] ~ dnorm(beta_r0,tau_r)
      beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_home0  ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance   increases.  
    beta_theta0 ~ dnorm(mu0theta, 0.1)
  
    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
  }
  
  datlist.game <- list(
    int = rep(1, nrow(dat)), 
    logr = log(dat$r), 
    theta = dat$theta, 
    result = dat$result, 
    home = dat$home,
    player = as.integer(as.factor(dat$globalplayerid)),
    N = nrow(dat), 
    M = n_distinct(dat$globalplayerid),
    mu0r = mu0r,
    mu0theta = mu0theta,
    del = discount_wt,
    games = as.integer(as.factor(dat$gameid)),
    g0 = anchor,
    y = rep(1, nrow(dat)) #"phantom data"
  )

  #same params as player model (may need to change)
  params <- c("beta_int","beta_r", "beta_home", "beta_theta","beta_int0","beta_home0","beta_r0", "beta_theta0")

  M <- n_distinct(dat$globalplayerid)
  initslist <- list(list("beta_int"=rep(0,M), "beta_r"=rep(0,M), "beta_theta"=rep(0,M),
                         "beta_int0"=0,"beta_r0"=0, "beta_theta0"=0, 
                         "tau_int"=1, "tau_r"=1, "tau_theta"=1
                         ))

  sim.game <- jags(data = datlist.game, 
              n.iter = S, n.chains = 1, n.burnin = B, n.thin = 1,
              inits = initslist,
              parameters.to.save = params,
              model.file=model.game
  )
  sim.mcmc.game <- as.data.frame(as.mcmc(sim.game)[[1]])

  hometext <- paste0("`beta_intH[",1:M,"]` = `beta_int[",1:M,"]` + `beta_home[",1:M,"]`", collapse=",\n")
  awaytext <- paste0("`beta_intA[",1:M,"]` = `beta_int[",1:M,"]`", collapse=",\n")

  sim.mcmc.game <- eval(parse(text=
    
    paste0("sim.mcmc.game %>%
    mutate(",hometext,", beta_intH0 = beta_int0 + beta_home0)", " %>% rename(",awaytext,", beta_intA0 = beta_int0)")

  )) %>% select(grep("(beta_int)|(beta_theta)|(beta_r)",names(.)))
  
  sim.mcmc.game <- sim.mcmc.game[ , order(colnames(sim.mcmc.game))]
  
  factorids <- str_extract_all(names(sim.mcmc.game), "[[:digit:]]+") %>% as.numeric()
  fids <- data.frame(factorid = factorids, order = 1:length(factorids))
  datmap <- dat %>% 
    mutate(factorid = as.integer(as.factor(globalplayerid))) %>%
    select(globalplayerid, factorid)
  gameids <- merge(datmap, fids, all.x=FALSE,all.y=TRUE) %>% 
    unique() %>% 
    mutate(globalplayerid = ifelse(is.na(globalplayerid),0,globalplayerid)) %>% 
    arrange(order)
  
  names(sim.mcmc.game) <- str_replace_all(names(sim.mcmc.game), "[[:digit:]]+", as.character(gameids$globalplayerid))

  return(sim.mcmc.game)

}

fit_games <- function(dat = NA, discount_wt = NA, gstart = 1, S = 10000, B = 500){
    
  G <- n_distinct(dat$gameid)
  gnames <- unique(dat$gameid)
  M <- n_distinct(dat$globalplayerid)

  game.mcmc.list <- as.list(rep(NA, G))

  for(g in gstart:G){
    print(paste(k0, discount_wt, g, sep=" : "))
    game.mcmc <- fit_game(dat, g, discount_wt, S, B)
    game.mcmc.list[[ g ]] <- game.mcmc
    
    save_gamelist(game.mcmc.list[g], delta_str=1000*discount_wt, g_str=formatC(g, digits=2, flag="0"))
  }
  
  names(game.mcmc.list) <- as.character(gamemap$gameid)
  return(game.mcmc.list)
}

get_game_params <- function(sim.mcmc.list=NA, dat=NA){
  
  G <- length(sim.mcmc.list)
  M <- n_distinct(as.character(str_extract_all(names(sim.mcmc.list[[1]]), "[[:digit:]]+")))

  for(g in 1:G){
    params.game <- get_player_params(sim.mcmc.list[[g]]) %>% filter(!is.na(globalplayerid))
    if(g==1){
       params.season <- data.frame(matrix(nrow = M*G, ncol = ncol(params.game)))
       colnames(params.season) <- c(colnames(params.game))
       gameids <- gamemap %>% arrange(factorid) %>% '[['("gameid")
       params.season$gameid <- rep(gameids, each=M)
     }
     params.season[(M*(g-1) + 1):(M*g), 1:ncol(params.game)] <- params.game
  }
  
  n2 <- dat %>% group_by(gameid, globalplayerid) %>% summarize(nshots = n()) %>% as.data.frame()
  params.season <- merge(params.season, n2, all=TRUE)
  params.season$nshots[is.na(params.season$nshots)] <- 0

  return(params.season)
}

plot_time_effect <- function(game.params = NA, ids = NA, parameters = NA, main=NA, zlab=NA, only_fga_games = TRUE){
  
  if(only_fga_games & ids != 0){
    #only consider this argument if we are looking at individual effects
    game.params <- game.params %>% filter(nshots > 0)
  }
  
  if(length(zlab) == 0){
    zlab <- parameters
  }else if(is.na(zlab[1])){
    zlab <- parameters
  }

  plotdat <- game.params %>% 
    filter(globalplayerid %in% ids) %>% 
    select(gameid, 
           lo  = paste0(parameters,"_lo"),
           mid = paste0(parameters),
           hi  = paste0(parameters,"_hi"),
           globalplayerid) %>%
    melt(id = c("gameid", "globalplayerid")) %>%
    select(globalplayerid, gameid, type = variable, y = value) %>%
    arrange(globalplayerid, gameid, type) %>%
    mutate(clr_p = str_extract(type, "[[:digit:]]+"),
           clr_p = parameters[as.numeric(clr_p)],
           clr_p = ifelse(is.na(clr_p), 0, clr_p),
           clr_p = as.factor(clr_p),
           clr_i = as.factor(globalplayerid))
  
  if(length(ids) == 1 & length(parameters) > 1){
    
    ggplot(data = plotdat, 
           aes(x=as.integer(as.factor(gameid)), 
               y=y, 
               z=type, 
               linetype=(!type %in% paste0("mid", c("",1:length(parameters)))),
               size = as.numeric(type %in% paste0("mid", c("",1:length(parameters)))),
               color=clr_p)) + 
      scale_size(range=c(0.5, 3)) +
      guides(linetype=FALSE, size=FALSE) + 
      geom_line() +   
      theme_bw() +
      labs(title=main, y="Estimate", x="Game Index", color = "Parameters") +
      scale_color_manual(values = 1:length(parameters), labels = zlab) + 
      theme(panel.grid = element_blank())
    
  }else if(length(ids) > 1 & length(parameters) == 1){
    
    ggplot(data = plotdat, 
           aes(x=as.integer(as.factor(gameid)), 
               y=y, 
               z=type, 
               linetype=(!type %in% paste0("mid", c("",1:length(parameters)))),
               size = as.numeric(type %in% paste0("mid", c("",1:length(parameters)))),
               color=clr_i)) + 
      scale_size(range=c(0.5, 3)) +
      guides(linetype=FALSE, size=FALSE) + 
      geom_line() +   
      theme_bw() +
      labs(title=main, y="Estimate", x="Game Index", color = "Players") +
      scale_color_manual(values = 1:length(ids), labels = zlab) + 
      theme(panel.grid = element_blank())

  }
}

if(!load_chains){
  
  eval(parse(
    text=paste0("game.mcmc.list.",deltas_str," <- fit_games(Xtrain,0.",deltas_str,", gstart=1, S=10000, B=500)\n    save_gamelist(game.mcmc.list.",deltas_str,",",deltas_str,");\n")
   ))
  
  eval(parse(
    text=paste0("game.params.",deltas_str," <- get_game_params(dat=Xtrain, game.mcmc.list.",deltas_str,");\n      save(game.params.",deltas_str,", file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))
  
}else{
  
  # eval(parse(
  #   text=paste0("game.mcmc.list.",deltas_str," <- load_gamelist(",deltas_str,");\n")
  # ))
  
  eval(parse(
    text=paste0("load(file='",rdatafiles,"gameparams",deltas_str,".RData');\n")
  ))


}

discplot1 <- plot_time_effect(game.params.750, id=id1, parameter=c("intH", "intA"), main="Player 1")
discplot2 <- plot_time_effect(game.params.750, id=id2, parameters=c("intH", "intA"), main="Player 2")
discplot3 <- plot_time_effect(game.params.750, id=id3, parameters=c("intH", "intA"), main="Player 3")
discplot4 <- plot_time_effect(game.params.750, id=id4, parameters=c("intH", "intA"), main="Player 4")
discplot5 <- plot_time_effect(game.params.750, id=0, parameters=c("intH", "intA"), main="Team Effect")

discplot6 <- plot_time_effect(game.params.999, id=id1, parameters=c("intH", "intA"), main="Player 1")
discplot7 <- plot_time_effect(game.params.999, id=id2, parameters=c("intH", "intA"), main="Player 2")
discplot8 <- plot_time_effect(game.params.999, id=id3, parameters=c("intH", "intA"), main="Player 3")
discplot9 <- plot_time_effect(game.params.999, id=id4, parameters=c("intH", "intA"), main="Player 4")
discplot10 <- plot_time_effect(game.params.999, id=0, parameters=c("intH", "intA"), main="Team Effect")

```

```{r discplot7500}
grid.arrange(discplot1,discplot2,discplot3,discplot4, nrow=2)
```

```{r discplot750, fig.cap="Intercepts for Four Players and Population over Time, $\\Delta$ = 0.750", out.width="90%", fig.align="right"}
discplot5
```

```{r discplot9990}
grid.arrange(discplot6,discplot7,discplot8,discplot9, nrow=2)
```

```{r discplot999, fig.cap="Intercepts for Four Players and Population over Time, $\\Delta$ = 0.999", out.width="90%", fig.align="right"}
discplot10
```

The plots above illustrate how the intercepts change for the four players and for the population over time. They also show how smaller values of $\Delta$ allow for greater variation in parameter values over time.


