# Models {#model}


```{r, init}
library(mvtnorm); library(dplyr); library(ggplot2); library(R2jags); library(pROC)
#generating shot success probabilities
#theta <- matrix(c(-0.5, 1.5, -5.5)) #GLM parameters (intercept, angle, log distance)
datafolder <- "C:/Users/Nathaniel Brown/Documents/important things/DMBBall Data"
githubfolder <- "C:/Users/Nathaniel Brown/Documents/GitHub/thesis-sp18-brown-hothand/"
setwd(githubfolder)
source("sportvu_fxns.R")

id1 <- 887661
id2 <- 842296

```

#### Exploratory Data Analysis

```{r, plots}
plotshotloc <- function(playerid, season){
plot(x=allgameshots$xt[allgameshots$result == 1 & allgameshots$globalplayerid==playerid & allgameshots$season==season],
       y=allgameshots$yt[allgameshots$result == 1 & allgameshots$globalplayerid==playerid & allgameshots$season==season], col = "red", ylab="y", xlab="x", main = paste(playerid, season))

points(x=allgameshots$xt[allgameshots$result == 0 & allgameshots$globalplayerid==playerid & allgameshots$season==season],
       y=allgameshots$yt[allgameshots$result == 0 & allgameshots$globalplayerid==playerid & allgameshots$season==season], col = "blue")
}

plotshottime <- function(playerid, season){
  allgameshots_sub <- allgameshots[allgameshots$globalplayerid==playerid & allgameshots$season==season,]
  Y <- allgameshots_sub$result #zoo::rollmean((allgameshots_sub$result), 4)
  X <- 1:length(Y)
  scatter.smooth(X,Y,span=0.09,type="n", main = paste(playerid, season))
}

```

#### Generalized Linear Model by Shot
```{r, glm, cache=TRUE}
playerid <- id2
seasons <- c(2014,2015,2016,2017)
# Z <- allgameshots %>% filter(globalplayerid == playerid & season %in% seasons) %>% mutate(logr = log(r) - mean(log(r))) %>% select(result, theta, logr)
# #mean center r.
# mod0 <- glm(result ~ 1, data=Z, family="binomial")
# mod1 <- glm(result ~ logr, data=Z, family="binomial")
# mod2 <- (glm(result ~ theta + logr, data=Z, family="binomial")) #high p-values everywhere
# 
# pred0 <- predict(mod0, newdata=Z, type="response")
# pred1 <- predict(mod1, newdata=Z, type="response")
# pred2 <- predict(mod2, newdata=Z, type="response")

plot_params <- function(playerid=NA, playerseason=NA){
  
  Z <- allgameshots %>% filter(globalplayerid == playerid & season == playerseason) %>% mutate(logr = log(r) - mean(log(r))) %>% select(result, theta, logr)
    
  if(nrow(Z) == 0){
    return(NULL)
  }else{
    #mod0 <- glm(result ~ 1, data=Z, family="binomial")
    #mod1 <- glm(result ~ logr, data=Z, family="binomial")
    mod2 <- (glm(result ~ theta + logr, data=Z, family="binomial")) #high p-values everywhere
  
    coefs <- summary(mod2)$coef %>% as.data.frame() %>% mutate(name = rownames(.), mean = Estimate, stderr = `Std. Error`, hi = mean + 1.96*stderr, lo = mean-1.96*stderr) %>% select(name, mean, hi, lo)
  
    ggplot(data = coefs, aes(x=name, y=mean)) + 
      geom_point() + 
      geom_errorbar(aes(ymin=lo, ymax=hi), width=0.5) + 
      geom_abline(intercept=0, slope=0) + 
      labs(title=paste(playerid, playerseason, sep=", "),x="predictor", y="estimate") 
  }
}

for(i in c(id1, id2)){
  for(j in 2014:2017){
    print(plot_params(i,j))
  }
}
```

#### Dynamic Generalized Linear Model by Shot
```{r, dglm, cache=TRUE}

#TO DO:
#send prof west the ft array (location and angle data, and intercept) and the binary y vector data. (check)
#make a mixed effects GLM with random player effect (check?)
#use JAGS or rstan for logistic regression random effects MCMC (check?)

playerid <- id1
Z <- allgameshots %>% filter(globalplayerid == playerid) %>% mutate(logr = log(r) - mean(log(r))) %>% select(theta, logr) %>% cbind(1,.)
X <- allgameshots %>% filter(globalplayerid == playerid) %>% select(x=xt, y=yt)
y <- allgameshots %>% filter(globalplayerid == playerid) %>% mutate(logr = log(r) - mean(log(r))) %>% select(result) %>% '[['(1)

ym <- 94; xm <- 50
shots <- rep(TRUE,nrow(Z)) #no missing shots in this case
tshot <- which(shots)
nshots <- length(tshot)
T <- length(shots)

#generating shot outcomes

iy <- which(y[!is.nan(y)] == 1)

#initial parameters
mod <- (glm(y ~ theta + logr, data=Z, family="binomial")) #high p-values everywhere
theta <- coef(mod)

p <- length(theta)
pscore <- fitted(mod, type="response")
q <- rep(NaN, T)
q[shots] <- pscore

par(xpd=TRUE)
plot(0,0,type="n",xlim = c(0,T),ylim=c(0,1), ylab = "probability", xlab = "time index", main = "GLM Predictions")
points(tshot, q[tshot], pch=4, col = "blue")
points(tshot, y[tshot], pch=1, col = "red")
legend(x=T*.8, y=1.21, legend=c("probability", "outcome"), pch = c(4,1), col=c("blue", "red"))

par(xpd=FALSE)
plot(X[iy,c("x","y")], ylim=c(0,ym), xlim=c(-xm/2,xm/2), col = "red", pch = 3, xlab="x", ylab="y", main = "Makes and Misses")
points(X[-iy,c("x","y")], col ="blue", pch = 1)
abline(h=ym/2)
points(0,0,col="red", cex=2)



#Forward Filtering

#set up DGLM and initial prior
#first, set up covariates per time interval
F <- t(Z)
p <- dim(F)[1]
#theta = state vector (GLM parameters) (px1)
#F = the data...regression vectors for all t...aka the design matrix (pxT)
#G = known evolution matrix ???????
#omega = evolution errors with 0 mean and known variance matrix W
#g(.) = function to map eta to real line (logit)

mt <- theta
Ct <- diag(p)
#mt = prior mean vector
#Ct = prior covariance matrix
#(theta[t-1]|D[t-1]) ~ N(mt[t-1], Ct[t-1])


delta <- 1 #0.99 #discount factor; "streaky parameter"
#forward filtering (FF)
smt <- matrix(rep(0,p*T), nrow=p)           #save post means
sCt <- array(rep(0,p*p*T), dim = c(p,p,T))  #save post covars
spt <- rep(NaN, T)                          #save post prob success
lmlik <- rep(0,T)                           #marg lik per time int
ishot <- 0

rtst <- array(NA, c(T,2))
for(t in 1:T){
  if(t %in% tshot){
    #current shot attempt index, and time
    ishot <- ishot + 1
    ti <- tshot[ishot]
    
    ft <- (F[,ishot]) %*% mt
    At <- Ct %*% F[,ishot]/delta
    qt <- (F[,ishot]) %*% At
    At <- At/as.numeric(qt)
    
    #at = Gt*mt in txtbk, but = mt here.
    #Rt = Gt*Ct[t-1]*Gt' + Wt in txtbk, but = Ct/delta here
    #f = F'at = F'mt
    #q = F'RF = F'Ct F (1/delta)
    #((lambda,theta)' | Dt-1) ~ N( (f, a), ((q, F'C/delta),(CF/delta, C)) )

    #what is mu tho?
    #???????????????????????
    #"the samp dist of Yt depends on thetat only via the single quantity mut
    #prior: (mu|Dt) ~ N(f, q)
    #Vt > 0 is scale parameter aka precision of distribution...
    #but precision of what??? what is b(Yt, Vt?)
    #Q = q + Vt
    #post:  (mu|Dt) ~ N(f*, q*)
    
    #f* = 
    #what is mu???
    #f = F'a which is
    
    #prior mean and var of linear predictor, and adaptive vector
    #compute approx prior Beta(r,s) params; update w/ numerical iterations for exact values
    eft <- exp(ft)   #crude initial values
    rt <- (1+eft)/qt
    st <- rt/eft
    rt <- max(0.5, rt)
    st <- max(0.5, st)
    
    
    

    #fts = ft* = posterior mean of ????
    #qts = qt* = posterior variance of something ???
    #iterative numerical solution (maybe comment out)
    ep <- 0.5; drt <- 1; dst <- 1; xt <- matrix(c(rt, st))
    while(max(drt, dst) < ep){
      r0t <- psigamma(rt,0); s0t <- psigamma(st,0)
      r1t <- psigamma(rt,1); s1t <- psigamma(st,1)
      fxt <- c(r0t-s0t-ft, r1t+s1t-qt)
      Axt <- matrix(c(r1t, -s1t, psigamma(rt, 2), psigamma(st, 2)), ncol=2, byrow = TRUE)
      xt <- xt - solve(Axt, fxt)
      drt <- xt[1] - rt; dst <- xt[2] - st
      rt <- xt[1]; st <- xt[2]
    }
    
    rtst[t,] <- c(rt, st)
    
    # if(rt > 1000){
    #   break
    # }
    
    lmlik[t] <- lgamma(rt+st) - lgamma(rt) - lgamma(st) + 
                lgamma(rt+y[t]) + lgamma(st+1-y[t]) - lgamma(rt+st+1) + 
                lgamma(2) - lgamma(1+y[t]) - lgamma(2-y[t])
    rts <- rt + y[t]; sts <- st + 1-y[t] #posterior beta params
    #convert to mean and variance for linear predictor
    fts <- psigamma(rts,0)-psigamma(sts,0); qts <- psigamma(rts,1)+psigamma(sts,1)
    spt[t] <- rts/(sts+rts)
    
    #update state parameters
    mt <- mt+At%*%(fts-ft)
    Ct <- Ct/delta - (At%*%t(At))*as.numeric(qt-qts)
    Ct <- (Ct + t(Ct))/2
    c(t, rt, st, mt)
    
    if(any(is.nan(mt))){
      print("stop")
      break
    }
    
  }
  smt[,t] <- mt; sCt[,,t] <- Ct #saving
}

par(xpd=TRUE)
plot(smt[1,],type="l", col = "blue", xlab = "shot index", ylab = "online state mean", main = "Dynamic Parameters")
lines(smt[2,],type="l", col = "orange")
lines(smt[3,],type="l", col = "yellow")
legend(x=T*.75, y=4, legend = c("intercept", "angle", "log(distance)"), pch = c(16), col = c("blue", "orange", "yellow"))

plot(0,0,type="n",xlim = c(0,T),ylim=c(0,1), ylab = "probability", xlab = "time index", main = "DGLM Predictions")
points(tshot, spt[tshot], pch=4, col = "blue")
points(tshot, y[tshot], pch=1, col = "red")
legend(x=T*.8, y=1.21, legend=c("probability", "outcome"), pch = c(4,1), col=c("blue", "red"))

#arm::binnedplot(x=spt[tshot], y=y[tshot]-spt[tshot])




#Backward sampling
nmc <- 1000
#save posterior means and posterior success probs
MCtheta <- array(0, c(p, T, nmc)) 
MCq <- array(0, c(T, nmc))

#begin BS at timeunit T
thetat <- rmvnorm(n=nmc, smt[,T], sCt[,,T]) #SOMETIMES sCT[,,T] IS NOT POSITIVE DEFINITE. DEPENDS ON RANDOM SEED.
MCtheta[,T,] <- t(thetat)
MCq[T,] <- 1/(1+exp(-thetat %*% F[,nshots]))

#then recurse backwards
ishot <- nshots + 1
for(t in (T-1):1){
  if(t %in% tshot){
    ht = (1-delta)*t(array(smt[,t], c(dim(smt)[1], nmc))) + delta*thetat
    #run a simulation for each row of ht and each 3rd dim of sCt
    thetat <- t(apply(ht, 1, rmvnorm, n=1, sigma = sCt[,,t]*(1-delta)))
    MCtheta[,t,] <- t(thetat)
    ishot <- ishot - 1; ti <- tshot[ishot]
    MCq[t,] <- 1/(1+exp(-thetat %*% F[,ishot]))
  }
}

#retrospective posterior summaries
#posterior of shot probabilities?
pr <- t(apply(MCq[tshot,], 1, quantile, c(.025, .25, .5, .75, .975))) #get quantiles of each row
plot(0,0, type="n", xlim = c(0,T), ylim=c(0,1), main = "Posterior Probability", ylab="hit rate", xlab="time interval") 
lines(x=tshot, y=pr[,1], col = "gray")
lines(x=tshot, y=pr[,5], col = "gray")
polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])),
        col = "gray", border = NA)
lines(x=tshot, y=pr[,2], col = "black")
lines(x=tshot, y=pr[,4], col = "black")
polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])),
        col = "black", border = NA)
lines(x=tshot, y=pr[,3], col = "red")
points(x=1:T, y=y, pch=1)

#posteriors of parameters from DGLM
posterior_labels <- c("Posterior Intercept", "Posterior Angle", "Posterior Log Distance")
for(j in 1:p){
  
  pr = t(apply(MCtheta[j,tshot,], 1, quantile, c(.025, .25, .5, .75, .975)))
  plot(0,0, type="n", xlim = c(0,T), ylim = range(pr), main = posterior_labels[j], xlab = "time interval", ylab = "state vector element") 
  lines(x=tshot, y=pr[,1], col = "gray")
  lines(x=tshot, y=pr[,5], col = "gray")
  polygon(c(tshot, rev(tshot)), c(pr[,1], rev(pr[,5])),
          col = "gray", border = NA)
  lines(x=tshot, y=pr[,2], col = "black")
  lines(x=tshot, y=pr[,4], col = "black")
  polygon(c(tshot, rev(tshot)), c(pr[,2], rev(pr[,4])),
          col = "black", border = NA)
  points(x=tshot, y=pr[,3], col = "red", pch = 4)
  
}

proc(y,q, main="ROC Curve for GLM")
proc(y,spt, main="ROC Curve for DGLM")
```

#### Hierarchichal Model
```{r, meglm, cache=TRUE}
# TODO:
# for beta priors, build a glm on a few games without player-specific measurements.
#   use means and precisions of these team glm betas as priors for gibbs betas
#   these will give you prior means. and use generally wide prior variances.
# investigate positive beta_r

priormod <- glm(result ~ r + theta, data=allgameshots, family="binomial")
mu0r <- summary(priormod)[["coefficients"]]["r","Estimate"]
mu0theta <- summary(priormod)[["coefficients"]]["r","Std. Error"]
tau0r <- summary(priormod)[["coefficients"]]["r","Std. Error"]^2
tau0theta <- summary(priormod)[["coefficients"]]["r","Std. Error"]^2

# model2 <- function(){
#     # N observations
#     for(i in 1:N){
#       result[i] ~ dbern(prob[i])
#       logit(prob[i]) <- beta_int*int[i] + e_int[player[i]] + beta_r*logr[i] + e_r[player[i]] + beta_theta*theta[i] + e_theta[player[i]] # a random 'e' here or is that implied?
#     }
#     # priors on random player effects
#     for(j in 1:M){
#         e_int[j] ~ dnorm(beta_int,tau)
#         e_r[j] ~ dnorm(beta_r,tau)
#         e_theta[j] ~ dnorm(beta_theta,tau)
#     }
#     # Priors
#     beta_int   ~ dnorm(0.0,0.1)
#     beta_r     ~ dnorm(mu0r,0.1)
#     beta_theta ~ dnorm(mu0theta,0.1)
# 
#     # Hyperpriors
#     tau ~ dgamma(0.1,0.1)
# }

model <- function(){
    # N observations
    for(i in 1:N){
      result[i] ~ dbern(prob[i])
      logit(prob[i]) <- beta_int[player[i]]*int[i] + beta_r[player[i]]*logr[i] + beta_theta[player[i]]*theta[i]
    }
    # priors on random player effects
    for(j in 1:M){
        beta_int[j] ~ dnorm(beta_int0,tau_int)
        beta_r[j] ~ dnorm(beta_r0,tau_r)
        beta_theta[j] ~ dnorm(beta_theta0,tau_theta)
    }
    # Priors
    beta_int0   ~ dnorm(0, 0.1)
    beta_r0     ~ dnorm(mu0r, 0.01) #would not expect a lot of variation in distance parameter between players. Everyone should get worse as distance increases.
    beta_theta0 ~ dnorm(mu0theta, 0.1)

    # Hyperpriors
    tau_int ~ dgamma(10, 100)
    tau_r ~ dgamma(10, 0.2)
    tau_theta ~ dgamma(10, 10)
}

datlist <- list(
                logr = log(allgameshots$r), 
                theta = allgameshots$theta, 
                result = allgameshots$result, 
                player = as.integer(as.factor(allgameshots$globalplayerid)),
                N = nrow(allgameshots), 
                int = rep(1, nrow(allgameshots)), 
                M = n_distinct(allgameshots$globalplayerid),
                mu0r = summary(priormod)[["coefficients"]]["r","Estimate"],
                mu0theta = summary(priormod)[["coefficients"]]["r","Std. Error"],
                tau0r = summary(priormod)[["coefficients"]]["r","Std. Error"]^2,
                tau0theta = summary(priormod)[["coefficients"]]["r","Std. Error"]^2

                )
params <- c("beta_int","beta_r", "beta_theta","beta_int0","beta_r0", "beta_theta0", "tau_int", "tau_r", "tau_theta")


sim <- jags(data = datlist, 
            n.iter = 1000, n.chains = 1, n.burnin = 100,
            #inits=list(list(p = rep(0.5, nrow(P0)))),
            parameters.to.save = params,
            model.file=model
)
sim.mcmc <- as.data.frame(as.mcmc(sim)[[1]])
sim.mcmc.means <- colMeans(sim.mcmc)
sim.mcmc.means[!grepl("\\[", names(sim.mcmc.means))][1:3] -> theta

factorid <- data.frame(
  factorid = as.integer(as.factor(allgameshots$globalplayerid)),
  globalplayerid = allgameshots$globalplayerid
) %>% unique()

playermapshots <- merge(factorid, playermap, by="globalplayerid", all=TRUE)
playermapparams <- playermapshots %>% mutate(int = NA, r = NA, theta = NA)
for(i in 1:nrow(playermapshots)){
  fid <- playermapparams$factorid[i]
  if(!is.na(fid)){
    theta_i <- sim.mcmc.means[grep(paste0("\\[",fid,"\\]"), names(sim.mcmc.means))]
  }else{
    theta_i <- theta
  }
  playermapparams[i,c("int", "r", "theta")] <- theta_i

}

post_prob <- function(newdata=NA){

  
  Z <- merge(newdata, factorid) %>% arrange(time)
  levels <- Z$factorid
  B <- t(apply(as.matrix(levels), 1, function(l){
    matrix(c(sim.mcmc.means[[paste0("beta_int[",l,"]")]],
         sim.mcmc.means[[paste0("beta_r[",l,"]")]],
         sim.mcmc.means[[paste0("beta_theta[",l,"]")]]),ncol=3,byrow=TRUE
    )}
  ))
  
  X <- Z %>% mutate(logr = log(r) - mean(log(r)), int=1) %>% select(int, logr, theta) %>% as.matrix()

  probs <- B %>% '%*%'(t(X)) %>% diag() %>% arm::invlogit()

  # sim.results <- arm::invlogit(sim.mcmc.means[["beta_int"]] + sim.mcmc.means[["beta_r"]] %*% t(Z[["logr"]]) + sim.mcmc.means[["beta_theta"]] %*% t(Z[["theta"]]) + indiv_effect)
  
  return(probs)
}

roc(allgameshots$result, post_prob(allgameshots))
```
